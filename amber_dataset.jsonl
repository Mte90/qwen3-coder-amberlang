{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_309=(\"${!1}\")\n    local value_310=\"${2}\"\n    index_312=0;\n    for element_311 in \"${array_309[@]}\"; do\n        if [ \"$([ \"_${value_310}\" != \"_${element_311}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_312}\"\n            return 0\n        fi\n        (( index_312++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_307=(\"${!1}\")\n    local value_308=\"${2}\"\n    array_find__0_v0 array_307[@] \"${value_308}\"\n    local result_313=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_313 >= 0 ))\"\n    return 0\n}\n\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__24_v0() {\n    local major_271=0\n    local minor_272=0\n    local patch_273=0\n    major_271=${BASH_VERSINFO[0]}\n        minor_272=${BASH_VERSINFO[1]}\n        patch_273=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version24_v0=(\"${major_271}\" \"${minor_272}\" \"${patch_273}\")\n    return 0\n}\n\nreplace__25_v0() {\n    local source_267=\"${1}\"\n    local search_268=\"${2}\"\n    local replace_269=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_270=\"\"\n    bash_version__24_v0 \n    left_comp=(\"${ret_bash_version24_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_270=\"${source_267//\"${search_268}\"/\"${replace_269}\"}\"\n        __status=$?\n    else\n        result_270=\"${source_267//\"${search_268}\"/${replace_269}}\"\n        __status=$?\n    fi\n    ret_replace25_v0=\"${result_270}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__27_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version27_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nreplace_regex__28_v0() {\n    local source_262=\"${1}\"\n    local search_263=\"${2}\"\n    local replace_text_264=\"${3}\"\n    local extended_265=\"${4}\"\n    sed_version__27_v0 \n    local sed_version_266=\"${ret_sed_version27_v0}\"\n    replace__25_v0 \"${search_263}\" \"/\" \"\\\\/\"\n    search_263=\"${ret_replace25_v0}\"\n    replace__25_v0 \"${replace_text_264}\" \"/\" \"\\\\/\"\n    replace_text_264=\"${ret_replace25_v0}\"\n    if [ \"$(( $(( sed_version_266 == __SED_VERSION_GNU_1 )) || $(( sed_version_266 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__25_v0 \"${search_263}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_263=\"${ret_replace25_v0}\"\n    fi\n    if [ \"${extended_265}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_266 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            local command_2\n            command_2=\"$(sed -r -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_2}\"\n            return 0\n        else\n            local command_3\n            command_3=\"$(sed -E -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_3}\"\n            return 0\n        fi\n    else\n        if [ \"$(( $(( sed_version_266 == __SED_VERSION_GNU_1 )) || $(( sed_version_266 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__25_v0 \"${search_263}\" \"\\\\|\" \"|\"\n            search_263=\"${ret_replace25_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n        __status=$?\n        ret_replace_regex28_v0=\"${command_4}\"\n        return 0\n    fi\n}\n\nsplit__29_v0() {\n    local text_279=\"${1}\"\n    local delimiter_280=\"${2}\"\n    local result_281=()\n    IFS=\"${delimiter_280}\" read -rd '' -a result_281 < <(printf %s \"$text_279\")\n    __status=$?\n    ret_split29_v0=(\"${result_281[@]}\")\n    return 0\n}\n\njoin__32_v0() {\n    local list_276=(\"${!1}\")\n    local delimiter_277=\"${2}\"\n    local command_6\n    command_6=\"$(IFS=\"${delimiter_277}\" ; printf \"%s\n\" \"${list_276[*]}\")\"\n    __status=$?\n    ret_join32_v0=\"${command_6}\"\n    return 0\n}\n\ntrim__35_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    __status=$?\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim35_v0=\"${result_15}\"\n    return 0\n}\n\nis_mac_os_mktemp__72_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp72_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp72_v0=0\n    return 0\n}\n\ntemp_dir_create__73_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__35_v0 \"${template_11}\"\n    local ret_trim35_v0__113_8=\"${ret_trim35_v0}\"\n    if [ \"$([ \"_${ret_trim35_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__72_v0 \n    local ret_is_mac_os_mktemp72_v0__119_8=\"${ret_is_mac_os_mktemp72_v0}\"\n    if [ \"${ret_is_mac_os_mktemp72_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_7\n        command_7=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_7}\"\n    else\n        local command_8\n        command_8=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_8}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create73_v0=\"${filename_16}\"\n    return 0\n}\n\nescape_non_glob_chars__76_v0() {\n    local path_261=\"${1}\"\n    replace_regex__28_v0 \"${path_261}\" \"\\\\([^*?/]\\\\)\" \"\\\\\\\\\\\\1\" 0\n    ret_escape_non_glob_chars76_v0=\"${ret_replace_regex28_v0}\"\n    return 0\n}\n\nfile_glob_all__77_v0() {\n    local paths_259=(\"${!1}\")\n    local combined_260=\"\"\n    local __length_9=(\"${paths_259[@]}\")\n    if [ \"$(( ${#__length_9[@]} == 1 ))\" != 0 ]; then\n        escape_non_glob_chars__76_v0 \"${paths_259[0]}\"\n        combined_260=\"${ret_escape_non_glob_chars76_v0}\"\n    else\n        local items_274=()\n        for item_275 in \"${paths_259[@]}\"; do\n            escape_non_glob_chars__76_v0 \"${item_275}\"\n            item_275=\"${ret_escape_non_glob_chars76_v0}\"\n            items_274+=(\"${item_275}\")\n        done\n        join__32_v0 items_274[@] \" \"\n        combined_260=\"${ret_join32_v0}\"\n    fi\n    local command_12\n    command_12=\"$(eval \"for file in ${combined_260}; do [ -e \\\"\\$file\\\" ] && printf \\\"%s\\n\\\" \\\"\\$file\\\"; done\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob_all77_v0=()\n        return \"${__status}\"\n    fi\n    local files_278=\"${command_12}\"\n    split__29_v0 \"${files_278}\" \"\n\"\n    ret_file_glob_all77_v0=(\"${ret_split29_v0[@]}\")\n    return 0\n}\n\nfile_glob__78_v0() {\n    local path_258=\"${1}\"\n    local array_13=(\"${path_258}\")\n    file_glob_all__77_v0 array_13[@]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob78_v0=()\n        return \"${__status}\"\n    fi\n    ret_file_glob78_v0=(\"${ret_file_glob_all77_v0[@]}\")\n    return 0\n}\n\ncompare__129_v0() {\n    local actual_304=(\"${!1}\")\n    local expected_305=(\"${!2}\")\n    local __length_14=(\"${actual_304[@]}\")\n    local __length_15=(\"${expected_305[@]}\")\n    if [ \"$(( ${#__length_14[@]} != ${#__length_15[@]} ))\" != 0 ]; then\n        ret_compare129_v0=0\n        return 0\n    fi\n    for file_306 in \"${expected_305[@]}\"; do\n        array_contains__2_v0 actual_304[@] \"${file_306}\"\n        local ret_array_contains2_v0__10_16=\"${ret_array_contains2_v0}\"\n        if [ \"$(( ! ret_array_contains2_v0__10_16 ))\" != 0 ]; then\n            ret_compare129_v0=0\n            return 0\n        fi\n    done\n    ret_compare129_v0=1\n    return 0\n}\n\ntemp_dir_create__73_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create73_v0}\"\ntouch \"${tmpdir_17}/1st file with spaces.txt\"\ntouch \"${tmpdir_17}/2nd file with spaces.txt\"\ntouch \"${tmpdir_17}/file.txt\"\ntouch \"${tmpdir_17}/file1.txt\"\ntouch \"${tmpdir_17}/file2.txt\"\ntouch \"${tmpdir_17}/file99.txt\"\ntouch \"${tmpdir_17}/other.csv\"\ncd \"${tmpdir_17}\" || exit\nexpected_18=(\"1st file with spaces.txt\" \"2nd file with spaces.txt\")\nfile_glob__78_v0 \"*with spaces*\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"FAILED\"\nfi\nactual_282=(\"${ret_file_glob78_v0[@]}\")\ncompare__129_v0 actual_282[@] expected_18[@]\nret_compare129_v0__37_8=\"${ret_compare129_v0}\"\nif [ \"${ret_compare129_v0__37_8}\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Expected: ${expected_18[*]}\"\n    echo \"Actual: ${actual_282[*]}\"\nfi", "output": "import * from \"std/array\"\nimport * from \"std/fs\"\nimport * from \"std/text\"\n\nfun compare(actual: [Text], expected: [Text]): Bool {\n    if len(actual) != len(expected) {\n        return false\n    }\n    for file in expected {\n        if not array_contains(actual, file) {\n            return false\n        }\n    }\n    return true\n}\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    trust {\n        touch(\"{tmpdir}/1st file with spaces.txt\")\n        touch(\"{tmpdir}/2nd file with spaces.txt\")\n        touch(\"{tmpdir}/file.txt\")\n        touch(\"{tmpdir}/file1.txt\")\n        touch(\"{tmpdir}/file2.txt\")\n        touch(\"{tmpdir}/file99.txt\")\n        touch(\"{tmpdir}/other.csv\")\n    }\n    cd(tmpdir)\n\n    const expected = [\n        \"1st file with spaces.txt\",\n        \"2nd file with spaces.txt\",\n    ]\n    const actual = file_glob(\"*with spaces*\") failed {\n        echo(\"FAILED\")\n    }\n    if compare(actual, expected) {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Expected: {expected}\")\n        echo(\"Actual: {actual}\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_remove_at__5_v0() {\n    local array_14=(\"${1}\")\n    local index_15=\"${2}\"\n    local offset_16=\"$(( index_15 + 1 ))\"\n    eval \"local array_14_deref_11=(\\\"\\${${array_14[0]}[@]}\\\")\"\n    local __length_0=(\"${array_14_deref_11[@]}\")\n    local length_17=\"${#__length_0[@]}\"\n    local slice_upper_1=\"${index_15}\"\n    local slice_offset_2=0\n    local slice_offset_2=$((${slice_offset_2} > 0 ? ${slice_offset_2} : 0))\n    local slice_length_3\n    slice_length_3=\"$(echo \"${slice_upper_1}\" '-' \"${slice_offset_2}\" | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\n    local slice_length_3=$((${slice_length_3} > 0 ? ${slice_length_3} : 0))\n    local slice_upper_4=\"${length_17}\"\n    local slice_offset_5=\"${offset_16}\"\n    local slice_offset_5=$((${slice_offset_5} > 0 ? ${slice_offset_5} : 0))\n    local slice_length_6\n    slice_length_6=\"$(echo \"${slice_upper_4}\" '-' \"${slice_offset_5}\" | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\n    local slice_length_6=$((${slice_length_6} > 0 ? ${slice_length_6} : 0))\n    eval \"local array_14_deref_12=(\\\"\\${${array_14[0]}[@]:\\${slice_offset_2}:\\${slice_length_3}}\\\")\"\n    eval \"local array_14_deref_13=(\\\"\\${${array_14[0]}[@]:\\${slice_offset_5}:\\${slice_length_6}}\\\")\"\n    eval \"${array_14}=(\\\"\\${array_14_deref_12[@]}\\\" \\\"\\${array_14_deref_13[@]}\\\")\"\n}\n\n# Output\n# Array after -5: (4) [zero one two three]\n# Array after -4: (4) [zero one two three]\n# Array after -3: (4) [zero one two three]\n# Array after -2: (4) [zero one two three]\n# Array after -1: (4) [zero one two three]\n# Array after 0: (3) [one two three]\n# Array after 1: (3) [zero two three]\n# Array after 2: (3) [zero one three]\n# Array after 3: (3) [zero one two]\n# Array after 4: (4) [zero one two three]\ntest_remove__13_v0() {\n    local data_12=(\"${!1}\")\n    local index_13=\"${2}\"\n    array_remove_at__5_v0 \"data_12\" \"${index_13}\"\n    local __length_8=(\"${data_12[@]}\")\n    echo \"Array after ${index_13}: (${#__length_8[*]}) [${data_12[*]}]\"\n}\n\nnumbers_0=(\"zero\" \"one\" \"two\" \"three\")\nfor (( index_1=-5; index_1 <= 4; index_1++ )); do\n    test_remove__13_v0 numbers_0[@] \"${index_1}\"\ndone", "output": "import { array_remove_at } from \"std/array\"\n\n// Output\n// Array after -5: (4) [zero one two three]\n// Array after -4: (4) [zero one two three]\n// Array after -3: (4) [zero one two three]\n// Array after -2: (4) [zero one two three]\n// Array after -1: (4) [zero one two three]\n// Array after 0: (3) [one two three]\n// Array after 1: (3) [zero two three]\n// Array after 2: (3) [zero one three]\n// Array after 3: (3) [zero one two]\n// Array after 4: (4) [zero one two three]\n\nfun test_remove(data: [Text], index: Int): Null {\n    array_remove_at(data, index)\n    echo(\"Array after {index}: ({len(data)}) [{data}]\")\n}\n\nmain {\n    const numbers = [\"zero\", \"one\", \"two\", \"three\"]\n    for index in -5..=4 {\n        test_remove(numbers, index)\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_14=(\"${!1}\")\n    local value_15=\"${2}\"\n    index_17=0;\n    for element_16 in \"${array_14[@]}\"; do\n        if [ \"$([ \"_${value_15}\" != \"_${element_16}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_17}\"\n            return 0\n        fi\n        (( index_17++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_12=(\"${!1}\")\n    local value_13=\"${2}\"\n    array_find__0_v0 array_12[@] \"${value_13}\"\n    local result_18=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_18 >= 0 ))\"\n    return 0\n}\n\n# Output\n# Not Found\narray_0=(\"apple\" \"banana cherry\")\narray_contains__2_v0 array_0[@] \"banana\"\nret_array_contains2_v0__8_8=\"${ret_array_contains2_v0}\"\nif [ \"${ret_array_contains2_v0__8_8}\" != 0 ]; then\n    echo \"Found\"\nelse\n    echo \"Not Found\"\nfi", "output": "import * from \"std/array\"\n\n// Output\n// Not Found\n\nmain {\n    const array = [\"apple\", \"banana cherry\"]\n    if array_contains(array, \"banana\") {\n        echo(\"Found\")\n    } else {\n        echo(\"Not Found\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nends_with__24_v0() {\n    local text_5=\"${1}\"\n    local suffix_6=\"${2}\"\n    [[ \"${text_5}\" == *\"${suffix_6}\" ]]\n    __status=$?\n    ret_ends_with24_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nends_with__24_v0 \"hello world\" \"world\"\nret_ends_with24_v0__4_8=\"${ret_ends_with24_v0}\"\nif [ \"${ret_ends_with24_v0__4_8}\" != 0 ]; then\n    echo \"Succeeded\"\nfi", "output": "import * from \"std/text\"\n\nmain {\n    if ends_with(\"hello world\", \"world\") {\n        echo(\"Succeeded\")\n    } \n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nuppercase__13_v0() {\n    local text_4=\"${1}\"\n    ret_uppercase13_v0=\"$(tr '[:lower:]' '[:upper:]' <<< \"${text_4}\")\"\n    return 0\n}\n\n# Output\n# HELLO WORLD\n# -N\nuppercase__13_v0 \"hello world\"\nret_uppercase13_v0__8_10=\"${ret_uppercase13_v0}\"\nprintf '%s\\n' \"${ret_uppercase13_v0__8_10}\"\nuppercase__13_v0 \"-n\"\nret_uppercase13_v0__9_10=\"${ret_uppercase13_v0}\"\nprintf '%s\\n' \"${ret_uppercase13_v0__9_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// HELLO WORLD\n// -N\n\nmain {\n    echo(uppercase(\"hello world\"))\n    echo(uppercase(\"-n\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nfile_read__43_v0() {\n    local path_23=\"${1}\"\n    local command_0\n    command_0=\"$(< \"${path_23}\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_read43_v0=''\n        return \"${__status}\"\n    fi\n    ret_file_read43_v0=\"${command_0}\"\n    return 0\n}\n\nfile_write__44_v0() {\n    local path_20=\"${1}\"\n    local content_21=\"${2}\"\n    local command_1\n    command_1=\"$(printf '%s\n' \"${content_21}\" > \"${path_20}\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_write44_v0=''\n        return \"${__status}\"\n    fi\n    ret_file_write44_v0=\"${command_1}\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_2\n        command_2=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_2}\"\n    else\n        local command_3\n        command_3=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_3}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\n# Output\n# Succeeded\n# 2\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ncd \"${tmpdir_17}\" || exit\nfile_write__44_v0 \"test.txt\" \"Succeeded\"\n__status=$?\nfile_read__43_v0 \"test.txt\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"Failed\"\nfi\nf_24=\"${ret_file_read43_v0}\"\nprintf '%s\\n' \"${f_24}\"\nfile_write__44_v0 \"dash.txt\" \"-E\"\n__status=$?\nfile_read__43_v0 \"dash.txt\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"Failed\"\nfi\nd_25=\"${ret_file_read43_v0}\"\n__length_5=\"${d_25}\"\nprintf '%s\\n' \"${#__length_5}\"", "output": "// Output\n// Succeeded\n// 2\nimport * from \"std/fs\"\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    cd(tmpdir)\n    trust file_write(\"test.txt\", \"Succeeded\")\n    const f = file_read(\"test.txt\") failed {\n        echo(\"Failed\")\n    }\n    echo(f)\n\n    trust file_write(\"dash.txt\", \"-E\")\n    const d = file_read(\"dash.txt\") failed {\n        echo(\"Failed\")\n    }\n    echo(len(d))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nfile_read__43_v0() {\n    local path_23=\"${1}\"\n    local command_0\n    command_0=\"$(< \"${path_23}\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_read43_v0=''\n        return \"${__status}\"\n    fi\n    ret_file_read43_v0=\"${command_0}\"\n    return 0\n}\n\nfile_write__44_v0() {\n    local path_20=\"${1}\"\n    local content_21=\"${2}\"\n    local command_1\n    command_1=\"$(printf '%s\n' \"${content_21}\" > \"${path_20}\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_write44_v0=''\n        return \"${__status}\"\n    fi\n    ret_file_write44_v0=\"${command_1}\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_2\n        command_2=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_2}\"\n    else\n        local command_3\n        command_3=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_3}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ncd \"${tmpdir_17}\" || exit\nfile_write__44_v0 \"test.txt\" \"Succeeded\"\n__status=$?\nfile_read__43_v0 \"test.txt\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"Failed\"\nfi\nf_24=\"${ret_file_read43_v0}\"\nprintf '%s\\n' \"${f_24}\"", "output": "import * from \"std/fs\"\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    cd(tmpdir)\n    trust file_write(\"test.txt\", \"Succeeded\")\n    const f = file_read(\"test.txt\") failed {\n        echo(\"Failed\" )\n    }\n    echo(f)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_0\n        command_0=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_0}\"\n    else\n        local command_1\n        command_1=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_1}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\ninput_prompt__126_v0() {\n    local prompt_20=\"${1}\"\n    read -p \"$prompt_20\" || read -p \"$prompt_20\" < /dev/tty\n    __status=$?\n    local command_2\n    command_2=\"$(printf '%s\n' $REPLY)\"\n    __status=$?\n    ret_input_prompt126_v0=\"${command_2}\"\n    return 0\n}\n\n# Output\n# Hello, Amber\ntemp_dir_create__49_v0 \"amber-input-test-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ntest_file_18=\"${tmpdir_17}/test_input\"\necho \"Amber\" >> ${test_file_18}\n__status=$?\nexec 0< ${test_file_18}\n__status=$?\ninput_prompt__126_v0 \"Please enter your name:\"\nname_21=\"${ret_input_prompt126_v0}\"\necho \"Hello, \"\"${name_21}\"", "output": "import * from \"std/env\"\nimport { temp_dir_create } from \"std/fs\"\n\n// Output\n// Hello, Amber\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-input-test-XXXX\", true, true)?\n    const test_file = \"{tmpdir}/test_input\"\n    trust $ echo \"Amber\" >> {test_file} $\n    trust $ exec 0< {test_file} $\n    const name = input_prompt(\"Please enter your name:\")\n    echo(\"Hello, \" + name)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nmath_round__1_v0() {\n    local number_1=\"${1}\"\n    if [ \"$(echo \"${number_1}\" '>' 0 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" != 0 ]; then\n        ret_math_round1_v0=\"$(bc <<< \"(${number_1}+0.5)/1\")\"\n        return 0\n    fi\n    ret_math_round1_v0=\"$(bc <<< \"(${number_1}-0.5)/1\")\"\n    return 0\n}\n\n# Output\n# 1\n# 2\n# -1\n# -2\nmath_round__1_v0 1.1\nret_math_round1_v0__10_10=\"${ret_math_round1_v0}\"\necho \"${ret_math_round1_v0__10_10}\"\nmath_round__1_v0 1.5\nret_math_round1_v0__11_10=\"${ret_math_round1_v0}\"\necho \"${ret_math_round1_v0__11_10}\"\nmath_round__1_v0 -1.1\nret_math_round1_v0__12_10=\"${ret_math_round1_v0}\"\necho \"${ret_math_round1_v0__12_10}\"\nmath_round__1_v0 -1.5\nret_math_round1_v0__13_10=\"${ret_math_round1_v0}\"\necho \"${ret_math_round1_v0__13_10}\"", "output": "import * from \"std/math\"\n\n// Output\n// 1\n// 2\n// -1\n// -2\n\nmain {\n    echo(math_round(1.1))\n    echo(math_round(1.5))\n    echo(math_round(-1.1))\n    echo(math_round(-1.5))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_extract_at__6_v0() {\n    local array_17=(\"${1}\")\n    local index_18=\"${2}\"\n    eval \"local array_17_deref_12=(\\\"\\${${array_17[0]}[@]}\\\")\"\n    local __length_0=(\"${array_17_deref_12[@]}\")\n    if [ \"$(( $(( index_18 < 0 )) || $(( index_18 >= ${#__length_0[@]} )) ))\" != 0 ]; then\n        ret_array_extract_at6_v0=''\n        return 1\n    fi\n    eval \"local array_17_deref_13=\\\"\\${${array_17[0]}[${index_18}]}\\\"\"\n    local element_19=\"${array_17_deref_13}\"\n    local offset_20=\"$(( index_18 + 1 ))\"\n    eval \"local array_17_deref_14=(\\\"\\${${array_17[0]}[@]}\\\")\"\n    local __length_1=(\"${array_17_deref_14[@]}\")\n    local length_21=\"${#__length_1[@]}\"\n    local slice_upper_2=\"${index_18}\"\n    local slice_offset_3=0\n    local slice_offset_3=$((${slice_offset_3} > 0 ? ${slice_offset_3} : 0))\n    local slice_length_4\n    slice_length_4=\"$(echo \"${slice_upper_2}\" '-' \"${slice_offset_3}\" | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\n    local slice_length_4=$((${slice_length_4} > 0 ? ${slice_length_4} : 0))\n    local slice_upper_5=\"${length_21}\"\n    local slice_offset_6=\"${offset_20}\"\n    local slice_offset_6=$((${slice_offset_6} > 0 ? ${slice_offset_6} : 0))\n    local slice_length_7\n    slice_length_7=\"$(echo \"${slice_upper_5}\" '-' \"${slice_offset_6}\" | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\n    local slice_length_7=$((${slice_length_7} > 0 ? ${slice_length_7} : 0))\n    eval \"local array_17_deref_15=(\\\"\\${${array_17[0]}[@]:\\${slice_offset_3}:\\${slice_length_4}}\\\")\"\n    eval \"local array_17_deref_16=(\\\"\\${${array_17[0]}[@]:\\${slice_offset_6}:\\${slice_length_7}}\\\")\"\n    eval \"${array_17}=(\\\"\\${array_17_deref_15[@]}\\\" \\\"\\${array_17_deref_16[@]}\\\")\"\n    ret_array_extract_at6_v0=\"${element_19}\"\n    return 0\n}\n\n# Output\n# Value at 0: \"zero\" (3) [one two three]\n# Value at 1: \"one\" (3) [zero two three]\n# Value at 2: \"two\" (3) [zero one three]\n# Value at 3: \"three\" (3) [zero one two]\ntest_extract__13_v0() {\n    local data_15=(\"${!1}\")\n    local index_16=\"${2}\"\n    array_extract_at__6_v0 \"data_15\" \"${index_16}\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_test_extract13_v0=''\n        return \"${__status}\"\n    fi\n    local value_22=\"${ret_array_extract_at6_v0}\"\n    local __length_9=(\"${data_15[@]}\")\n    echo \"Value at ${index_16}: \\\"${value_22}\\\" (${#__length_9[*]}) [${data_15[*]}]\"\n}\n\nnumbers_0=(\"zero\" \"one\" \"two\" \"three\")\nfor (( index_1=0; index_1 < 4; index_1++ )); do\n    test_extract__13_v0 numbers_0[@] \"${index_1}\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        exit \"${__status}\"\n    fi\ndone", "output": "import { array_extract_at } from \"std/array\"\n\n// Output\n// Value at 0: \"zero\" (3) [one two three]\n// Value at 1: \"one\" (3) [zero two three]\n// Value at 2: \"two\" (3) [zero one three]\n// Value at 3: \"three\" (3) [zero one two]\n\nfun test_extract(data: [Text], index: Int): Null? {\n    const value = array_extract_at(data, index)?\n    echo(\"Value at {index}: \\\"{value}\\\" ({len(data)}) [{data}]\")\n}\n\nmain {\n    const numbers = [\"zero\", \"one\", \"two\", \"three\"]\n    for index in 0..4 {\n        test_extract(numbers, index)?\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\njoin__8_v0() {\n    local list_5=(\"${!1}\")\n    local delimiter_6=\"${2}\"\n    ret_join8_v0=\"$(IFS=\"${delimiter_6}\" ; printf \"%s\n\" \"${list_5[*]}\")\"\n    return 0\n}\n\n# Output\n# apple,banana,cherry\narray_2=(\"apple\" \"banana\" \"cherry\")\njoin__8_v0 array_2[@] \", \"\nret_join8_v0__7_10=\"${ret_join8_v0}\"\nprintf '%s\\n' \"${ret_join8_v0__7_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// apple,banana,cherry\n\nmain {\n    echo(join([\"apple\", \"banana\", \"cherry\"], \", \"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nprintf__131_v0() {\n    local format_5=\"${1}\"\n    local args_6=(\"${!2}\")\n    args_6=(\"${format_5}\" \"${args_6[@]}\")\n    printf \"${args_6[@]}\"\n}\n\n# Output\n# Hello, Amber!\narray_1=(\"Hello\" \" Amber\")\nprintf__131_v0 \"%s,%s\"'!'\"\n\" array_1[@]", "output": "import * from \"std/env\"\n\n// Output\n// Hello, Amber!\n\nmain {\n    printf(\"%s,%s!\\n\", [\"Hello\", \" Amber\"])\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nhas_failed__129_v0() {\n    local command_4=\"${1}\"\n    eval ${command_4} >/dev/null 2>&1\n    __status=$?\n    ret_has_failed129_v0=\"$(( __status != 0 ))\"\n    return 0\n}\n\n# Output\n# Command failed\nhas_failed__129_v0 \"ls /nonexistent\"\nret_has_failed129_v0__7_8=\"${ret_has_failed129_v0}\"\nif [ \"${ret_has_failed129_v0__7_8}\" != 0 ]; then\n    echo \"Command failed\"\nelse\n    echo \"Command succeeded\"\nfi", "output": "import * from \"std/env\"\n\n// Output\n// Command failed\n\nmain {\n    if has_failed(\"ls /nonexistent\") {\n        echo(\"Command failed\")\n    } else {\n        echo(\"Command succeeded\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nsorted__10_v0() {\n    local array_33=(\"${!1}\")\n    local desc_34=\"${2}\"\n    local version_sort_35=\"${3}\"\n    local __length_0=(\"${array_33[@]}\")\n    if [ \"$(( 0 || $(( ${#__length_0[@]} <= 1 )) ))\" != 0 ]; then\n        ret_sorted10_v0=(\"${array_33[@]}\")\n        return 0\n    fi\n    local desc_flag_36\n    desc_flag_36=\"$(if [ \"${desc_34}\" != 0 ]; then echo \"-r\"; else echo \"\"; fi)\"\n    local sort_flag_37=\"\"\n    if [ \"$(( 1 && version_sort_35 ))\" != 0 ]; then\n        sort_flag_37=\"-V\"\n    fi\n    local result_38=()\n    IFS=\"\n\" read -rd '' -a result_38 < <(printf \"%s\n\" \"${array_33[@]}\" | sort ${sort_flag_37} ${desc_flag_36})\n    ret_sorted10_v0=(\"${result_38[@]}\")\n    return 0\n}\n\nsorted__10_v1() {\n    local array_45=(\"${!1}\")\n    local desc_46=\"${2}\"\n    local version_sort_47=\"${3}\"\n    local __length_2=(\"${array_45[@]}\")\n    if [ \"$(( 0 || $(( ${#__length_2[@]} <= 1 )) ))\" != 0 ]; then\n        ret_sorted10_v1=(\"${array_45[@]}\")\n        return 0\n    fi\n    local desc_flag_48\n    desc_flag_48=\"$(if [ \"${desc_46}\" != 0 ]; then echo \"-r\"; else echo \"\"; fi)\"\n    local sort_flag_49=\"\"\n        sort_flag_49=\"-n\"\n    local result_50=()\n    IFS=\"\n\" read -rd '' -a result_50 < <(printf \"%s\n\" \"${array_45[@]}\" | sort ${sort_flag_49} ${desc_flag_48})\n    ret_sorted10_v1=(\"${result_50[@]}\")\n    return 0\n}\n\nsorted__10_v2() {\n    local array_57=(\"${!1}\")\n    local desc_58=\"${2}\"\n    local version_sort_59=\"${3}\"\n    local __length_4=(\"${array_57[@]}\")\n    if [ \"$(( 0 || $(( ${#__length_4[@]} <= 1 )) ))\" != 0 ]; then\n        ret_sorted10_v2=(\"${array_57[@]}\")\n        return 0\n    fi\n    local desc_flag_60\n    desc_flag_60=\"$(if [ \"${desc_58}\" != 0 ]; then echo \"-r\"; else echo \"\"; fi)\"\n    local sort_flag_61=\"\"\n        sort_flag_61=\"-n\"\n    local result_62=()\n    IFS=\"\n\" read -rd '' -a result_62 < <(printf \"%s\n\" \"${array_57[@]}\" | sort ${sort_flag_61} ${desc_flag_60})\n    ret_sorted10_v2=(\"${result_62[@]}\")\n    return 0\n}\n\nsorted__10_v3() {\n    local array_69=(\"${!1}\")\n    local desc_70=\"${2}\"\n    local version_sort_71=\"${3}\"\n    local __length_6=(\"${array_69[@]}\")\n    if [ \"$(( 0 || $(( ${#__length_6[@]} <= 1 )) ))\" != 0 ]; then\n        ret_sorted10_v3=(\"${array_69[@]}\")\n        return 0\n    fi\n    local desc_flag_72\n    desc_flag_72=\"$(if [ \"${desc_70}\" != 0 ]; then echo \"-r\"; else echo \"\"; fi)\"\n    local sort_flag_73=\"\"\n        sort_flag_73=\"-n\"\n    local result_74=()\n    IFS=\"\n\" read -rd '' -a result_74 < <(printf \"%s\n\" \"${array_69[@]}\" | sort ${sort_flag_73} ${desc_flag_72})\n    ret_sorted10_v3=(\"${result_74[@]}\")\n    return 0\n}\n\nsorted__10_v4() {\n    local array_81=(\"${!1}\")\n    local desc_82=\"${2}\"\n    local version_sort_83=\"${3}\"\n        ret_sorted10_v4=(\"${array_81[@]}\")\n        return 0\n    local desc_flag_84\n    desc_flag_84=\"$(if [ \"${desc_82}\" != 0 ]; then echo \"-r\"; else echo \"\"; fi)\"\n    local sort_flag_85=\"\"\n    local result_86=()\n    IFS=\"\n\" read -rd '' -a result_86 < <(printf \"%s\n\" \"${array_81[@]}\" | sort ${sort_flag_85} ${desc_flag_84})\n    ret_sorted10_v4=(\"${result_86[@]}\")\n    return 0\n}\n\nsort__11_v0() {\n    local array_30=(\"${1}\")\n    local desc_31=\"${2}\"\n    local version_sort_32=\"${3}\"\n    sorted__10_v0 $array_30[@] \"${desc_31}\" \"${version_sort_32}\"\n    eval \"${array_30}=(\\\"\\${ret_sorted10_v0[@]}\\\")\"\n}\n\nsort__11_v1() {\n    local array_42=(\"${1}\")\n    local desc_43=\"${2}\"\n    local version_sort_44=\"${3}\"\n    sorted__10_v1 $array_42[@] \"${desc_43}\" \"${version_sort_44}\"\n    eval \"${array_42}=(\\\"\\${ret_sorted10_v1[@]}\\\")\"\n}\n\nsort__11_v2() {\n    local array_54=(\"${1}\")\n    local desc_55=\"${2}\"\n    local version_sort_56=\"${3}\"\n    sorted__10_v2 $array_54[@] \"${desc_55}\" \"${version_sort_56}\"\n    eval \"${array_54}=(\\\"\\${ret_sorted10_v2[@]}\\\")\"\n}\n\nsort__11_v3() {\n    local array_66=(\"${1}\")\n    local desc_67=\"${2}\"\n    local version_sort_68=\"${3}\"\n    sorted__10_v3 $array_66[@] \"${desc_67}\" \"${version_sort_68}\"\n    eval \"${array_66}=(\\\"\\${ret_sorted10_v3[@]}\\\")\"\n}\n\nsort__11_v4() {\n    local array_78=(\"${1}\")\n    local desc_79=\"${2}\"\n    local version_sort_80=\"${3}\"\n    sorted__10_v4 $array_78[@] \"${desc_79}\" \"${version_sort_80}\"\n    eval \"${array_78}=(\\\"\\${ret_sorted10_v4[@]}\\\")\"\n}\n\n# Output\n# Array length: 7\n# [-5 1 12 2 a c d]\n# Array length: 7\n# [1 2 12 a c d -5]\n# Array length: 7\n# [d c a 2 12 1 -5]\n# Array length: 4\n# [-2 5 7 10]\n# Array length: 4\n# [10 7 5 -2]\n# Array length: 4\n# [-2 5 7 10]\n# Array length: 4\n# [-5.4 2.34 6.1 11.5]\n# Array length: 4\n# [11.5 6.1 2.34 -5.4]\n# Array length: 2\n# [0 1]\n# Array length: 2\n# [ ]\ntest_sort__13_v0() {\n    local arr_27=(\"${!1}\")\n    local desc_28=\"${2}\"\n    local version_sort_29=\"${3}\"\n    sort__11_v0 \"arr_27\" \"${desc_28}\" \"${version_sort_29}\"\n    local __length_9=(\"${arr_27[@]}\")\n    echo \"Array length: ${#__length_9[*]}\"\n    echo \"[${arr_27[*]}]\"\n}\n\ntest_sort__13_v1() {\n    local arr_39=(\"${!1}\")\n    local desc_40=\"${2}\"\n    local version_sort_41=\"${3}\"\n    sort__11_v1 \"arr_39\" \"${desc_40}\" \"${version_sort_41}\"\n    local __length_10=(\"${arr_39[@]}\")\n    echo \"Array length: ${#__length_10[*]}\"\n    echo \"[${arr_39[*]}]\"\n}\n\ntest_sort__13_v2() {\n    local arr_51=(\"${!1}\")\n    local desc_52=\"${2}\"\n    local version_sort_53=\"${3}\"\n    sort__11_v2 \"arr_51\" \"${desc_52}\" \"${version_sort_53}\"\n    local __length_11=(\"${arr_51[@]}\")\n    echo \"Array length: ${#__length_11[*]}\"\n    echo \"[${arr_51[*]}]\"\n}\n\ntest_sort__13_v3() {\n    local arr_63=(\"${!1}\")\n    local desc_64=\"${2}\"\n    local version_sort_65=\"${3}\"\n    sort__11_v3 \"arr_63\" \"${desc_64}\" \"${version_sort_65}\"\n    local __length_12=(\"${arr_63[@]}\")\n    echo \"Array length: ${#__length_12[*]}\"\n    echo \"[${arr_63[*]}]\"\n}\n\ntest_sort__13_v4() {\n    local arr_75=(\"${!1}\")\n    local desc_76=\"${2}\"\n    local version_sort_77=\"${3}\"\n    sort__11_v4 \"arr_75\" \"${desc_76}\" \"${version_sort_77}\"\n    local __length_13=(\"${arr_75[@]}\")\n    echo \"Array length: ${#__length_13[*]}\"\n    echo \"[${arr_75[*]}]\"\n}\n\narray_15=(\"c\" \"d\" \"a\" \"1\" \"12\" \"2\" \"-5\")\ntest_sort__13_v0 array_15[@] 0 0\narray_16=(\"c\" \"d\" \"a\" \"1\" \"12\" \"2\" \"-5\")\ntest_sort__13_v0 array_16[@] 0 1\narray_17=(\"c\" \"d\" \"a\" \"1\" \"12\" \"2\" \"-5\")\ntest_sort__13_v0 array_17[@] 1 0\narray_18=(7 10 5 -2)\ntest_sort__13_v1 array_18[@] 0 0\narray_19=(7 10 5 -2)\ntest_sort__13_v1 array_19[@] 1 0\narray_20=(7 10 5 -2)\ntest_sort__13_v1 array_20[@] 0 1\narray_21=(11.5 6.1 -5.4 2.34)\ntest_sort__13_v2 array_21[@] 0 0\narray_22=(11.5 6.1 -5.4 2.34)\ntest_sort__13_v2 array_22[@] 1 0\narray_23=(1 0)\ntest_sort__13_v3 array_23[@] 0 0\narray_24=('' '')\ntest_sort__13_v4 array_24[@] 0 0", "output": "import { sort } from \"std/array\"\n\n// Output\n// Array length: 7\n// [-5 1 12 2 a c d]\n// Array length: 7\n// [1 2 12 a c d -5]\n// Array length: 7\n// [d c a 2 12 1 -5]\n// Array length: 4\n// [-2 5 7 10]\n// Array length: 4\n// [10 7 5 -2]\n// Array length: 4\n// [-2 5 7 10]\n// Array length: 4\n// [-5.4 2.34 6.1 11.5]\n// Array length: 4\n// [11.5 6.1 2.34 -5.4]\n// Array length: 2\n// [0 1]\n// Array length: 2\n// [ ]\n\nfun test_sort(arr: [], desc: Bool, version_sort: Bool) {\n    sort(arr, desc, version_sort)\n    echo(\"Array length: {len(arr)}\")\n    echo(\"[{arr}]\")\n}\n\nmain {\n    test_sort([\"c\", \"d\", \"a\", \"1\", \"12\", \"2\", \"-5\"], false, false)\n    test_sort([\"c\", \"d\", \"a\", \"1\", \"12\", \"2\", \"-5\"], false, true)\n    test_sort([\"c\", \"d\", \"a\", \"1\", \"12\", \"2\", \"-5\"], true, false)\n    test_sort([7, 10, 5, -2], false, false)\n    test_sort([7, 10, 5, -2], true, false)\n    test_sort([7, 10, 5, -2], false, true)\n    test_sort([11.5, 6.1, -5.4, 2.34], false, false)\n    test_sort([11.5, 6.1, -5.4, 2.34], true, false)\n    test_sort([true, false], false, false)\n    test_sort([null, null], false, false)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntext_contains__17_v0() {\n    local source_25=\"${1}\"\n    local search_26=\"${2}\"\n    [[ \"${source_25}\" == *\"${search_26}\"* ]]\n    __status=$?\n    ret_text_contains17_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\ntext_contains_all__19_v0() {\n    local source_22=\"${1}\"\n    local searches_23=(\"${!2}\")\n    for search_24 in \"${searches_23[@]}\"; do\n        text_contains__17_v0 \"${source_22}\" \"${search_24}\"\n        local ret_text_contains17_v0__301_16=\"${ret_text_contains17_v0}\"\n        if [ \"$(( ! ret_text_contains17_v0__301_16 ))\" != 0 ]; then\n            ret_text_contains_all19_v0=0\n            return 0\n        fi\n    done\n    ret_text_contains_all19_v0=1\n    return 0\n}\n\n# Output\n# None: 0\n# One: 0\n# Right: 1\n# Both: 1\ntest_multiple__37_v0() {\n    local label_19=\"${1}\"\n    local text_20=\"${2}\"\n    local terms_21=(\"${!3}\")\n    text_contains_all__19_v0 \"${text_20}\" terms_21[@]\n    local result_27=\"${ret_text_contains_all19_v0}\"\n    printf '%s\\n' \"${label_19}: ${result_27}\"\n}\n\narray_1=(\"Other\" \"Other\")\ntest_multiple__37_v0 \"None\" \"Hello World\" array_1[@]\narray_2=(\"World\" \"Something\")\ntest_multiple__37_v0 \"One\" \"Hello World\" array_2[@]\narray_3=(\"World\" \"Hello\")\ntest_multiple__37_v0 \"Right\" \"Hello World\" array_3[@]\narray_4=(\"Hello\" \"World\")\ntest_multiple__37_v0 \"Both\" \"Hello World\" array_4[@]", "output": "import { text_contains_all } from \"std/text\"\n\n// Output\n// None: 0\n// One: 0\n// Right: 1\n// Both: 1\n\nfun test_multiple(label, text, terms) {\n    const result = text_contains_all(text, terms)\n    echo(\"{label}: {result}\")\n}\n\nmain {\n    test_multiple(\"None\", \"Hello World\", [\"Other\", \"Other\"])\n    test_multiple(\"One\", \"Hello World\", [\"World\", \"Something\"])\n    test_multiple(\"Right\", \"Hello World\", [\"World\", \"Hello\"])\n    test_multiple(\"Both\", \"Hello World\", [\"Hello\", \"World\"])\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim_right__10_v0() {\n    local text_5=\"${1}\"\n    local result_6=\"\"\n    result_6=\"${text_5%${text_5##*[![:space:]]}}\"\n    ret_trim_right10_v0=\"${result_6}\"\n    return 0\n}\n\ntrim_right__10_v0 \"  hello   world  \"\nret_trim_right10_v0__4_10=\"${ret_trim_right10_v0}\"\nprintf '%s\\n' \"${ret_trim_right10_v0__4_10}\"", "output": "import * from \"std/text\"\n\nmain {\n    echo(trim_right(\"  hello   world  \"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nchar_at__26_v0() {\n    local text_6=\"${1}\"\n    local index_7=\"${2}\"\n    local result_8=\"\"\n    result_8=\"${text_6:${index_7}:1}\"\n    ret_char_at26_v0=\"${result_8}\"\n    return 0\n}\n\n# Output\n# h\n# d\n# o\nchar_at__26_v0 \"hello world\" 0\nret_char_at26_v0__9_10=\"${ret_char_at26_v0}\"\nprintf '%s\\n' \"${ret_char_at26_v0__9_10}\"\nchar_at__26_v0 \"hello world\" -1\nret_char_at26_v0__10_10=\"${ret_char_at26_v0}\"\nprintf '%s\\n' \"${ret_char_at26_v0__10_10}\"\nchar_at__26_v0 \"hello world\" 4\nret_char_at26_v0__11_10=\"${ret_char_at26_v0}\"\nprintf '%s\\n' \"${ret_char_at26_v0__11_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// h \n// d\n// o\n\nmain {\n    echo(char_at(\"hello world\", 0))\n    echo(char_at(\"hello world\", -1))\n    echo(char_at(\"hello world\", 4))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nstarts_with__23_v0() {\n    local text_5=\"${1}\"\n    local prefix_6=\"${2}\"\n    [[ \"${text_5}\" == \"${prefix_6}\"* ]]\n    __status=$?\n    ret_starts_with23_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nstarts_with__23_v0 \"hello world\" \"hello\"\nret_starts_with23_v0__4_8=\"${ret_starts_with23_v0}\"\nif [ \"${ret_starts_with23_v0__4_8}\" != 0 ]; then\n    echo \"Succeeded\"\nfi", "output": "import * from \"std/text\"\n\nmain {\n    if starts_with(\"hello world\", \"hello\") {\n        echo(\"Succeeded\")\n    } \n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nparse_num__15_v0() {\n    local text_6=\"${1}\"\n    local re_int_7=\"^-?[0-9]+\\$\"\n    local re_float_8=\"^-?[0-9]*\\\\.[0-9]+\\$\"\n    [[ ${text_6} =~ ${re_int_7} ]] || [[ ${text_6} =~ ${re_float_8} ]]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_parse_num15_v0=''\n        return \"${__status}\"\n    fi\n    ret_parse_num15_v0=\"${text_6}\"\n    return 0\n}\n\n# Output\n# 123\n# -123\n# 3.14\n# .15\n# -456.789\n# 0\nparse_num__15_v0 \"123\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_parse_num15_v0__12_10=\"${ret_parse_num15_v0}\"\necho \"${ret_parse_num15_v0__12_10}\"\nparse_num__15_v0 \"-123\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_parse_num15_v0__13_10=\"${ret_parse_num15_v0}\"\necho \"${ret_parse_num15_v0__13_10}\"\nparse_num__15_v0 \"3.14\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_parse_num15_v0__14_10=\"${ret_parse_num15_v0}\"\necho \"${ret_parse_num15_v0__14_10}\"\nparse_num__15_v0 \".15\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_parse_num15_v0__15_10=\"${ret_parse_num15_v0}\"\necho \"${ret_parse_num15_v0__15_10}\"\nparse_num__15_v0 \"-456.789\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_parse_num15_v0__16_10=\"${ret_parse_num15_v0}\"\necho \"${ret_parse_num15_v0__16_10}\"\nparse_num__15_v0 \"0\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_parse_num15_v0__17_10=\"${ret_parse_num15_v0}\"\necho \"${ret_parse_num15_v0__17_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// 123\n// -123\n// 3.14\n// .15\n// -456.789\n// 0\n\nmain {\n    echo(parse_num(\"123\")?)\n    echo(parse_num(\"-123\")?)\n    echo(parse_num(\"3.14\")?)\n    echo(parse_num(\".15\")?)\n    echo(parse_num(\"-456.789\")?)\n    echo(parse_num(\"0\")?)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_14=(\"${!1}\")\n    local value_15=\"${2}\"\n    index_17=0;\n    for element_16 in \"${array_14[@]}\"; do\n        if [ \"$([ \"_${value_15}\" != \"_${element_16}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_17}\"\n            return 0\n        fi\n        (( index_17++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_12=(\"${!1}\")\n    local value_13=\"${2}\"\n    array_find__0_v0 array_12[@] \"${value_13}\"\n    local result_18=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_18 >= 0 ))\"\n    return 0\n}\n\narray_0=(\"apple\" \"banana cherry\")\narray_contains__2_v0 array_0[@] \"banana cherry\"\nret_array_contains2_v0__5_8=\"${ret_array_contains2_v0}\"\nif [ \"${ret_array_contains2_v0__5_8}\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Not Found\"\nfi", "output": "import * from \"std/array\"\n\nmain {\n    const array = [\"apple\", \"banana cherry\"]\n    if array_contains(array, \"banana cherry\") {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Not Found\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__0_v0() {\n    local major_469=0\n    local minor_470=0\n    local patch_471=0\n    major_469=${BASH_VERSINFO[0]}\n        minor_470=${BASH_VERSINFO[1]}\n        patch_471=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version0_v0=(\"${major_469}\" \"${minor_470}\" \"${patch_471}\")\n    return 0\n}\n\nreplace__1_v0() {\n    local source_465=\"${1}\"\n    local search_466=\"${2}\"\n    local replace_467=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_468=\"\"\n    bash_version__0_v0 \n    left_comp=(\"${ret_bash_version0_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_468=\"${source_465//\"${search_466}\"/\"${replace_467}\"}\"\n        __status=$?\n    else\n        result_468=\"${source_465//\"${search_466}\"/${replace_467}}\"\n        __status=$?\n    fi\n    ret_replace1_v0=\"${result_468}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__3_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version3_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    __status=$?\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nmatch_regex__20_v0() {\n    local source_461=\"${1}\"\n    local search_462=\"${2}\"\n    local extended_463=\"${3}\"\n    sed_version__3_v0 \n    local sed_version_464=\"${ret_sed_version3_v0}\"\n    replace__1_v0 \"${search_462}\" \"/\" \"\\\\/\"\n    search_462=\"${ret_replace1_v0}\"\n    local output_472=\"\"\n    if [ \"$(( $(( sed_version_464 == __SED_VERSION_GNU_1 )) || $(( sed_version_464 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__1_v0 \"${search_462}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_462=\"${ret_replace1_v0}\"\n    fi\n    if [ \"${extended_463}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_464 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            # '\\b' is not in POSIX standards. Disable it\n            replace__1_v0 \"${search_462}\" \"\\\\b\" \"\\\\b\"\n            search_462=\"${ret_replace1_v0}\"\n            local command_2\n            command_2=\"$(sed -r -ne \"/${search_462}/p\" <<<\"${source_461}\")\"\n            __status=$?\n            output_472=\"${command_2}\"\n        else\n            local command_3\n            command_3=\"$(sed -E -ne \"/${search_462}/p\" <<<\"${source_461}\")\"\n            __status=$?\n            output_472=\"${command_3}\"\n        fi\n    else\n        if [ \"$(( $(( sed_version_464 == __SED_VERSION_GNU_1 )) || $(( sed_version_464 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__1_v0 \"${search_462}\" \"\\\\|\" \"|\"\n            search_462=\"${ret_replace1_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -ne \"/${search_462}/p\" <<<\"${source_461}\")\"\n        __status=$?\n        output_472=\"${command_4}\"\n    fi\n    if [ \"$([ \"_${output_472}\" == \"_\" ]; echo $?)\" != 0 ]; then\n        ret_match_regex20_v0=1\n        return 0\n    fi\n    ret_match_regex20_v0=0\n    return 0\n}\n\nfile_exists__42_v0() {\n    local path_475=\"${1}\"\n    [ -f \"${path_475}\" ]\n    __status=$?\n    ret_file_exists42_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_5\n        command_5=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_5}\"\n    else\n        local command_6\n        command_6=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_6}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\nfile_extract__55_v0() {\n    local path_479=\"${1}\"\n    local target_480=\"${2}\"\n    file_exists__42_v0 \"${path_479}\"\n    local ret_file_exists42_v0__229_8=\"${ret_file_exists42_v0}\"\n    if [ \"${ret_file_exists42_v0__229_8}\" != 0 ]; then\n        match_regex__20_v0 \"${path_479}\" \"\\\\.(tar\\\\.bz2|tbz|tbz2)\\$\" 1\n        local ret_match_regex20_v0__231_13=\"${ret_match_regex20_v0}\"\n        match_regex__20_v0 \"${path_479}\" \"\\\\.(tar\\\\.gz|tgz)\\$\" 1\n        local ret_match_regex20_v0__232_13=\"${ret_match_regex20_v0}\"\n        match_regex__20_v0 \"${path_479}\" \"\\\\.(tar\\\\.xz|txz)\\$\" 1\n        local ret_match_regex20_v0__233_13=\"${ret_match_regex20_v0}\"\n        match_regex__20_v0 \"${path_479}\" \"\\\\.bz2\\$\" 0\n        local ret_match_regex20_v0__234_13=\"${ret_match_regex20_v0}\"\n        match_regex__20_v0 \"${path_479}\" \"\\\\.deb\\$\" 0\n        local ret_match_regex20_v0__235_13=\"${ret_match_regex20_v0}\"\n        match_regex__20_v0 \"${path_479}\" \"\\\\.gz\\$\" 0\n        local ret_match_regex20_v0__236_13=\"${ret_match_regex20_v0}\"\n        match_regex__20_v0 \"${path_479}\" \"\\\\.rar\\$\" 0\n        local ret_match_regex20_v0__237_13=\"${ret_match_regex20_v0}\"\n        match_regex__20_v0 \"${path_479}\" \"\\\\.rpm\\$\" 0\n        local ret_match_regex20_v0__238_13=\"${ret_match_regex20_v0}\"\n        match_regex__20_v0 \"${path_479}\" \"\\\\.tar\\$\" 0\n        local ret_match_regex20_v0__239_13=\"${ret_match_regex20_v0}\"\n        match_regex__20_v0 \"${path_479}\" \"\\\\.xz\\$\" 0\n        local ret_match_regex20_v0__240_13=\"${ret_match_regex20_v0}\"\n        match_regex__20_v0 \"${path_479}\" \"\\\\.7z\\$\" 0\n        local ret_match_regex20_v0__241_13=\"${ret_match_regex20_v0}\"\n        match_regex__20_v0 \"${path_479}\" \"\\\\.\\\\(zip\\\\|war\\\\|jar\\\\)\\$\" 0\n        local ret_match_regex20_v0__242_13=\"${ret_match_regex20_v0}\"\n        if [ \"${ret_match_regex20_v0__231_13}\" != 0 ]; then\n            tar xvjf \"${path_479}\" -C \"${target_480}\"\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                ret_file_extract55_v0=''\n                return \"${__status}\"\n            fi\n        elif [ \"${ret_match_regex20_v0__232_13}\" != 0 ]; then\n            tar xzf \"${path_479}\" -C \"${target_480}\"\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                ret_file_extract55_v0=''\n                return \"${__status}\"\n            fi\n        elif [ \"${ret_match_regex20_v0__233_13}\" != 0 ]; then\n            tar xJf \"${path_479}\" -C \"${target_480}\"\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                ret_file_extract55_v0=''\n                return \"${__status}\"\n            fi\n        elif [ \"${ret_match_regex20_v0__234_13}\" != 0 ]; then\n            bunzip2 \"${path_479}\"\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                ret_file_extract55_v0=''\n                return \"${__status}\"\n            fi\n        elif [ \"${ret_match_regex20_v0__235_13}\" != 0 ]; then\n            dpkg-deb -xv \"${path_479}\" \"${target_480}\"\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                ret_file_extract55_v0=''\n                return \"${__status}\"\n            fi\n        elif [ \"${ret_match_regex20_v0__236_13}\" != 0 ]; then\n            gunzip \"${path_479}\"\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                ret_file_extract55_v0=''\n                return \"${__status}\"\n            fi\n        elif [ \"${ret_match_regex20_v0__237_13}\" != 0 ]; then\n            unrar x \"${path_479}\" \"${target_480}\"\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                ret_file_extract55_v0=''\n                return \"${__status}\"\n            fi\n        elif [ \"${ret_match_regex20_v0__238_13}\" != 0 ]; then\n            rpm2cpio \"${path_479}\" | cpio -idm\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                ret_file_extract55_v0=''\n                return \"${__status}\"\n            fi\n        elif [ \"${ret_match_regex20_v0__239_13}\" != 0 ]; then\n            tar xf \"${path_479}\" -C \"${target_480}\"\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                ret_file_extract55_v0=''\n                return \"${__status}\"\n            fi\n        elif [ \"${ret_match_regex20_v0__240_13}\" != 0 ]; then\n            xz --decompress \"${path_479}\"\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                ret_file_extract55_v0=''\n                return \"${__status}\"\n            fi\n        elif [ \"${ret_match_regex20_v0__241_13}\" != 0 ]; then\n            7z -y \"${path_479}\" -o \"${target_480}\"\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                ret_file_extract55_v0=''\n                return \"${__status}\"\n            fi\n        elif [ \"${ret_match_regex20_v0__242_13}\" != 0 ]; then\n            unzip \"${path_479}\" -d \"${target_480}\"\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                ret_file_extract55_v0=''\n                return \"${__status}\"\n            fi\n        else\n            echo \"Error: Unsupported file type\"\n            ret_file_extract55_v0=''\n            return 3\n        fi\n    else\n        echo \"Error: File not found\"\n        ret_file_extract55_v0=''\n        return 2\n    fi\n}\n\nfile_compress__56_v0() {\n    local files_459=(\"${!1}\")\n    local target_460=\"${2}\"\n    match_regex__20_v0 \"${target_460}\" \"\\\\.(tar\\\\.bz2|tbz|tbz2)\\$\" 1\n    local ret_match_regex20_v0__264_9=\"${ret_match_regex20_v0}\"\n    match_regex__20_v0 \"${target_460}\" \"\\\\.(tar\\\\.gz|tgz)\\$\" 1\n    local ret_match_regex20_v0__265_9=\"${ret_match_regex20_v0}\"\n    match_regex__20_v0 \"${target_460}\" \"\\\\.(tar\\\\.xz|txz)\\$\" 1\n    local ret_match_regex20_v0__266_9=\"${ret_match_regex20_v0}\"\n    match_regex__20_v0 \"${target_460}\" \"\\\\.tar\\$\" 1\n    local ret_match_regex20_v0__267_9=\"${ret_match_regex20_v0}\"\n    match_regex__20_v0 \"${target_460}\" \"\\\\.bz2\\$\" 0\n    local ret_match_regex20_v0__268_9=\"${ret_match_regex20_v0}\"\n    match_regex__20_v0 \"${target_460}\" \"\\\\.gz\\$\" 0\n    local ret_match_regex20_v0__269_9=\"${ret_match_regex20_v0}\"\n    match_regex__20_v0 \"${target_460}\" \"\\\\.xz\\$\" 0\n    local ret_match_regex20_v0__270_9=\"${ret_match_regex20_v0}\"\n    match_regex__20_v0 \"${target_460}\" \"\\\\.7z\\$\" 0\n    local ret_match_regex20_v0__271_9=\"${ret_match_regex20_v0}\"\n    match_regex__20_v0 \"${target_460}\" \"\\\\.(zip|war|jar)\\$\" 1\n    local ret_match_regex20_v0__272_9=\"${ret_match_regex20_v0}\"\n    match_regex__20_v0 \"${target_460}\" \"\\\\.rar\\$\" 0\n    local ret_match_regex20_v0__273_9=\"${ret_match_regex20_v0}\"\n    match_regex__20_v0 \"${target_460}\" \"\\\\.deb\\$\" 0\n    local ret_match_regex20_v0__274_9=\"${ret_match_regex20_v0}\"\n    match_regex__20_v0 \"${target_460}\" \"\\\\.rpm\\$\" 0\n    local ret_match_regex20_v0__275_9=\"${ret_match_regex20_v0}\"\n    if [ \"${ret_match_regex20_v0__264_9}\" != 0 ]; then\n        tar -cjf \"${target_460}\" ${files_459[@]} >/dev/null 2>&1\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_compress56_v0=''\n            return \"${__status}\"\n        fi\n    elif [ \"${ret_match_regex20_v0__265_9}\" != 0 ]; then\n        tar -czf \"${target_460}\" ${files_459[@]} >/dev/null 2>&1\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_compress56_v0=''\n            return \"${__status}\"\n        fi\n    elif [ \"${ret_match_regex20_v0__266_9}\" != 0 ]; then\n        tar -cJf \"${target_460}\" ${files_459[@]} >/dev/null 2>&1\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_compress56_v0=''\n            return \"${__status}\"\n        fi\n    elif [ \"${ret_match_regex20_v0__267_9}\" != 0 ]; then\n        tar -cf \"${target_460}\" ${files_459[@]}\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_compress56_v0=''\n            return \"${__status}\"\n        fi\n    elif [ \"${ret_match_regex20_v0__268_9}\" != 0 ]; then\n        bzip2 -k -c ${files_459[@]} > \"${target_460}\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_compress56_v0=''\n            return \"${__status}\"\n        fi\n    elif [ \"${ret_match_regex20_v0__269_9}\" != 0 ]; then\n        gzip -k -c ${files_459[@]} > \"${target_460}\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_compress56_v0=''\n            return \"${__status}\"\n        fi\n    elif [ \"${ret_match_regex20_v0__270_9}\" != 0 ]; then\n        xz -k -c ${files_459[@]} > \"${target_460}\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_compress56_v0=''\n            return \"${__status}\"\n        fi\n    elif [ \"${ret_match_regex20_v0__271_9}\" != 0 ]; then\n        7z a -y \"${target_460}\" ${files_459[@]} >/dev/null 2>&1\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_compress56_v0=''\n            return \"${__status}\"\n        fi\n    elif [ \"${ret_match_regex20_v0__272_9}\" != 0 ]; then\n        zip -r \"${target_460}\" ${files_459[@]} >/dev/null 2>&1\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_compress56_v0=''\n            return \"${__status}\"\n        fi\n    elif [ \"${ret_match_regex20_v0__273_9}\" != 0 ]; then\n        rar a -y \"${target_460}\" ${files_459[@]} >/dev/null 2>&1\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_compress56_v0=''\n            return \"${__status}\"\n        fi\n    elif [ \"${ret_match_regex20_v0__274_9}\" != 0 ]; then\n        dpkg-deb --build ${files_459[@]} \"${target_460}\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_compress56_v0=''\n            return \"${__status}\"\n        fi\n    elif [ \"${ret_match_regex20_v0__275_9}\" != 0 ]; then\n        rpmbuild -bb --buildroot=\"${files_459[@]}\" -D \"_rpmdir=$(dirname \"${target_460}\")\" specfile.spec\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_compress56_v0=''\n            return \"${__status}\"\n        fi\n    else\n        echo \"Error: Unsupported file type\"\n        ret_file_compress56_v0=''\n        return 3\n    fi\n}\n\ntemp_dir_create__49_v0 \"amber-test-src-XXXX\" 0 0\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nsrc_dir_17=\"${ret_temp_dir_create49_v0}\"\ncd \"${src_dir_17}\" || exit\ntouch \"test.txt\"\narray_8=(\"test.txt\")\nfile_compress__56_v0 array_8[@] \"filename.tar.gz\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\npackage_473=\"${src_dir_17}/filename.tar.gz\"\nfile_exists__42_v0 \"${package_473}\"\nret_file_exists42_v0__10_12=\"${ret_file_exists42_v0}\"\nif [ \"$(( ! ret_file_exists42_v0__10_12 ))\" != 0 ]; then\n    echo \"Compression falis; ${package_473} does not exists\"\nfi\ntemp_dir_create__49_v0 \"amber-test-dist-XXXX\" 0 0\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ndist_dir_476=\"${ret_temp_dir_create49_v0}\"\nfile_extract__55_v0 \"${package_473}\" \"${dist_dir_476}\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nfile_exists__42_v0 \"${dist_dir_476}/test.txt\"\nret_file_exists42_v0__17_8=\"${ret_file_exists42_v0}\"\nif [ \"${ret_file_exists42_v0__17_8}\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Extraction fails: ${dist_dir_476}/test.txt does not exist\"\nfi\nrm -rf ${src_dir_17} ${dist_dir_476}\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi", "output": "import * from \"std/fs\"\nimport { array_contains } from \"std/array\"\n\nmain {\n    const src_dir = temp_dir_create(\"amber-test-src-XXXX\")?\n    cd(src_dir)\n    touch(\"test.txt\")\n    file_compress([\"test.txt\"],\"filename.tar.gz\")?\n    const package = \"{src_dir}/filename.tar.gz\"\n    if not file_exists(package) {\n        echo(\"Compression falis; {package} does not exists\")\n    }\n\n    const dist_dir = temp_dir_create(\"amber-test-dist-XXXX\")?\n    file_extract(package, dist_dir)?\n\n    if file_exists(\"{dist_dir}/test.txt\") {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Extraction fails: {dist_dir}/test.txt does not exist\")\n    }\n\n    $ rm -rf {src_dir} {dist_dir} $?\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_filled__9_v0() {\n    local size_3=\"${1}\"\n    local value_4=\"${2}\"\n    local array_5=(\"${value_4}\")\n    # Used for type casting array\n    array_5=(\"${array_5[@]:0:0}\")\n    # Resetting the array size to 0\n    if [ \"$(( $(( size_3 <= 0 )) || $(( ! 1 )) ))\" != 0 ]; then\n        ret_array_filled9_v0=(\"${array_5[@]}\")\n        return 0\n    fi\n    local __range_start_6=0\n    local __range_end_6=\"${size_3}\"\n    local __dir_6=$(( ${__range_start_6} <= ${__range_end_6} ? 1 : -1 ))\n    for (( ____6=${__range_start_6}; ____6 * ${__dir_6} < ${__range_end_6} * ${__dir_6}; ____6+=${__dir_6} )); do\n        local array_1=(\"${value_4}\")\n        array_5+=(\"${array_1[@]}\")\ndone\n    ret_array_filled9_v0=(\"${array_5[@]}\")\n    return 0\n}\n\narray_filled__9_v1() {\n    local size_7=\"${1}\"\n    local value_8=\"${2}\"\n    local array_9=(\"${value_8}\")\n    # Used for type casting array\n    array_9=(\"${array_9[@]:0:0}\")\n    # Resetting the array size to 0\n    if [ \"$(( $(( size_7 <= 0 )) || $(( ! 1 )) ))\" != 0 ]; then\n        ret_array_filled9_v1=(\"${array_9[@]}\")\n        return 0\n    fi\n    local __range_start_10=0\n    local __range_end_10=\"${size_7}\"\n    local __dir_10=$(( ${__range_start_10} <= ${__range_end_10} ? 1 : -1 ))\n    for (( ____10=${__range_start_10}; ____10 * ${__dir_10} < ${__range_end_10} * ${__dir_10}; ____10+=${__dir_10} )); do\n        local array_3=(\"${value_8}\")\n        array_9+=(\"${array_3[@]}\")\ndone\n    ret_array_filled9_v1=(\"${array_9[@]}\")\n    return 0\n}\n\narray_filled__9_v2() {\n    local size_11=\"${1}\"\n    local value_12=\"${2}\"\n    local array_13=(\"${value_12}\")\n    # Used for type casting array\n    array_13=(\"${array_13[@]:0:0}\")\n    # Resetting the array size to 0\n    if [ \"$(( $(( size_11 <= 0 )) || $(( ! 1 )) ))\" != 0 ]; then\n        ret_array_filled9_v2=(\"${array_13[@]}\")\n        return 0\n    fi\n    local __range_start_14=0\n    local __range_end_14=\"${size_11}\"\n    local __dir_14=$(( ${__range_start_14} <= ${__range_end_14} ? 1 : -1 ))\n    for (( ____14=${__range_start_14}; ____14 * ${__dir_14} < ${__range_end_14} * ${__dir_14}; ____14+=${__dir_14} )); do\n        local array_5=(\"${value_12}\")\n        array_13+=(\"${array_5[@]}\")\ndone\n    ret_array_filled9_v2=(\"${array_13[@]}\")\n    return 0\n}\n\narray_filled__9_v3() {\n    local size_15=\"${1}\"\n    local value_16=\"${2}\"\n    local array_17=(\"${value_16}\")\n    # Used for type casting array\n    array_17=(\"${array_17[@]:0:0}\")\n    # Resetting the array size to 0\n    if [ \"$(( $(( size_15 <= 0 )) || $(( ! 1 )) ))\" != 0 ]; then\n        ret_array_filled9_v3=(\"${array_17[@]}\")\n        return 0\n    fi\n    local __range_start_18=0\n    local __range_end_18=\"${size_15}\"\n    local __dir_18=$(( ${__range_start_18} <= ${__range_end_18} ? 1 : -1 ))\n    for (( ____18=${__range_start_18}; ____18 * ${__dir_18} < ${__range_end_18} * ${__dir_18}; ____18+=${__dir_18} )); do\n        local array_7=(\"${value_16}\")\n        array_17+=(\"${array_7[@]}\")\ndone\n    ret_array_filled9_v3=(\"${array_17[@]}\")\n    return 0\n}\n\narray_filled__9_v4() {\n    local size_19=\"${1}\"\n    local value_20=\"${2}\"\n    local array_21=(\"${value_20}\")\n    # Used for type casting array\n    array_21=(\"${array_21[@]:0:0}\")\n    # Resetting the array size to 0\n    if [ \"$(( $(( size_19 <= 0 )) || $(( ! 1 )) ))\" != 0 ]; then\n        ret_array_filled9_v4=(\"${array_21[@]}\")\n        return 0\n    fi\n    local __range_start_22=0\n    local __range_end_22=\"${size_19}\"\n    local __dir_22=$(( ${__range_start_22} <= ${__range_end_22} ? 1 : -1 ))\n    for (( ____22=${__range_start_22}; ____22 * ${__dir_22} < ${__range_end_22} * ${__dir_22}; ____22+=${__dir_22} )); do\n        local array_9=(\"${value_20}\")\n        array_21+=(\"${array_9[@]}\")\ndone\n    ret_array_filled9_v4=(\"${array_21[@]}\")\n    return 0\n}\n\n# Output\n# [0 0 0]\n# [0 0 0]\n# [.5 .5 .5]\n# [a a a]\n# [0 0 0]\n# [  ]\narray_filled__9_v0 3 0\nret_array_filled9_v0__12_13=(\"${ret_array_filled9_v0[@]}\")\necho \"[${ret_array_filled9_v0__12_13[*]}]\"\narray_filled__9_v0 3 0\nret_array_filled9_v0__13_13=(\"${ret_array_filled9_v0[@]}\")\necho \"[${ret_array_filled9_v0__13_13[*]}]\"\narray_filled__9_v1 3 .5\nret_array_filled9_v1__14_13=(\"${ret_array_filled9_v1[@]}\")\necho \"[${ret_array_filled9_v1__14_13[*]}]\"\narray_filled__9_v2 3 \"a\"\nret_array_filled9_v2__15_13=(\"${ret_array_filled9_v2[@]}\")\necho \"[${ret_array_filled9_v2__15_13[*]}]\"\narray_filled__9_v3 3 0\nret_array_filled9_v3__16_13=(\"${ret_array_filled9_v3[@]}\")\necho \"[${ret_array_filled9_v3__16_13[*]}]\"\narray_filled__9_v4 3 ''\nret_array_filled9_v4__17_13=(\"${ret_array_filled9_v4[@]}\")\necho \"[${ret_array_filled9_v4__17_13[*]}]\"", "output": "import { array_filled } from \"std/array\"\n\n// Output\n// [0 0 0]\n// [0 0 0]\n// [.5 .5 .5]\n// [a a a]\n// [0 0 0]\n// [  ]\n\nmain {\n    echo(\"[{array_filled(3)}]\")\n    echo(\"[{array_filled(3, 0)}]\")\n    echo(\"[{array_filled(3, .5)}]\")\n    echo(\"[{array_filled(3, \"a\")}]\")\n    echo(\"[{array_filled(3, false)}]\")\n    echo(\"[{array_filled(3, null)}]\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__0_v0() {\n    local major_270=0\n    local minor_271=0\n    local patch_272=0\n    major_270=${BASH_VERSINFO[0]}\n        minor_271=${BASH_VERSINFO[1]}\n        patch_272=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version0_v0=(\"${major_270}\" \"${minor_271}\" \"${patch_272}\")\n    return 0\n}\n\nreplace__1_v0() {\n    local source_266=\"${1}\"\n    local search_267=\"${2}\"\n    local replace_268=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_269=\"\"\n    bash_version__0_v0 \n    left_comp=(\"${ret_bash_version0_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_269=\"${source_266//\"${search_267}\"/\"${replace_268}\"}\"\n        __status=$?\n    else\n        result_269=\"${source_266//\"${search_267}\"/${replace_268}}\"\n        __status=$?\n    fi\n    ret_replace1_v0=\"${result_269}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__3_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version3_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nreplace_regex__4_v0() {\n    local source_261=\"${1}\"\n    local search_262=\"${2}\"\n    local replace_text_263=\"${3}\"\n    local extended_264=\"${4}\"\n    sed_version__3_v0 \n    local sed_version_265=\"${ret_sed_version3_v0}\"\n    replace__1_v0 \"${search_262}\" \"/\" \"\\\\/\"\n    search_262=\"${ret_replace1_v0}\"\n    replace__1_v0 \"${replace_text_263}\" \"/\" \"\\\\/\"\n    replace_text_263=\"${ret_replace1_v0}\"\n    if [ \"$(( $(( sed_version_265 == __SED_VERSION_GNU_1 )) || $(( sed_version_265 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__1_v0 \"${search_262}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_262=\"${ret_replace1_v0}\"\n    fi\n    if [ \"${extended_264}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_265 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            local command_2\n            command_2=\"$(sed -r -e \"s/${search_262}/${replace_text_263}/g\" <<<\"${source_261}\")\"\n            __status=$?\n            ret_replace_regex4_v0=\"${command_2}\"\n            return 0\n        else\n            local command_3\n            command_3=\"$(sed -E -e \"s/${search_262}/${replace_text_263}/g\" <<<\"${source_261}\")\"\n            __status=$?\n            ret_replace_regex4_v0=\"${command_3}\"\n            return 0\n        fi\n    else\n        if [ \"$(( $(( sed_version_265 == __SED_VERSION_GNU_1 )) || $(( sed_version_265 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__1_v0 \"${search_262}\" \"\\\\|\" \"|\"\n            search_262=\"${ret_replace1_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -e \"s/${search_262}/${replace_text_263}/g\" <<<\"${source_261}\")\"\n        __status=$?\n        ret_replace_regex4_v0=\"${command_4}\"\n        return 0\n    fi\n}\n\nsplit__5_v0() {\n    local text_278=\"${1}\"\n    local delimiter_279=\"${2}\"\n    local result_280=()\n    IFS=\"${delimiter_279}\" read -rd '' -a result_280 < <(printf %s \"$text_278\")\n    __status=$?\n    ret_split5_v0=(\"${result_280[@]}\")\n    return 0\n}\n\njoin__8_v0() {\n    local list_275=(\"${!1}\")\n    local delimiter_276=\"${2}\"\n    local command_6\n    command_6=\"$(IFS=\"${delimiter_276}\" ; printf \"%s\n\" \"${list_275[*]}\")\"\n    __status=$?\n    ret_join8_v0=\"${command_6}\"\n    return 0\n}\n\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    __status=$?\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_7\n        command_7=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_7}\"\n    else\n        local command_8\n        command_8=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_8}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\nescape_non_glob_chars__52_v0() {\n    local path_260=\"${1}\"\n    replace_regex__4_v0 \"${path_260}\" \"\\\\([^*?/]\\\\)\" \"\\\\\\\\\\\\1\" 0\n    ret_escape_non_glob_chars52_v0=\"${ret_replace_regex4_v0}\"\n    return 0\n}\n\nfile_glob_all__53_v0() {\n    local paths_258=(\"${!1}\")\n    local combined_259=\"\"\n    local __length_9=(\"${paths_258[@]}\")\n    if [ \"$(( ${#__length_9[@]} == 1 ))\" != 0 ]; then\n        escape_non_glob_chars__52_v0 \"${paths_258[0]}\"\n        combined_259=\"${ret_escape_non_glob_chars52_v0}\"\n    else\n        local items_273=()\n        for item_274 in \"${paths_258[@]}\"; do\n            escape_non_glob_chars__52_v0 \"${item_274}\"\n            item_274=\"${ret_escape_non_glob_chars52_v0}\"\n            items_273+=(\"${item_274}\")\n        done\n        join__8_v0 items_273[@] \" \"\n        combined_259=\"${ret_join8_v0}\"\n    fi\n    local command_12\n    command_12=\"$(eval \"for file in ${combined_259}; do [ -e \\\"\\$file\\\" ] && printf \\\"%s\\n\\\" \\\"\\$file\\\"; done\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob_all53_v0=()\n        return \"${__status}\"\n    fi\n    local files_277=\"${command_12}\"\n    split__5_v0 \"${files_277}\" \"\n\"\n    ret_file_glob_all53_v0=(\"${ret_split5_v0[@]}\")\n    return 0\n}\n\nfile_glob__54_v0() {\n    local path_257=\"${1}\"\n    local array_13=(\"${path_257}\")\n    file_glob_all__53_v0 array_13[@]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob54_v0=()\n        return \"${__status}\"\n    fi\n    ret_file_glob54_v0=(\"${ret_file_glob_all53_v0[@]}\")\n    return 0\n}\n\n# Output\n# [xxx; do echo HACKED; done; for file in]\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ntouch \"${tmpdir_17}/xxx; do echo HACKED; done; for file in\"\n__status=$?\ncd \"${tmpdir_17}\" || exit\n# The glob function escapes all characters in the passed-in glob\n# apart from \"*\", \"?\" and \"/\", to prevent injection attacks.  If we\n# didn't do this, the following code would output \"[HACKED]\" instead\n# of the filename.\nfile_glob__54_v0 \"xxx; do echo HACKED; done; for file in\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"FAILED\"\nfi\nfiles_281=(\"${ret_file_glob54_v0[@]}\")\nfor file_282 in \"${files_281[@]}\"; do\n    echo \"[${file_282}]\"\ndone", "output": "import * from \"std/fs\"\n\n// Output\n// [xxx; do echo HACKED; done; for file in]\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    trust {\n        $ touch \"{tmpdir}/xxx; do echo HACKED; done; for file in\" $\n    }\n    cd(tmpdir)\n\n    // The glob function escapes all characters in the passed-in glob\n    // apart from \"*\", \"?\" and \"/\", to prevent injection attacks.  If we\n    // didn't do this, the following code would output \"[HACKED]\" instead\n    // of the filename.\n    const files = file_glob(\"xxx; do echo HACKED; done; for file in\") failed {\n        echo(\"FAILED\")\n    }\n    for file in files {\n        echo(\"[{file}]\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nenv_var_set__122_v0() {\n    local name_5=\"${1}\"\n    local val_6=\"${2}\"\n    export $name_5=\"$val_6\" 2> /dev/null\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_env_var_set122_v0=''\n        return \"${__status}\"\n    fi\n}\n\nenv_var_set__122_v0 \"test_shell_var_set\" \"Succeeded\"\n__status=$?\necho $test_shell_var_set\n__status=$?", "output": "import * from \"std/env\"\n\nmain {\n    trust env_var_set(\"test_shell_var_set\", \"Succeeded\")\n    trust $ echo \\$test_shell_var_set $\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_14=(\"${!1}\")\n    local value_15=\"${2}\"\n    index_17=0;\n    for element_16 in \"${array_14[@]}\"; do\n        if [ \"$([ \"_${value_15}\" != \"_${element_16}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_17}\"\n            return 0\n        fi\n        (( index_17++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_12=(\"${!1}\")\n    local value_13=\"${2}\"\n    array_find__0_v0 array_12[@] \"${value_13}\"\n    local result_18=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_18 >= 0 ))\"\n    return 0\n}\n\narray_0=(\"apple\" \"banana\" \"cherry\")\narray_contains__2_v0 array_0[@] \"banana\"\nret_array_contains2_v0__5_8=\"${ret_array_contains2_v0}\"\nif [ \"${ret_array_contains2_v0__5_8}\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Not Found\"\nfi", "output": "import * from \"std/array\"\n\nmain {\n    const array = [\"apple\", \"banana\", \"cherry\"]\n    if array_contains(array, \"banana\") {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Not Found\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__0_v0() {\n    local major_270=0\n    local minor_271=0\n    local patch_272=0\n    major_270=${BASH_VERSINFO[0]}\n        minor_271=${BASH_VERSINFO[1]}\n        patch_272=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version0_v0=(\"${major_270}\" \"${minor_271}\" \"${patch_272}\")\n    return 0\n}\n\nreplace__1_v0() {\n    local source_266=\"${1}\"\n    local search_267=\"${2}\"\n    local replace_268=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_269=\"\"\n    bash_version__0_v0 \n    left_comp=(\"${ret_bash_version0_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_269=\"${source_266//\"${search_267}\"/\"${replace_268}\"}\"\n        __status=$?\n    else\n        result_269=\"${source_266//\"${search_267}\"/${replace_268}}\"\n        __status=$?\n    fi\n    ret_replace1_v0=\"${result_269}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__3_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version3_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nreplace_regex__4_v0() {\n    local source_261=\"${1}\"\n    local search_262=\"${2}\"\n    local replace_text_263=\"${3}\"\n    local extended_264=\"${4}\"\n    sed_version__3_v0 \n    local sed_version_265=\"${ret_sed_version3_v0}\"\n    replace__1_v0 \"${search_262}\" \"/\" \"\\\\/\"\n    search_262=\"${ret_replace1_v0}\"\n    replace__1_v0 \"${replace_text_263}\" \"/\" \"\\\\/\"\n    replace_text_263=\"${ret_replace1_v0}\"\n    if [ \"$(( $(( sed_version_265 == __SED_VERSION_GNU_1 )) || $(( sed_version_265 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__1_v0 \"${search_262}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_262=\"${ret_replace1_v0}\"\n    fi\n    if [ \"${extended_264}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_265 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            local command_2\n            command_2=\"$(sed -r -e \"s/${search_262}/${replace_text_263}/g\" <<<\"${source_261}\")\"\n            __status=$?\n            ret_replace_regex4_v0=\"${command_2}\"\n            return 0\n        else\n            local command_3\n            command_3=\"$(sed -E -e \"s/${search_262}/${replace_text_263}/g\" <<<\"${source_261}\")\"\n            __status=$?\n            ret_replace_regex4_v0=\"${command_3}\"\n            return 0\n        fi\n    else\n        if [ \"$(( $(( sed_version_265 == __SED_VERSION_GNU_1 )) || $(( sed_version_265 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__1_v0 \"${search_262}\" \"\\\\|\" \"|\"\n            search_262=\"${ret_replace1_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -e \"s/${search_262}/${replace_text_263}/g\" <<<\"${source_261}\")\"\n        __status=$?\n        ret_replace_regex4_v0=\"${command_4}\"\n        return 0\n    fi\n}\n\nsplit__5_v0() {\n    local text_278=\"${1}\"\n    local delimiter_279=\"${2}\"\n    local result_280=()\n    IFS=\"${delimiter_279}\" read -rd '' -a result_280 < <(printf %s \"$text_278\")\n    __status=$?\n    ret_split5_v0=(\"${result_280[@]}\")\n    return 0\n}\n\njoin__8_v0() {\n    local list_275=(\"${!1}\")\n    local delimiter_276=\"${2}\"\n    local command_6\n    command_6=\"$(IFS=\"${delimiter_276}\" ; printf \"%s\n\" \"${list_275[*]}\")\"\n    __status=$?\n    ret_join8_v0=\"${command_6}\"\n    return 0\n}\n\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    __status=$?\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_7\n        command_7=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_7}\"\n    else\n        local command_8\n        command_8=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_8}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\nescape_non_glob_chars__52_v0() {\n    local path_260=\"${1}\"\n    replace_regex__4_v0 \"${path_260}\" \"\\\\([^*?/]\\\\)\" \"\\\\\\\\\\\\1\" 0\n    ret_escape_non_glob_chars52_v0=\"${ret_replace_regex4_v0}\"\n    return 0\n}\n\nfile_glob_all__53_v0() {\n    local paths_258=(\"${!1}\")\n    local combined_259=\"\"\n    local __length_9=(\"${paths_258[@]}\")\n    if [ \"$(( ${#__length_9[@]} == 1 ))\" != 0 ]; then\n        escape_non_glob_chars__52_v0 \"${paths_258[0]}\"\n        combined_259=\"${ret_escape_non_glob_chars52_v0}\"\n    else\n        local items_273=()\n        for item_274 in \"${paths_258[@]}\"; do\n            escape_non_glob_chars__52_v0 \"${item_274}\"\n            item_274=\"${ret_escape_non_glob_chars52_v0}\"\n            items_273+=(\"${item_274}\")\n        done\n        join__8_v0 items_273[@] \" \"\n        combined_259=\"${ret_join8_v0}\"\n    fi\n    local command_12\n    command_12=\"$(eval \"for file in ${combined_259}; do [ -e \\\"\\$file\\\" ] && printf \\\"%s\\n\\\" \\\"\\$file\\\"; done\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob_all53_v0=()\n        return \"${__status}\"\n    fi\n    local files_277=\"${command_12}\"\n    split__5_v0 \"${files_277}\" \"\n\"\n    ret_file_glob_all53_v0=(\"${ret_split5_v0[@]}\")\n    return 0\n}\n\nfile_glob__54_v0() {\n    local path_257=\"${1}\"\n    local array_13=(\"${path_257}\")\n    file_glob_all__53_v0 array_13[@]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob54_v0=()\n        return \"${__status}\"\n    fi\n    ret_file_glob54_v0=(\"${ret_file_glob_all53_v0[@]}\")\n    return 0\n}\n\n# Output\n# FAILED\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ntouch \"${tmpdir_17}/1st file with spaces.txt\"\ntouch \"${tmpdir_17}/2nd file with spaces.txt\"\ntouch \"${tmpdir_17}/file.txt\"\ntouch \"${tmpdir_17}/file1.txt\"\ntouch \"${tmpdir_17}/file2.txt\"\ntouch \"${tmpdir_17}/file99.txt\"\ntouch \"${tmpdir_17}/other.csv\"\nfile_glob__54_v0 \"${tmpdir_17}/missing*\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"FAILED\"\nfi\nfiles_281=(\"${ret_file_glob54_v0[@]}\")\nfor file_282 in \"${files_281[@]}\"; do\n    echo \"[${file_282}]\"\ndone", "output": "import * from \"std/fs\"\n\n// Output\n// FAILED\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    trust {\n        touch(\"{tmpdir}/1st file with spaces.txt\")\n        touch(\"{tmpdir}/2nd file with spaces.txt\")\n        touch(\"{tmpdir}/file.txt\")\n        touch(\"{tmpdir}/file1.txt\")\n        touch(\"{tmpdir}/file2.txt\")\n        touch(\"{tmpdir}/file99.txt\")\n        touch(\"{tmpdir}/other.csv\")\n    }\n\n    const files = file_glob(\"{tmpdir}/missing*\") failed {\n        echo(\"FAILED\")\n    }\n    for file in files {\n        echo(\"[{file}]\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_309=(\"${!1}\")\n    local value_310=\"${2}\"\n    index_312=0;\n    for element_311 in \"${array_309[@]}\"; do\n        if [ \"$([ \"_${value_310}\" != \"_${element_311}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_312}\"\n            return 0\n        fi\n        (( index_312++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_307=(\"${!1}\")\n    local value_308=\"${2}\"\n    array_find__0_v0 array_307[@] \"${value_308}\"\n    local result_313=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_313 >= 0 ))\"\n    return 0\n}\n\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__24_v0() {\n    local major_271=0\n    local minor_272=0\n    local patch_273=0\n    major_271=${BASH_VERSINFO[0]}\n        minor_272=${BASH_VERSINFO[1]}\n        patch_273=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version24_v0=(\"${major_271}\" \"${minor_272}\" \"${patch_273}\")\n    return 0\n}\n\nreplace__25_v0() {\n    local source_267=\"${1}\"\n    local search_268=\"${2}\"\n    local replace_269=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_270=\"\"\n    bash_version__24_v0 \n    left_comp=(\"${ret_bash_version24_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_270=\"${source_267//\"${search_268}\"/\"${replace_269}\"}\"\n        __status=$?\n    else\n        result_270=\"${source_267//\"${search_268}\"/${replace_269}}\"\n        __status=$?\n    fi\n    ret_replace25_v0=\"${result_270}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__27_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version27_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nreplace_regex__28_v0() {\n    local source_262=\"${1}\"\n    local search_263=\"${2}\"\n    local replace_text_264=\"${3}\"\n    local extended_265=\"${4}\"\n    sed_version__27_v0 \n    local sed_version_266=\"${ret_sed_version27_v0}\"\n    replace__25_v0 \"${search_263}\" \"/\" \"\\\\/\"\n    search_263=\"${ret_replace25_v0}\"\n    replace__25_v0 \"${replace_text_264}\" \"/\" \"\\\\/\"\n    replace_text_264=\"${ret_replace25_v0}\"\n    if [ \"$(( $(( sed_version_266 == __SED_VERSION_GNU_1 )) || $(( sed_version_266 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__25_v0 \"${search_263}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_263=\"${ret_replace25_v0}\"\n    fi\n    if [ \"${extended_265}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_266 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            local command_2\n            command_2=\"$(sed -r -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_2}\"\n            return 0\n        else\n            local command_3\n            command_3=\"$(sed -E -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_3}\"\n            return 0\n        fi\n    else\n        if [ \"$(( $(( sed_version_266 == __SED_VERSION_GNU_1 )) || $(( sed_version_266 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__25_v0 \"${search_263}\" \"\\\\|\" \"|\"\n            search_263=\"${ret_replace25_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n        __status=$?\n        ret_replace_regex28_v0=\"${command_4}\"\n        return 0\n    fi\n}\n\nsplit__29_v0() {\n    local text_279=\"${1}\"\n    local delimiter_280=\"${2}\"\n    local result_281=()\n    IFS=\"${delimiter_280}\" read -rd '' -a result_281 < <(printf %s \"$text_279\")\n    __status=$?\n    ret_split29_v0=(\"${result_281[@]}\")\n    return 0\n}\n\njoin__32_v0() {\n    local list_276=(\"${!1}\")\n    local delimiter_277=\"${2}\"\n    local command_6\n    command_6=\"$(IFS=\"${delimiter_277}\" ; printf \"%s\n\" \"${list_276[*]}\")\"\n    __status=$?\n    ret_join32_v0=\"${command_6}\"\n    return 0\n}\n\ntrim__35_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    __status=$?\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim35_v0=\"${result_15}\"\n    return 0\n}\n\nis_mac_os_mktemp__72_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp72_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp72_v0=0\n    return 0\n}\n\ntemp_dir_create__73_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__35_v0 \"${template_11}\"\n    local ret_trim35_v0__113_8=\"${ret_trim35_v0}\"\n    if [ \"$([ \"_${ret_trim35_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__72_v0 \n    local ret_is_mac_os_mktemp72_v0__119_8=\"${ret_is_mac_os_mktemp72_v0}\"\n    if [ \"${ret_is_mac_os_mktemp72_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_7\n        command_7=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_7}\"\n    else\n        local command_8\n        command_8=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_8}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create73_v0=\"${filename_16}\"\n    return 0\n}\n\nescape_non_glob_chars__76_v0() {\n    local path_261=\"${1}\"\n    replace_regex__28_v0 \"${path_261}\" \"\\\\([^*?/]\\\\)\" \"\\\\\\\\\\\\1\" 0\n    ret_escape_non_glob_chars76_v0=\"${ret_replace_regex28_v0}\"\n    return 0\n}\n\nfile_glob_all__77_v0() {\n    local paths_259=(\"${!1}\")\n    local combined_260=\"\"\n    local __length_9=(\"${paths_259[@]}\")\n    if [ \"$(( ${#__length_9[@]} == 1 ))\" != 0 ]; then\n        escape_non_glob_chars__76_v0 \"${paths_259[0]}\"\n        combined_260=\"${ret_escape_non_glob_chars76_v0}\"\n    else\n        local items_274=()\n        for item_275 in \"${paths_259[@]}\"; do\n            escape_non_glob_chars__76_v0 \"${item_275}\"\n            item_275=\"${ret_escape_non_glob_chars76_v0}\"\n            items_274+=(\"${item_275}\")\n        done\n        join__32_v0 items_274[@] \" \"\n        combined_260=\"${ret_join32_v0}\"\n    fi\n    local command_12\n    command_12=\"$(eval \"for file in ${combined_260}; do [ -e \\\"\\$file\\\" ] && printf \\\"%s\\n\\\" \\\"\\$file\\\"; done\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob_all77_v0=()\n        return \"${__status}\"\n    fi\n    local files_278=\"${command_12}\"\n    split__29_v0 \"${files_278}\" \"\n\"\n    ret_file_glob_all77_v0=(\"${ret_split29_v0[@]}\")\n    return 0\n}\n\nfile_glob__78_v0() {\n    local path_258=\"${1}\"\n    local array_13=(\"${path_258}\")\n    file_glob_all__77_v0 array_13[@]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob78_v0=()\n        return \"${__status}\"\n    fi\n    ret_file_glob78_v0=(\"${ret_file_glob_all77_v0[@]}\")\n    return 0\n}\n\ncompare__129_v0() {\n    local actual_304=(\"${!1}\")\n    local expected_305=(\"${!2}\")\n    local __length_14=(\"${actual_304[@]}\")\n    local __length_15=(\"${expected_305[@]}\")\n    if [ \"$(( ${#__length_14[@]} != ${#__length_15[@]} ))\" != 0 ]; then\n        ret_compare129_v0=0\n        return 0\n    fi\n    for file_306 in \"${expected_305[@]}\"; do\n        array_contains__2_v0 actual_304[@] \"${file_306}\"\n        local ret_array_contains2_v0__10_16=\"${ret_array_contains2_v0}\"\n        if [ \"$(( ! ret_array_contains2_v0__10_16 ))\" != 0 ]; then\n            ret_compare129_v0=0\n            return 0\n        fi\n    done\n    ret_compare129_v0=1\n    return 0\n}\n\ntemp_dir_create__73_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create73_v0}\"\ntouch \"${tmpdir_17}/1st file with spaces.txt\"\ntouch \"${tmpdir_17}/2nd file with spaces.txt\"\ntouch \"${tmpdir_17}/file.txt\"\ntouch \"${tmpdir_17}/file1.txt\"\ntouch \"${tmpdir_17}/file2.txt\"\ntouch \"${tmpdir_17}/file99.txt\"\ntouch \"${tmpdir_17}/other.csv\"\ncd \"${tmpdir_17}\" || exit\nexpected_18=(\"file1.txt\" \"file2.txt\")\nfile_glob__78_v0 \"file?.txt\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"FAILED\"\nfi\nactual_282=(\"${ret_file_glob78_v0[@]}\")\ncompare__129_v0 actual_282[@] expected_18[@]\nret_compare129_v0__37_8=\"${ret_compare129_v0}\"\nif [ \"${ret_compare129_v0__37_8}\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Expected: ${expected_18[*]}\"\n    echo \"Actual: ${actual_282[*]}\"\nfi", "output": "import * from \"std/array\"\nimport * from \"std/fs\"\nimport * from \"std/text\"\n\nfun compare(actual: [Text], expected: [Text]): Bool {\n    if len(actual) != len(expected) {\n        return false\n    }\n    for file in expected {\n        if not array_contains(actual, file) {\n            return false\n        }\n    }\n    return true\n}\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    trust {\n        touch(\"{tmpdir}/1st file with spaces.txt\")\n        touch(\"{tmpdir}/2nd file with spaces.txt\")\n        touch(\"{tmpdir}/file.txt\")\n        touch(\"{tmpdir}/file1.txt\")\n        touch(\"{tmpdir}/file2.txt\")\n        touch(\"{tmpdir}/file99.txt\")\n        touch(\"{tmpdir}/other.csv\")\n    }\n    cd(tmpdir)\n\n    const expected = [\n        \"file1.txt\",\n        \"file2.txt\",\n    ]\n    const actual = file_glob(\"file?.txt\") failed {\n        echo(\"FAILED\")\n    }\n    if compare(actual, expected) {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Expected: {expected}\")\n        echo(\"Actual: {actual}\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__0_v0() {\n    local major_17=0\n    local minor_18=0\n    local patch_19=0\n    major_17=${BASH_VERSINFO[0]}\n        minor_18=${BASH_VERSINFO[1]}\n        patch_19=${BASH_VERSINFO[2]}\n    ret_bash_version0_v0=(\"${major_17}\" \"${minor_18}\" \"${patch_19}\")\n    return 0\n}\n\nreplace__1_v0() {\n    local source_13=\"${1}\"\n    local search_14=\"${2}\"\n    local replace_15=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_16=\"\"\n    bash_version__0_v0 \n    left_comp=(\"${ret_bash_version0_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_16=\"${source_13//\"${search_14}\"/\"${replace_15}\"}\"\n    else\n        result_16=\"${source_13//\"${search_14}\"/${replace_15}}\"\n    fi\n    ret_replace1_v0=\"${result_16}\"\n    return 0\n}\n\n# Output\n# TWO TWO TWO\n# a\\\\b\\\\c\\\\d\n# first..second..third..fourth\n# mono\n# di\n# tri\nreplace__1_v0 \"one one one\" \"one\" \"TWO\"\nret_replace1_v0__12_10=\"${ret_replace1_v0}\"\nprintf '%s\\n' \"${ret_replace1_v0__12_10}\"\nreplace__1_v0 \"a\\\\b\\\\c\\\\d\" \"\\\\\" \"\\\\\\\\\"\nret_replace1_v0__13_10=\"${ret_replace1_v0}\"\nprintf '%s\\n' \"${ret_replace1_v0__13_10}\"\nreplace__1_v0 \"first\nsecond\nthird\nfourth\" \"\n\" \"..\"\nret_replace1_v0__14_10=\"${ret_replace1_v0}\"\nprintf '%s\\n' \"${ret_replace1_v0__14_10}\"\n# other newlines should not be touched\nreplace__1_v0 \"mono\ndo\ntri\" \"do\n\" \"di\n\"\nret_replace1_v0__16_10=\"${ret_replace1_v0}\"\nprintf '%s\\n' \"${ret_replace1_v0__16_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// TWO TWO TWO\n// a\\\\b\\\\c\\\\d\n// first..second..third..fourth\n// mono\n// di\n// tri\n\nmain {\n    echo(replace(\"one one one\", \"one\", \"TWO\"))\n    echo(replace(\"a\\\\b\\\\c\\\\d\", \"\\\\\", \"\\\\\\\\\"))\n    echo(replace(\"first\\nsecond\\nthird\\nfourth\", \"\\n\", \"..\"))\n    // other newlines should not be touched\n    echo(replace(\"mono\\ndo\\ntri\", \"do\\n\", \"di\\n\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__0_v0() {\n    local major_28=0\n    local minor_29=0\n    local patch_30=0\n    major_28=${BASH_VERSINFO[0]}\n        minor_29=${BASH_VERSINFO[1]}\n        patch_30=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version0_v0=(\"${major_28}\" \"${minor_29}\" \"${patch_30}\")\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__3_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version3_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nuppercase__13_v0() {\n    local text_34=\"${1}\"\n    local command_1\n    command_1=\"$(tr '[:lower:]' '[:upper:]' <<< \"${text_34}\")\"\n    __status=$?\n    ret_uppercase13_v0=\"${command_1}\"\n    return 0\n}\n\nslice__25_v0() {\n    local text_36=\"${1}\"\n    local index_37=\"${2}\"\n    local length_38=\"${3}\"\n    local result_39=\"\"\n    if [ \"$(( length_38 == 0 ))\" != 0 ]; then\n        local __length_2=\"${text_36}\"\n        length_38=\"$(( ${#__length_2} - index_37 ))\"\n    fi\n    if [ \"$(( length_38 <= 0 ))\" != 0 ]; then\n        ret_slice25_v0=\"${result_39}\"\n        return 0\n    fi\n    result_39=\"${text_36: ${index_37}: ${length_38}}\"\n    __status=$?\n    ret_slice25_v0=\"${result_39}\"\n    return 0\n}\n\nchar_at__26_v0() {\n    local text_31=\"${1}\"\n    local index_32=\"${2}\"\n    local result_33=\"\"\n    result_33=\"${text_31:${index_32}:1}\"\n    __status=$?\n    ret_char_at26_v0=\"${result_33}\"\n    return 0\n}\n\ncapitalized__27_v0() {\n    local text_27=\"${1}\"\n    local __length_3=\"${text_27}\"\n    if [ \"$(( ${#__length_3} == 0 ))\" != 0 ]; then\n        ret_capitalized27_v0=\"${text_27}\"\n        return 0\n    fi\n    bash_version__0_v0 \n    left_comp=(\"${ret_bash_version0_v0[@]}\")\n    right_comp=(4)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        local command_5\n        command_5=\"$(printf '%s\n' \"${text_27^}\")\"\n        __status=$?\n        ret_capitalized27_v0=\"${command_5}\"\n        return 0\n    fi\n    sed_version__3_v0 \n    local ret_sed_version3_v0__456_12=\"${ret_sed_version3_v0}\"\n    if [ \"$(( ret_sed_version3_v0__456_12 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n        # GNU sed supports \\U\n        local command_6\n        command_6=\"$(printf '%s\n' \"${text_27}\" | sed \"s/^\\(.\\)/\\U\\1/\")\"\n        __status=$?\n        ret_capitalized27_v0=\"${command_6}\"\n        return 0\n    fi\n    char_at__26_v0 \"${text_27}\" 0\n    local ret_char_at26_v0__460_40=\"${ret_char_at26_v0}\"\n    uppercase__13_v0 \"${ret_char_at26_v0__460_40}\"\n    local first_letter_35=\"${ret_uppercase13_v0}\"\n    slice__25_v0 \"${text_27}\" 1 0\n    local ret_slice25_v0__461_31=\"${ret_slice25_v0}\"\n    ret_capitalized27_v0=\"${first_letter_35}\"\"${ret_slice25_v0__461_31}\"\n    return 0\n}\n\n# Output\n# Hello world\ncapitalized__27_v0 \"hello world\"\nret_capitalized27_v0__7_10=\"${ret_capitalized27_v0}\"\nprintf '%s\\n' \"${ret_capitalized27_v0__7_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// Hello world\n\nmain {\n    echo(capitalized(\"hello world\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_filled__9_v0() {\n    local size_3=\"${1}\"\n    local value_4=\"${2}\"\n    local array_5=(\"${value_4}\")\n    # Used for type casting array\n    array_5=(\"${array_5[@]:0:0}\")\n    # Resetting the array size to 0\n    if [ \"$(( $(( size_3 <= 0 )) || $(( ! 1 )) ))\" != 0 ]; then\n        ret_array_filled9_v0=(\"${array_5[@]}\")\n        return 0\n    fi\n    local __range_start_6=0\n    local __range_end_6=\"${size_3}\"\n    local __dir_6=$(( ${__range_start_6} <= ${__range_end_6} ? 1 : -1 ))\n    for (( ____6=${__range_start_6}; ____6 * ${__dir_6} < ${__range_end_6} * ${__dir_6}; ____6+=${__dir_6} )); do\n        local array_1=(\"${value_4}\")\n        array_5+=(\"${array_1[@]}\")\ndone\n    ret_array_filled9_v0=(\"${array_5[@]}\")\n    return 0\n}\n\narray_filled__9_v0 0 ''\narray_7=(\"${ret_array_filled9_v0[@]}\")\narray_3=()\nif [ \"$(\n    (( ${#array_7[@]} != ${#array_3[@]} )) && echo 0 && exit\n    for (( i=0; i<${#array_7[@]}; i++ )); do [[ \"${array_7[i]}\" != \"${array_3[i]}\" ]] && echo 0 && exit; done\n    echo 1\n)\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Failed\"\nfi", "output": "import { array_filled } from \"std/array\"\n\nmain {\n    const array = array_filled(0, null)\n    if array == [Null]:\n        echo(\"Succeeded\")\n    else:\n        echo(\"Failed\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nescaped__132_v0() {\n    local text_7=\"${1}\"\n    ret_escaped132_v0=\"$(printf \"%s\n\" \"$text_7\" | sed -e 's/\\\\/\\\\\\\\/g' -e \"s/%/%%/g\")\"\n    return 0\n}\n\nbold__134_v0() {\n    local message_6=\"${1}\"\n    escaped__132_v0 \"${message_6}\"\n    local ret_escaped132_v0__258_21=\"${ret_escaped132_v0}\"\n    ret_bold134_v0=\"\\\\x1b[1m${ret_escaped132_v0__258_21}\\\\x1b[0m\"\n    return 0\n}\n\n# Output\n# \\x1b[1mHello Amber!\\x1b[0m\nbold__134_v0 \"Hello Amber\"'!'\"\"\nret_bold134_v0__7_10=\"${ret_bold134_v0}\"\nprintf '%s\\n' \"${ret_bold134_v0__7_10}\"", "output": "import * from \"std/env\"\n\n// Output\n// \\x1b[1mHello Amber!\\x1b[0m\n\nmain {\n    echo(bold(\"Hello Amber!\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nmath_floor__2_v0() {\n    local number_4=\"${1}\"\n    ret_math_floor2_v0=\"$(awk '{printf \"%d\", ($1 < 0 ? int($1) - 1 : int($1))}' <<< \"${number_4}\")\"\n    return 0\n}\n\nmath_ceil__3_v0() {\n    local number_3=\"${1}\"\n    math_floor__2_v0 \"${number_3}\"\n    local ret_math_floor2_v0__52_12=\"${ret_math_floor2_v0}\"\n    ret_math_ceil3_v0=\"$(( ret_math_floor2_v0__52_12 + 1 ))\"\n    return 0\n}\n\n# Output\n# 2\n# -1\nmath_ceil__3_v0 1.1\nret_math_ceil3_v0__8_10=\"${ret_math_ceil3_v0}\"\necho \"${ret_math_ceil3_v0__8_10}\"\nmath_ceil__3_v0 -1.9\nret_math_ceil3_v0__9_10=\"${ret_math_ceil3_v0}\"\necho \"${ret_math_ceil3_v0__9_10}\"", "output": "import * from \"std/math\"\n\n// Output\n// 2\n// -1\n\nmain {\n    echo(math_ceil(1.1))\n    echo(math_ceil(-1.9))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_309=(\"${!1}\")\n    local value_310=\"${2}\"\n    index_312=0;\n    for element_311 in \"${array_309[@]}\"; do\n        if [ \"$([ \"_${value_310}\" != \"_${element_311}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_312}\"\n            return 0\n        fi\n        (( index_312++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_307=(\"${!1}\")\n    local value_308=\"${2}\"\n    array_find__0_v0 array_307[@] \"${value_308}\"\n    local result_313=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_313 >= 0 ))\"\n    return 0\n}\n\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__24_v0() {\n    local major_271=0\n    local minor_272=0\n    local patch_273=0\n    major_271=${BASH_VERSINFO[0]}\n        minor_272=${BASH_VERSINFO[1]}\n        patch_273=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version24_v0=(\"${major_271}\" \"${minor_272}\" \"${patch_273}\")\n    return 0\n}\n\nreplace__25_v0() {\n    local source_267=\"${1}\"\n    local search_268=\"${2}\"\n    local replace_269=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_270=\"\"\n    bash_version__24_v0 \n    left_comp=(\"${ret_bash_version24_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_270=\"${source_267//\"${search_268}\"/\"${replace_269}\"}\"\n        __status=$?\n    else\n        result_270=\"${source_267//\"${search_268}\"/${replace_269}}\"\n        __status=$?\n    fi\n    ret_replace25_v0=\"${result_270}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__27_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version27_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nreplace_regex__28_v0() {\n    local source_262=\"${1}\"\n    local search_263=\"${2}\"\n    local replace_text_264=\"${3}\"\n    local extended_265=\"${4}\"\n    sed_version__27_v0 \n    local sed_version_266=\"${ret_sed_version27_v0}\"\n    replace__25_v0 \"${search_263}\" \"/\" \"\\\\/\"\n    search_263=\"${ret_replace25_v0}\"\n    replace__25_v0 \"${replace_text_264}\" \"/\" \"\\\\/\"\n    replace_text_264=\"${ret_replace25_v0}\"\n    if [ \"$(( $(( sed_version_266 == __SED_VERSION_GNU_1 )) || $(( sed_version_266 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__25_v0 \"${search_263}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_263=\"${ret_replace25_v0}\"\n    fi\n    if [ \"${extended_265}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_266 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            local command_2\n            command_2=\"$(sed -r -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_2}\"\n            return 0\n        else\n            local command_3\n            command_3=\"$(sed -E -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_3}\"\n            return 0\n        fi\n    else\n        if [ \"$(( $(( sed_version_266 == __SED_VERSION_GNU_1 )) || $(( sed_version_266 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__25_v0 \"${search_263}\" \"\\\\|\" \"|\"\n            search_263=\"${ret_replace25_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n        __status=$?\n        ret_replace_regex28_v0=\"${command_4}\"\n        return 0\n    fi\n}\n\nsplit__29_v0() {\n    local text_279=\"${1}\"\n    local delimiter_280=\"${2}\"\n    local result_281=()\n    IFS=\"${delimiter_280}\" read -rd '' -a result_281 < <(printf %s \"$text_279\")\n    __status=$?\n    ret_split29_v0=(\"${result_281[@]}\")\n    return 0\n}\n\njoin__32_v0() {\n    local list_276=(\"${!1}\")\n    local delimiter_277=\"${2}\"\n    local command_6\n    command_6=\"$(IFS=\"${delimiter_277}\" ; printf \"%s\n\" \"${list_276[*]}\")\"\n    __status=$?\n    ret_join32_v0=\"${command_6}\"\n    return 0\n}\n\ntrim__35_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    __status=$?\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim35_v0=\"${result_15}\"\n    return 0\n}\n\nis_mac_os_mktemp__72_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp72_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp72_v0=0\n    return 0\n}\n\ntemp_dir_create__73_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__35_v0 \"${template_11}\"\n    local ret_trim35_v0__113_8=\"${ret_trim35_v0}\"\n    if [ \"$([ \"_${ret_trim35_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__72_v0 \n    local ret_is_mac_os_mktemp72_v0__119_8=\"${ret_is_mac_os_mktemp72_v0}\"\n    if [ \"${ret_is_mac_os_mktemp72_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_7\n        command_7=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_7}\"\n    else\n        local command_8\n        command_8=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_8}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create73_v0=\"${filename_16}\"\n    return 0\n}\n\nescape_non_glob_chars__76_v0() {\n    local path_261=\"${1}\"\n    replace_regex__28_v0 \"${path_261}\" \"\\\\([^*?/]\\\\)\" \"\\\\\\\\\\\\1\" 0\n    ret_escape_non_glob_chars76_v0=\"${ret_replace_regex28_v0}\"\n    return 0\n}\n\nfile_glob_all__77_v0() {\n    local paths_259=(\"${!1}\")\n    local combined_260=\"\"\n    local __length_9=(\"${paths_259[@]}\")\n    if [ \"$(( ${#__length_9[@]} == 1 ))\" != 0 ]; then\n        escape_non_glob_chars__76_v0 \"${paths_259[0]}\"\n        combined_260=\"${ret_escape_non_glob_chars76_v0}\"\n    else\n        local items_274=()\n        for item_275 in \"${paths_259[@]}\"; do\n            escape_non_glob_chars__76_v0 \"${item_275}\"\n            item_275=\"${ret_escape_non_glob_chars76_v0}\"\n            items_274+=(\"${item_275}\")\n        done\n        join__32_v0 items_274[@] \" \"\n        combined_260=\"${ret_join32_v0}\"\n    fi\n    local command_12\n    command_12=\"$(eval \"for file in ${combined_260}; do [ -e \\\"\\$file\\\" ] && printf \\\"%s\\n\\\" \\\"\\$file\\\"; done\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob_all77_v0=()\n        return \"${__status}\"\n    fi\n    local files_278=\"${command_12}\"\n    split__29_v0 \"${files_278}\" \"\n\"\n    ret_file_glob_all77_v0=(\"${ret_split29_v0[@]}\")\n    return 0\n}\n\nfile_glob__78_v0() {\n    local path_258=\"${1}\"\n    local array_13=(\"${path_258}\")\n    file_glob_all__77_v0 array_13[@]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob78_v0=()\n        return \"${__status}\"\n    fi\n    ret_file_glob78_v0=(\"${ret_file_glob_all77_v0[@]}\")\n    return 0\n}\n\ncompare__129_v0() {\n    local actual_304=(\"${!1}\")\n    local expected_305=(\"${!2}\")\n    local __length_14=(\"${actual_304[@]}\")\n    local __length_15=(\"${expected_305[@]}\")\n    if [ \"$(( ${#__length_14[@]} != ${#__length_15[@]} ))\" != 0 ]; then\n        ret_compare129_v0=0\n        return 0\n    fi\n    for file_306 in \"${expected_305[@]}\"; do\n        array_contains__2_v0 actual_304[@] \"${file_306}\"\n        local ret_array_contains2_v0__10_16=\"${ret_array_contains2_v0}\"\n        if [ \"$(( ! ret_array_contains2_v0__10_16 ))\" != 0 ]; then\n            ret_compare129_v0=0\n            return 0\n        fi\n    done\n    ret_compare129_v0=1\n    return 0\n}\n\ntemp_dir_create__73_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create73_v0}\"\ntouch \"${tmpdir_17}/1st file with spaces.txt\"\ntouch \"${tmpdir_17}/2nd file with spaces.txt\"\ntouch \"${tmpdir_17}/file.txt\"\ntouch \"${tmpdir_17}/file1.txt\"\ntouch \"${tmpdir_17}/file2.txt\"\ntouch \"${tmpdir_17}/file99.txt\"\ntouch \"${tmpdir_17}/other.csv\"\nexpected_18=(\"${tmpdir_17}/1st file with spaces.txt\" \"${tmpdir_17}/2nd file with spaces.txt\")\nfile_glob__78_v0 \"${tmpdir_17}/*with spaces*\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"FAILED\"\nfi\nactual_282=(\"${ret_file_glob78_v0[@]}\")\ncompare__129_v0 actual_282[@] expected_18[@]\nret_compare129_v0__36_8=\"${ret_compare129_v0}\"\nif [ \"${ret_compare129_v0__36_8}\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Expected: ${expected_18[*]}\"\n    echo \"Actual: ${actual_282[*]}\"\nfi", "output": "import * from \"std/array\"\nimport * from \"std/fs\"\nimport * from \"std/text\"\n\nfun compare(actual: [Text], expected: [Text]): Bool {\n    if len(actual) != len(expected) {\n        return false\n    }\n    for file in expected {\n        if not array_contains(actual, file) {\n            return false\n        }\n    }\n    return true\n}\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    trust {\n        touch(\"{tmpdir}/1st file with spaces.txt\")\n        touch(\"{tmpdir}/2nd file with spaces.txt\")\n        touch(\"{tmpdir}/file.txt\")\n        touch(\"{tmpdir}/file1.txt\")\n        touch(\"{tmpdir}/file2.txt\")\n        touch(\"{tmpdir}/file99.txt\")\n        touch(\"{tmpdir}/other.csv\")\n    }\n\n    const expected = [\n        \"{tmpdir}/1st file with spaces.txt\",\n        \"{tmpdir}/2nd file with spaces.txt\",\n    ]\n    const actual = file_glob(\"{tmpdir}/*with spaces*\") failed {\n        echo(\"FAILED\")\n    }\n    if compare(actual, expected) {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Expected: {expected}\")\n        echo(\"Actual: {actual}\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nsort_lines__34_v0() {\n    local text_7=\"${1}\"\n    local desc_8=\"${2}\"\n    local numeric_9=\"${3}\"\n    local args_10=\"\"\n    if [ \"${desc_8}\" != 0 ]; then\n        args_10+=\"r\"\n    fi\n    if [ \"${numeric_9}\" != 0 ]; then\n        args_10+=\"n\"\n    fi\n    ret_sort_lines34_v0=\"$(sort -${args_10} <<< \"${text_7}\")\"\n    return 0\n}\n\n# Output\n# apple\n# banana\n# cherry\n# cherry\n# banana\n# apple\n# 1\n# 2\n# 10\nsort_lines__34_v0 \"banana\napple\ncherry\" 0 0\nret_sort_lines34_v0__14_9=\"${ret_sort_lines34_v0}\"\nprintf '%s\\n' \"${ret_sort_lines34_v0__14_9}\"\nsort_lines__34_v0 \"banana\napple\ncherry\" 1 0\nret_sort_lines34_v0__15_9=\"${ret_sort_lines34_v0}\"\nprintf '%s\\n' \"${ret_sort_lines34_v0__15_9}\"\nsort_lines__34_v0 \"10\n2\n1\" 0 1\nret_sort_lines34_v0__16_9=\"${ret_sort_lines34_v0}\"\nprintf '%s\\n' \"${ret_sort_lines34_v0__16_9}\"", "output": "import { sort_lines } from \"std/text\"\n\n// Output\n// apple\n// banana\n// cherry\n// cherry\n// banana\n// apple\n// 1\n// 2\n// 10\nmain {\n   echo(sort_lines(\"banana\\napple\\ncherry\"))\n   echo(sort_lines(\"banana\\napple\\ncherry\", true))\n   echo(sort_lines(\"10\\n2\\n1\", false, true))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# All dates are internally stored as milliseconds since the Epoch (1970-01-01 00:00 UTC).\ndate_now__2_v0() {\n    ret_date_now2_v0=\"$(date +%s)\"\n    return 0\n}\n\nmath_abs__14_v0() {\n    local number_2=\"${1}\"\n    if [ \"$(( number_2 < 0 ))\" != 0 ]; then\n        ret_math_abs14_v0=\"$(( - number_2 ))\"\n        return 0\n    fi\n    ret_math_abs14_v0=\"${number_2}\"\n    return 0\n}\n\nget_current_date__20_v0() {\n    ret_get_current_date20_v0=\"$(date +%s)\"\n    return 0\n}\n\nget_current_date__20_v0 \nposix_now_0=\"${ret_get_current_date20_v0}\"\ndate_now__2_v0 \nret_date_now2_v0__11_17=\"${ret_date_now2_v0}\"\nmath_abs__14_v0 \"$(( ret_date_now2_v0__11_17 - posix_now_0 ))\"\nret_math_abs14_v0__11_8=\"${ret_math_abs14_v0}\"\nif [ \"$(( ret_math_abs14_v0__11_8 < 3 ))\" != 0 ]; then\n    echo \"Succeeded\"\nfi", "output": "import * from \"std/date\"\nimport * from \"std/math\"\n\n#[allow_absurd_cast]\nfun get_current_date(): Int {\n    return trust $ date +%s $ as Int\n}\n\nmain {\n    const posix_now = get_current_date()\n    if math_abs(date_now() - posix_now) < 3: echo(\"Succeeded\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ncount_lines__31_v0() {\n    local text_4=\"${1}\"\n    if [ \"$([ \"_${text_4}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        ret_count_lines31_v0=0\n        return 0\n    fi\n    ret_count_lines31_v0=\"$(wc -l <<< \"${text_4}\" | tr -d ' ')\"\n    return 0\n}\n\n# Output\n# 3\n# 1\n# 0\n# 5\ncount_lines__31_v0 \"one\ntwo\nthree\"\nret_count_lines31_v0__10_10=\"${ret_count_lines31_v0}\"\necho \"${ret_count_lines31_v0__10_10}\"\ncount_lines__31_v0 \"single line\"\nret_count_lines31_v0__11_10=\"${ret_count_lines31_v0}\"\necho \"${ret_count_lines31_v0__11_10}\"\ncount_lines__31_v0 \"\"\nret_count_lines31_v0__12_10=\"${ret_count_lines31_v0}\"\necho \"${ret_count_lines31_v0__12_10}\"\ncount_lines__31_v0 \"a\nb\nc\nd\ne\"\nret_count_lines31_v0__13_10=\"${ret_count_lines31_v0}\"\necho \"${ret_count_lines31_v0__13_10}\"", "output": "import { count_lines } from \"std/text\"\n\n// Output\n// 3\n// 1\n// 0\n// 5\n\nmain {\n    echo(count_lines(\"one\\ntwo\\nthree\"))\n    echo(count_lines(\"single line\"))\n    echo(count_lines(\"\"))\n    echo(count_lines(\"a\\nb\\nc\\nd\\ne\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nenv_var_get__123_v0() {\n    local name_4=\"${1}\"\n    local command_0\n    command_0=\"$(printf \"%s\n\" \"${!name_4}\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_env_var_get123_v0=''\n        return \"${__status}\"\n    fi\n    ret_env_var_get123_v0=\"${command_0}\"\n    return 0\n}\n\nexport test_shell_var_get=\"Succeeded\"\n__status=$?\nenv_var_get__123_v0 \"test_shell_var_get\"\n__status=$?\nret_env_var_get123_v0__5_16=\"${ret_env_var_get123_v0}\"\nprintf '%s\\n' \"${ret_env_var_get123_v0__5_16}\"", "output": "import * from \"std/env\"\n\nmain {\n    trust $ export test_shell_var_get=\"Succeeded\" $\n    echo(trust env_var_get(\"test_shell_var_get\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_shift__8_v0() {\n    local array_13=(\"${1}\")\n    eval \"local array_13_deref_8=(\\\"\\${${array_13[0]}[@]}\\\")\"\n    local __length_0=(\"${array_13_deref_8[@]}\")\n    local length_14=\"${#__length_0[@]}\"\n    if [ \"$(( length_14 == 0 ))\" != 0 ]; then\n        ret_array_shift8_v0=''\n        return 1\n    fi\n    eval \"local array_13_deref_9=\\\"\\${${array_13[0]}[0]}\\\"\"\n    local element_15=\"${array_13_deref_9}\"\n    local slice_upper_1=\"${length_14}\"\n    local slice_offset_2=1\n    local slice_offset_2=$((${slice_offset_2} > 0 ? ${slice_offset_2} : 0))\n    local slice_length_3\n    slice_length_3=\"$(echo \"${slice_upper_1}\" '-' \"${slice_offset_2}\" | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\n    local slice_length_3=$((${slice_length_3} > 0 ? ${slice_length_3} : 0))\n    eval \"local array_13_deref_10=(\\\"\\${${array_13[0]}[@]:\\${slice_offset_2}:\\${slice_length_3}}\\\")\"\n    eval \"${array_13}=(\\\"\\${array_13_deref_10[@]}\\\")\"\n    ret_array_shift8_v0=\"${element_15}\"\n    return 0\n}\n\n# Output\n# Shifted from numbers: \"zero\" (3) [one two three]\n# First of empty array does not exist\ntest_shift__13_v0() {\n    local label_11=\"${1}\"\n    local data_12=(\"${!2}\")\n    array_shift__8_v0 \"data_12\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        echo \"First of empty array does not exist\"\n        ret_test_shift13_v0=''\n        return 0\n    fi\n    local value_16=\"${ret_array_shift8_v0}\"\n    local __length_4=(\"${data_12[@]}\")\n    echo \"Shifted from ${label_11}: \\\"${value_16}\\\" (${#__length_4[*]}) [${data_12[*]}]\"\n}\n\nnumbers_0=(\"zero\" \"one\" \"two\" \"three\")\nempty_1=()\ntest_shift__13_v0 \"numbers\" numbers_0[@]\ntest_shift__13_v0 \"empty\" empty_1[@]", "output": "import { array_shift } from \"std/array\"\n\n// Output\n// Shifted from numbers: \"zero\" (3) [one two three]\n// First of empty array does not exist\n\nfun test_shift(label: Text, data: [Text]): Null {\n    const value = array_shift(data) failed {\n        echo(\"First of empty array does not exist\")\n        return null\n    }\n    echo(\"Shifted from {label}: \\\"{value}\\\" ({len(data)}) [{data}]\")\n}\n\nmain {\n    const numbers = [\"zero\", \"one\", \"two\", \"three\"]\n    const empty = [Text]\n    test_shift(\"numbers\", numbers)\n    test_shift(\"empty\", empty)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__0_v0() {\n    local major_54=0\n    local minor_55=0\n    local patch_56=0\n    major_54=${BASH_VERSINFO[0]}\n        minor_55=${BASH_VERSINFO[1]}\n        patch_56=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version0_v0=(\"${major_54}\" \"${minor_55}\" \"${patch_56}\")\n    return 0\n}\n\nreplace__1_v0() {\n    local source_50=\"${1}\"\n    local search_51=\"${2}\"\n    local replace_52=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_53=\"\"\n    bash_version__0_v0 \n    left_comp=(\"${ret_bash_version0_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_53=\"${source_50//\"${search_51}\"/\"${replace_52}\"}\"\n        __status=$?\n    else\n        result_53=\"${source_50//\"${search_51}\"/${replace_52}}\"\n        __status=$?\n    fi\n    ret_replace1_v0=\"${result_53}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__3_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version3_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nmatch_regex__20_v0() {\n    local source_46=\"${1}\"\n    local search_47=\"${2}\"\n    local extended_48=\"${3}\"\n    sed_version__3_v0 \n    local sed_version_49=\"${ret_sed_version3_v0}\"\n    replace__1_v0 \"${search_47}\" \"/\" \"\\\\/\"\n    search_47=\"${ret_replace1_v0}\"\n    local output_57=\"\"\n    if [ \"$(( $(( sed_version_49 == __SED_VERSION_GNU_1 )) || $(( sed_version_49 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__1_v0 \"${search_47}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_47=\"${ret_replace1_v0}\"\n    fi\n    if [ \"${extended_48}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_49 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            # '\\b' is not in POSIX standards. Disable it\n            replace__1_v0 \"${search_47}\" \"\\\\b\" \"\\\\b\"\n            search_47=\"${ret_replace1_v0}\"\n            local command_2\n            command_2=\"$(sed -r -ne \"/${search_47}/p\" <<<\"${source_46}\")\"\n            __status=$?\n            output_57=\"${command_2}\"\n        else\n            local command_3\n            command_3=\"$(sed -E -ne \"/${search_47}/p\" <<<\"${source_46}\")\"\n            __status=$?\n            output_57=\"${command_3}\"\n        fi\n    else\n        if [ \"$(( $(( sed_version_49 == __SED_VERSION_GNU_1 )) || $(( sed_version_49 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__1_v0 \"${search_47}\" \"\\\\|\" \"|\"\n            search_47=\"${ret_replace1_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -ne \"/${search_47}/p\" <<<\"${source_46}\")\"\n        __status=$?\n        output_57=\"${command_4}\"\n    fi\n    if [ \"$([ \"_${output_57}\" == \"_\" ]; echo $?)\" != 0 ]; then\n        ret_match_regex20_v0=1\n        return 0\n    fi\n    ret_match_regex20_v0=0\n    return 0\n}\n\n# Output\n# Succeeded\n# Succeeded\n# $ end of string\nmatch_regex__20_v0 \"Hello World\" \" World\\$\" 0\nret_match_regex20_v0__9_10=\"${ret_match_regex20_v0}\"\nprintf '%s\\n' \"$(if [ \"${ret_match_regex20_v0__9_10}\" != 0 ]; then echo \"Succeeded\"; else echo \"\"; fi)\"\n# A pipe (|) should be treated as a literal character in POSIX Standards BRE.\nmatch_regex__20_v0 \"to be\" \"to be|not to be\" 0\nret_match_regex20_v0__11_10=\"${ret_match_regex20_v0}\"\nprintf '%s\\n' \"$(if [ \"${ret_match_regex20_v0__11_10}\" != 0 ]; then echo \"\"; else echo \"Succeeded\"; fi)\"", "output": "import { match_regex } from \"std/text\"\n\n// Output\n// Succeeded\n// Succeeded\n\nmain {\n    // $ end of string\n    echo(match_regex(\"Hello World\", \" World$\") then \"Succeeded\" else \"\")\n    // A pipe (|) should be treated as a literal character in POSIX Standards BRE.\n    echo(match_regex(\"to be\", \"to be|not to be\") then \"\" else \"Succeeded\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nenv_var_set__122_v0() {\n    local name_5=\"${1}\"\n    local val_6=\"${2}\"\n    export $name_5=\"$val_6\" 2> /dev/null\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_env_var_set122_v0=''\n        return \"${__status}\"\n    fi\n}\n\nenv_var_unset__124_v0() {\n    local name_8=\"${1}\"\n    unset ${name_8}\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_env_var_unset124_v0=''\n        return \"${__status}\"\n    fi\n}\n\nenv_var_set__122_v0 \"test_shell_unset\" \"Succeeded\"\n__status=$?\necho $test_shell_unset\n__status=$?\nenv_var_unset__124_v0 \"test_shell_unset\"\n__status=$?\necho $test_shell_unset\n__status=$?", "output": "import * from \"std/env\"\n\nmain {\n    trust env_var_set(\"test_shell_unset\", \"Succeeded\")\n    trust $ echo \\$test_shell_unset $\n    trust env_var_unset(\"test_shell_unset\")\n    trust $ echo \\$test_shell_unset $\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nis_command__125_v0() {\n    local command_4=\"${1}\"\n    [ -x \"$(command -v \"${command_4}\")\" ]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_command125_v0=0\n        return 0\n    fi\n    ret_is_command125_v0=1\n    return 0\n}\n\nis_command__125_v0 \"cat\"\nret_is_command125_v0__4_8=\"${ret_is_command125_v0}\"\nif [ \"${ret_is_command125_v0__4_8}\" != 0 ]; then\n    echo \"Succeeded\"\nfi\nis_command__125_v0 \"this_is_not_command_amber\"\nret_is_command125_v0__8_8=\"${ret_is_command125_v0}\"\nif [ \"${ret_is_command125_v0__8_8}\" != 0 ]; then\n    echo \"exist-error\"\nfi", "output": "import { is_command } from \"std/env\"\n\nmain {\n    if is_command(\"cat\") {\n        echo(\"Succeeded\")\n    }\n\n    if is_command(\"this_is_not_command_amber\") {\n        echo(\"exist-error\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nescaped__132_v0() {\n    local text_49=\"${1}\"\n    ret_escaped132_v0=\"$(printf \"%s\n\" \"$text_49\" | sed -e 's/\\\\/\\\\\\\\/g' -e \"s/%/%%/g\")\"\n    return 0\n}\n\nstyled__133_v0() {\n    local message_42=\"${1}\"\n    local style_43=\"${2}\"\n    local fg_44=\"${3}\"\n    local bg_45=\"${4}\"\n    # https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit\n    local fg_code_47=0\n    local bg_code_48=0\n        bg_code_48=\"${bg_45}\"\n        fg_code_47=\"${fg_44}\"\n    escaped__132_v0 \"${message_42}\"\n    local ret_escaped132_v0__248_47=\"${ret_escaped132_v0}\"\n    ret_styled133_v0=\"\\\\x1b[${style_43};${fg_code_47};${bg_code_48}m${ret_escaped132_v0__248_47}\\\\x1b[0m\"\n    return 0\n}\n\n# Output\n# \\x1b[31;1;42mHello Amber!\\x1b[0m\nstyled__133_v0 \"Hello Amber\"'!'\"\" 31 1 42\nret_styled133_v0__7_10=\"${ret_styled133_v0}\"\nprintf '%s\\n' \"${ret_styled133_v0__7_10}\"", "output": "import * from \"std/env\"\n\n// Output\n// \\x1b[31;1;42mHello Amber!\\x1b[0m\n\nmain {\n    echo(styled(\"Hello Amber!\", 31, 1, 42))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__0_v0() {\n    local major_17=0\n    local minor_18=0\n    local patch_19=0\n    major_17=${BASH_VERSINFO[0]}\n        minor_18=${BASH_VERSINFO[1]}\n        patch_19=${BASH_VERSINFO[2]}\n    ret_bash_version0_v0=(\"${major_17}\" \"${minor_18}\" \"${patch_19}\")\n    return 0\n}\n\nreplace_one__2_v0() {\n    local source_13=\"${1}\"\n    local search_14=\"${2}\"\n    local replace_15=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_16=\"\"\n    bash_version__0_v0 \n    left_comp=(\"${ret_bash_version0_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_16=\"${source_13/\"${search_14}\"/\"${replace_15}\"}\"\n    else\n        result_16=\"${source_13/\"${search_14}\"/${replace_15}}\"\n    fi\n    ret_replace_one2_v0=\"${result_16}\"\n    return 0\n}\n\n# Output\n# TWO one one\n# a\\\\b\\c\\d\n# first..second\n# third\n# fourth\n# mono\n# di\n# tri\nreplace_one__2_v0 \"one one one\" \"one\" \"TWO\"\nret_replace_one2_v0__14_10=\"${ret_replace_one2_v0}\"\nprintf '%s\\n' \"${ret_replace_one2_v0__14_10}\"\nreplace_one__2_v0 \"a\\\\b\\\\c\\\\d\" \"\\\\\" \"\\\\\\\\\"\nret_replace_one2_v0__15_10=\"${ret_replace_one2_v0}\"\nprintf '%s\\n' \"${ret_replace_one2_v0__15_10}\"\nreplace_one__2_v0 \"first\nsecond\nthird\nfourth\" \"\n\" \"..\"\nret_replace_one2_v0__16_10=\"${ret_replace_one2_v0}\"\nprintf '%s\\n' \"${ret_replace_one2_v0__16_10}\"\n# other newlines should not be touched\nreplace_one__2_v0 \"mono\ndo\ntri\" \"do\n\" \"di\n\"\nret_replace_one2_v0__18_10=\"${ret_replace_one2_v0}\"\nprintf '%s\\n' \"${ret_replace_one2_v0__18_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// TWO one one\n// a\\\\b\\c\\d\n// first..second\n// third\n// fourth\n// mono\n// di\n// tri\n\nmain {\n    echo(replace_one(\"one one one\", \"one\", \"TWO\"))\n    echo(replace_one(\"a\\\\b\\\\c\\\\d\", \"\\\\\", \"\\\\\\\\\"))\n    echo(replace_one(\"first\\nsecond\\nthird\\nfourth\", \"\\n\", \"..\"))\n    // other newlines should not be touched\n    echo(replace_one(\"mono\\ndo\\ntri\", \"do\\n\", \"di\\n\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ncount_words__32_v0() {\n    local text_4=\"${1}\"\n    ret_count_words32_v0=\"$(wc -w <<< \"${text_4}\" | tr -d ' ')\"\n    return 0\n}\n\n# Output\n# 3\n# 1\n# 0\n# 6\ncount_words__32_v0 \"hello world foo\"\nret_count_words32_v0__10_10=\"${ret_count_words32_v0}\"\necho \"${ret_count_words32_v0__10_10}\"\ncount_words__32_v0 \"single\"\nret_count_words32_v0__11_10=\"${ret_count_words32_v0}\"\necho \"${ret_count_words32_v0__11_10}\"\ncount_words__32_v0 \"\"\nret_count_words32_v0__12_10=\"${ret_count_words32_v0}\"\necho \"${ret_count_words32_v0__12_10}\"\ncount_words__32_v0 \"one two\nthree four\nfive six\"\nret_count_words32_v0__13_10=\"${ret_count_words32_v0}\"\necho \"${ret_count_words32_v0__13_10}\"", "output": "import { count_words } from \"std/text\"\n\n// Output\n// 3\n// 1\n// 0\n// 6\n\nmain {\n    echo(count_words(\"hello world foo\"))\n    echo(count_words(\"single\"))\n    echo(count_words(\"\"))\n    echo(count_words(\"one two\\nthree four\\nfive six\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nfile_exists__42_v0() {\n    local path_24=\"${1}\"\n    [ -f \"${path_24}\" ]\n    __status=$?\n    ret_file_exists42_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_0\n        command_0=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_0}\"\n    else\n        local command_1\n        command_1=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_1}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\nfile_chmod__50_v0() {\n    local path_22=\"${1}\"\n    local mode_23=\"${2}\"\n    file_exists__42_v0 \"${path_22}\"\n    local ret_file_exists42_v0__153_8=\"${ret_file_exists42_v0}\"\n    if [ \"${ret_file_exists42_v0__153_8}\" != 0 ]; then\n        chmod \"${mode_23}\" \"${path_22}\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_chmod50_v0=''\n            return \"${__status}\"\n        fi\n        ret_file_chmod50_v0=''\n        return 0\n    fi\n    echo \"The file ${path_22} doesn't exist\"'!'\"\"\n    ret_file_chmod50_v0=''\n    return 1\n}\n\n# Output\n# created\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ntouch \"${tmpdir_17}/amber-symbolic\"\nfile_chmod__50_v0 \"${tmpdir_17}/amber-symbolic\" \"+x\"\n__status=$?\nif [ \"$(( __status == 0 ))\" != 0 ]; then\n    echo \"created\"\nfi", "output": "import { file_chmod, temp_dir_create } from \"std/fs\"\n\n// Output\n// created\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    touch(\"{tmpdir}/amber-symbolic\")\n    trust file_chmod(\"{tmpdir}/amber-symbolic\", \"+x\")\n    if status == 0 {\n        echo(\"created\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__0_v0() {\n    local major_55=0\n    local minor_56=0\n    local patch_57=0\n    major_55=${BASH_VERSINFO[0]}\n        minor_56=${BASH_VERSINFO[1]}\n        patch_57=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version0_v0=(\"${major_55}\" \"${minor_56}\" \"${patch_57}\")\n    return 0\n}\n\nreplace__1_v0() {\n    local source_51=\"${1}\"\n    local search_52=\"${2}\"\n    local replace_53=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_54=\"\"\n    bash_version__0_v0 \n    left_comp=(\"${ret_bash_version0_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_54=\"${source_51//\"${search_52}\"/\"${replace_53}\"}\"\n        __status=$?\n    else\n        result_54=\"${source_51//\"${search_52}\"/${replace_53}}\"\n        __status=$?\n    fi\n    ret_replace1_v0=\"${result_54}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__3_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version3_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nreplace_regex__4_v0() {\n    local source_46=\"${1}\"\n    local search_47=\"${2}\"\n    local replace_text_48=\"${3}\"\n    local extended_49=\"${4}\"\n    sed_version__3_v0 \n    local sed_version_50=\"${ret_sed_version3_v0}\"\n    replace__1_v0 \"${search_47}\" \"/\" \"\\\\/\"\n    search_47=\"${ret_replace1_v0}\"\n    replace__1_v0 \"${replace_text_48}\" \"/\" \"\\\\/\"\n    replace_text_48=\"${ret_replace1_v0}\"\n    if [ \"$(( $(( sed_version_50 == __SED_VERSION_GNU_1 )) || $(( sed_version_50 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__1_v0 \"${search_47}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_47=\"${ret_replace1_v0}\"\n    fi\n    if [ \"${extended_49}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_50 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            local command_2\n            command_2=\"$(sed -r -e \"s/${search_47}/${replace_text_48}/g\" <<<\"${source_46}\")\"\n            __status=$?\n            ret_replace_regex4_v0=\"${command_2}\"\n            return 0\n        else\n            local command_3\n            command_3=\"$(sed -E -e \"s/${search_47}/${replace_text_48}/g\" <<<\"${source_46}\")\"\n            __status=$?\n            ret_replace_regex4_v0=\"${command_3}\"\n            return 0\n        fi\n    else\n        if [ \"$(( $(( sed_version_50 == __SED_VERSION_GNU_1 )) || $(( sed_version_50 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__1_v0 \"${search_47}\" \"\\\\|\" \"|\"\n            search_47=\"${ret_replace1_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -e \"s/${search_47}/${replace_text_48}/g\" <<<\"${source_46}\")\"\n        __status=$?\n        ret_replace_regex4_v0=\"${command_4}\"\n        return 0\n    fi\n}\n\n# Output\n# aeon aeons ### eons\n# abc[123]def\n# ###\n# .tar.gz\n# #path#to#file.txt\nreplace_regex__4_v0 \"aeon aeons eon eons\" \" eon \" \" ### \" 0\nret_replace_regex4_v0__11_10=\"${ret_replace_regex4_v0}\"\nprintf '%s\\n' \"${ret_replace_regex4_v0__11_10}\"\n# Combination of bracket exp and one or more\nreplace_regex__4_v0 \"abc123def\" \"\\\\([0-9][0-9]*\\\\)\" \"[\\\\1]\" 0\nret_replace_regex4_v0__13_10=\"${ret_replace_regex4_v0}\"\nprintf '%s\\n' \"${ret_replace_regex4_v0__13_10}\"\n# Ending position of the string\nreplace_regex__4_v0 \"foo\" \"foo\\$\" \"###\" 0\nret_replace_regex4_v0__15_10=\"${ret_replace_regex4_v0}\"\nprintf '%s\\n' \"${ret_replace_regex4_v0__15_10}\"\n# A pipe (|) should be treated as a literal character in POSIX Standards BRE.\nreplace_regex__4_v0 \".tar.gz\" \"\\\\.\\\\(tar\\\\.gz\\\\|tgz\\\\)\\$\" \"Failed\" 0\nret_replace_regex4_v0__17_10=\"${ret_replace_regex4_v0}\"\nprintf '%s\\n' \"${ret_replace_regex4_v0__17_10}\"\n# Replacing forward slash failed\nreplace_regex__4_v0 \"/path/to/file.txt\" \"/\" \"#\" 0\nret_replace_regex4_v0__19_10=\"${ret_replace_regex4_v0}\"\nprintf '%s\\n' \"${ret_replace_regex4_v0__19_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// aeon aeons ### eons\n// abc[123]def\n// ###\n// .tar.gz\n// #path#to#file.txt\n\nmain {\n    echo(replace_regex(\"aeon aeons eon eons\", \" eon \", \" ### \"))\n    // Combination of bracket exp and one or more\n    echo(replace_regex(\"abc123def\", \"\\([0-9][0-9]*\\)\", \"[\\1]\"))\n    // Ending position of the string\n    echo(replace_regex(\"foo\", \"foo$\", \"###\"))\n    // A pipe (|) should be treated as a literal character in POSIX Standards BRE.\n    echo(replace_regex(\".tar.gz\", \"\\.\\(tar\\.gz\\|tgz\\)$\", \"Failed\"))\n    // Replacing forward slash failed\n    echo(replace_regex(\"/path/to/file.txt\", \"/\", \"#\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nmath_floor__2_v0() {\n    local number_1=\"${1}\"\n    ret_math_floor2_v0=\"$(awk '{printf \"%d\", ($1 < 0 ? int($1) - 1 : int($1))}' <<< \"${number_1}\")\"\n    return 0\n}\n\n# Output\n# 1\n# -2\nmath_floor__2_v0 1.9\nret_math_floor2_v0__8_10=\"${ret_math_floor2_v0}\"\necho \"${ret_math_floor2_v0__8_10}\"\nmath_floor__2_v0 -1.1\nret_math_floor2_v0__9_10=\"${ret_math_floor2_v0}\"\necho \"${ret_math_floor2_v0__9_10}\"", "output": "import * from \"std/math\"\n\n// Output\n// 1\n// -2\n\nmain {\n    echo(math_floor(1.9))\n    echo(math_floor(-1.1))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nenv_var_test__120_v0() {\n    local name_4=\"${1}\"\n    [[ ! -z ${!name_4+z} ]]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_env_var_test120_v0=0\n        return 0\n    fi\n    ret_env_var_test120_v0=1\n    return 0\n}\n\ntest_var_isset=\"test\"\n__status=$?\nenv_var_test__120_v0 \"test_var_isset\"\nret_env_var_test120_v0__5_8=\"${ret_env_var_test120_v0}\"\nif [ \"${ret_env_var_test120_v0__5_8}\" != 0 ]; then\n    echo \"Succeeded\"\nfi\nenv_var_test__120_v0 \"test_var_isset2\"\nret_env_var_test120_v0__9_8=\"${ret_env_var_test120_v0}\"\nif [ \"${ret_env_var_test120_v0__9_8}\" != 0 ]; then\n    echo \"test_var_isset2\"\nfi", "output": "import * from \"std/env\"\n\nmain {\n    trust $ test_var_isset=\"test\" $\n    if env_var_test(\"test_var_isset\") {\n        echo(\"Succeeded\")\n    }\n\n    if env_var_test(\"test_var_isset2\") {\n        echo(\"test_var_isset2\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_14=(\"${!1}\")\n    local value_15=\"${2}\"\n    index_17=0;\n    for element_16 in \"${array_14[@]}\"; do\n        if [ \"$([ \"_${value_15}\" != \"_${element_16}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_17}\"\n            return 0\n        fi\n        (( index_17++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_12=(\"${!1}\")\n    local value_13=\"${2}\"\n    array_find__0_v0 array_12[@] \"${value_13}\"\n    local result_18=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_18 >= 0 ))\"\n    return 0\n}\n\n# Output\n# Not Found\narray_0=(\"foo\" \"bar\" \"baz\")\narray_contains__2_v0 array_0[@] \"oo ba\"\nret_array_contains2_v0__8_8=\"${ret_array_contains2_v0}\"\nif [ \"${ret_array_contains2_v0__8_8}\" != 0 ]; then\n    echo \"Found\"\nelse\n    echo \"Not Found\"\nfi", "output": "import * from \"std/array\"\n\n// Output\n// Not Found\n\nmain {\n    const array = [\"foo\", \"bar\", \"baz\"]\n    if array_contains(array, \"oo ba\") {\n        echo(\"Found\")\n    } else {\n        echo(\"Not Found\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_229=(\"${!1}\")\n    local value_230=\"${2}\"\n    index_232=0;\n    for element_231 in \"${array_229[@]}\"; do\n        if [ \"$([ \"_${value_230}\" != \"_${element_231}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_232}\"\n            return 0\n        fi\n        (( index_232++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_227=(\"${!1}\")\n    local value_228=\"${2}\"\n    array_find__0_v0 array_227[@] \"${value_228}\"\n    local result_233=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_233 >= 0 ))\"\n    return 0\n}\n\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__24_v0() {\n    local major_191=0\n    local minor_192=0\n    local patch_193=0\n    major_191=${BASH_VERSINFO[0]}\n        minor_192=${BASH_VERSINFO[1]}\n        patch_193=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version24_v0=(\"${major_191}\" \"${minor_192}\" \"${patch_193}\")\n    return 0\n}\n\nreplace__25_v0() {\n    local source_187=\"${1}\"\n    local search_188=\"${2}\"\n    local replace_189=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_190=\"\"\n    bash_version__24_v0 \n    left_comp=(\"${ret_bash_version24_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_190=\"${source_187//\"${search_188}\"/\"${replace_189}\"}\"\n        __status=$?\n    else\n        result_190=\"${source_187//\"${search_188}\"/${replace_189}}\"\n        __status=$?\n    fi\n    ret_replace25_v0=\"${result_190}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__27_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version27_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nreplace_regex__28_v0() {\n    local source_182=\"${1}\"\n    local search_183=\"${2}\"\n    local replace_text_184=\"${3}\"\n    local extended_185=\"${4}\"\n    sed_version__27_v0 \n    local sed_version_186=\"${ret_sed_version27_v0}\"\n    replace__25_v0 \"${search_183}\" \"/\" \"\\\\/\"\n    search_183=\"${ret_replace25_v0}\"\n    replace__25_v0 \"${replace_text_184}\" \"/\" \"\\\\/\"\n    replace_text_184=\"${ret_replace25_v0}\"\n    if [ \"$(( $(( sed_version_186 == __SED_VERSION_GNU_1 )) || $(( sed_version_186 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__25_v0 \"${search_183}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_183=\"${ret_replace25_v0}\"\n    fi\n    if [ \"${extended_185}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_186 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            local command_2\n            command_2=\"$(sed -r -e \"s/${search_183}/${replace_text_184}/g\" <<<\"${source_182}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_2}\"\n            return 0\n        else\n            local command_3\n            command_3=\"$(sed -E -e \"s/${search_183}/${replace_text_184}/g\" <<<\"${source_182}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_3}\"\n            return 0\n        fi\n    else\n        if [ \"$(( $(( sed_version_186 == __SED_VERSION_GNU_1 )) || $(( sed_version_186 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__25_v0 \"${search_183}\" \"\\\\|\" \"|\"\n            search_183=\"${ret_replace25_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -e \"s/${search_183}/${replace_text_184}/g\" <<<\"${source_182}\")\"\n        __status=$?\n        ret_replace_regex28_v0=\"${command_4}\"\n        return 0\n    fi\n}\n\nsplit__29_v0() {\n    local text_199=\"${1}\"\n    local delimiter_200=\"${2}\"\n    local result_201=()\n    IFS=\"${delimiter_200}\" read -rd '' -a result_201 < <(printf %s \"$text_199\")\n    __status=$?\n    ret_split29_v0=(\"${result_201[@]}\")\n    return 0\n}\n\njoin__32_v0() {\n    local list_196=(\"${!1}\")\n    local delimiter_197=\"${2}\"\n    local command_6\n    command_6=\"$(IFS=\"${delimiter_197}\" ; printf \"%s\n\" \"${list_196[*]}\")\"\n    __status=$?\n    ret_join32_v0=\"${command_6}\"\n    return 0\n}\n\ntrim__35_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    __status=$?\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim35_v0=\"${result_15}\"\n    return 0\n}\n\nis_mac_os_mktemp__72_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp72_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp72_v0=0\n    return 0\n}\n\ntemp_dir_create__73_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__35_v0 \"${template_11}\"\n    local ret_trim35_v0__113_8=\"${ret_trim35_v0}\"\n    if [ \"$([ \"_${ret_trim35_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__72_v0 \n    local ret_is_mac_os_mktemp72_v0__119_8=\"${ret_is_mac_os_mktemp72_v0}\"\n    if [ \"${ret_is_mac_os_mktemp72_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_7\n        command_7=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_7}\"\n    else\n        local command_8\n        command_8=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_8}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create73_v0=\"${filename_16}\"\n    return 0\n}\n\nescape_non_glob_chars__76_v0() {\n    local path_181=\"${1}\"\n    replace_regex__28_v0 \"${path_181}\" \"\\\\([^*?/]\\\\)\" \"\\\\\\\\\\\\1\" 0\n    ret_escape_non_glob_chars76_v0=\"${ret_replace_regex28_v0}\"\n    return 0\n}\n\nfile_glob_all__77_v0() {\n    local paths_179=(\"${!1}\")\n    local combined_180=\"\"\n    local __length_9=(\"${paths_179[@]}\")\n    if [ \"$(( ${#__length_9[@]} == 1 ))\" != 0 ]; then\n        escape_non_glob_chars__76_v0 \"${paths_179[0]}\"\n        combined_180=\"${ret_escape_non_glob_chars76_v0}\"\n    else\n        local items_194=()\n        for item_195 in \"${paths_179[@]}\"; do\n            escape_non_glob_chars__76_v0 \"${item_195}\"\n            item_195=\"${ret_escape_non_glob_chars76_v0}\"\n            items_194+=(\"${item_195}\")\n        done\n        join__32_v0 items_194[@] \" \"\n        combined_180=\"${ret_join32_v0}\"\n    fi\n    local command_12\n    command_12=\"$(eval \"for file in ${combined_180}; do [ -e \\\"\\$file\\\" ] && printf \\\"%s\\n\\\" \\\"\\$file\\\"; done\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob_all77_v0=()\n        return \"${__status}\"\n    fi\n    local files_198=\"${command_12}\"\n    split__29_v0 \"${files_198}\" \"\n\"\n    ret_file_glob_all77_v0=(\"${ret_split29_v0[@]}\")\n    return 0\n}\n\ncompare__129_v0() {\n    local actual_224=(\"${!1}\")\n    local expected_225=(\"${!2}\")\n    local __length_13=(\"${actual_224[@]}\")\n    local __length_14=(\"${expected_225[@]}\")\n    if [ \"$(( ${#__length_13[@]} != ${#__length_14[@]} ))\" != 0 ]; then\n        ret_compare129_v0=0\n        return 0\n    fi\n    for file_226 in \"${expected_225[@]}\"; do\n        array_contains__2_v0 actual_224[@] \"${file_226}\"\n        local ret_array_contains2_v0__10_16=\"${ret_array_contains2_v0}\"\n        if [ \"$(( ! ret_array_contains2_v0__10_16 ))\" != 0 ]; then\n            ret_compare129_v0=0\n            return 0\n        fi\n    done\n    ret_compare129_v0=1\n    return 0\n}\n\ntemp_dir_create__73_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create73_v0}\"\ntouch \"${tmpdir_17}/1st file with spaces.txt\"\ntouch \"${tmpdir_17}/2nd file with spaces.txt\"\ntouch \"${tmpdir_17}/file.txt\"\ntouch \"${tmpdir_17}/file1.txt\"\ntouch \"${tmpdir_17}/file2.txt\"\ntouch \"${tmpdir_17}/file99.txt\"\ntouch \"${tmpdir_17}/other.csv\"\ncd \"${tmpdir_17}\" || exit\nexpected_18=(\"file.txt\" \"file1.txt\" \"file2.txt\" \"file99.txt\" \"other.csv\")\narray_17=(\"missing*\" \"file*.txt\" \"other*.csv\")\nfile_glob_all__77_v0 array_17[@]\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"FAILED\"\nfi\nactual_202=(\"${ret_file_glob_all77_v0[@]}\")\ncompare__129_v0 actual_202[@] expected_18[@]\nret_compare129_v0__40_8=\"${ret_compare129_v0}\"\nif [ \"${ret_compare129_v0__40_8}\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Expected: ${expected_18[*]}\"\n    echo \"Actual: ${actual_202[*]}\"\nfi", "output": "import * from \"std/array\"\nimport * from \"std/fs\"\nimport * from \"std/text\"\n\nfun compare(actual: [Text], expected: [Text]): Bool {\n    if len(actual) != len(expected) {\n        return false\n    }\n    for file in expected {\n        if not array_contains(actual, file) {\n            return false\n        }\n    }\n    return true\n}\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    trust {\n        touch(\"{tmpdir}/1st file with spaces.txt\")\n        touch(\"{tmpdir}/2nd file with spaces.txt\")\n        touch(\"{tmpdir}/file.txt\")\n        touch(\"{tmpdir}/file1.txt\")\n        touch(\"{tmpdir}/file2.txt\")\n        touch(\"{tmpdir}/file99.txt\")\n        touch(\"{tmpdir}/other.csv\")\n    }\n    cd(tmpdir)\n\n    const expected = [\n        \"file.txt\",\n        \"file1.txt\",\n        \"file2.txt\",\n        \"file99.txt\",\n        \"other.csv\",\n    ]\n    const actual = file_glob_all([\"missing*\", \"file*.txt\", \"other*.csv\"]) failed {\n        echo(\"FAILED\")\n    }\n    if compare(actual, expected) {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Expected: {expected}\")\n        echo(\"Actual: {actual}\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nfile_exists__42_v0() {\n    local path_24=\"${1}\"\n    [ -f \"${path_24}\" ]\n    __status=$?\n    ret_file_exists42_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nsymlink_create__46_v0() {\n    local origin_22=\"${1}\"\n    local destination_23=\"${2}\"\n    file_exists__42_v0 \"${origin_22}\"\n    local ret_file_exists42_v0__71_8=\"${ret_file_exists42_v0}\"\n    if [ \"${ret_file_exists42_v0__71_8}\" != 0 ]; then\n        ln -fs \"${origin_22}\" \"${destination_23}\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_symlink_create46_v0=''\n            return \"${__status}\"\n        fi\n        ret_symlink_create46_v0=''\n        return 0\n    fi\n    echo \"The file ${origin_22} doesn't exist\"'!'\"\"\n    ret_symlink_create46_v0=''\n    return 1\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_0\n        command_0=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_0}\"\n    else\n        local command_1\n        command_1=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_1}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\n# Output\n# Succeeded\n# Succeeded\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ntouch \"${tmpdir_17}/amber-symbolic\"\nsymlink_create__46_v0 \"${tmpdir_17}/amber-symbolic\" \"${tmpdir_17}/amber-symbolic-link\"\n__status=$?\nif [ \"$(( __status == 0 ))\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"failed\"\nfi\ntouch \"${tmpdir_17}/amber-symbolic\"\ntouch \"${tmpdir_17}/amber-symbolic-link\"\nsymlink_create__46_v0 \"${tmpdir_17}/amber-symbolic\" \"${tmpdir_17}/amber-symbolic-link\"\n__status=$?\nif [ \"$(( __status == 0 ))\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"failed\"\nfi", "output": "import { symlink_create, temp_dir_create } from \"std/fs\"\n\n// Output\n// Succeeded\n// Succeeded\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    touch(\"{tmpdir}/amber-symbolic\")\n    trust symlink_create(\"{tmpdir}/amber-symbolic\", \"{tmpdir}/amber-symbolic-link\")\n    if status == 0 {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"failed\")\n    }\n    touch(\"{tmpdir}/amber-symbolic\")\n    touch(\"{tmpdir}/amber-symbolic-link\")\n    trust symlink_create(\"{tmpdir}/amber-symbolic\", \"{tmpdir}/amber-symbolic-link\")\n    if status == 0 {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"failed\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\narray_find__71_v0() {\n    local array_34=(\"${!1}\")\n    local value_35=\"${2}\"\n    index_37=0;\n    for element_36 in \"${array_34[@]}\"; do\n        if [ \"$([ \"_${value_35}\" != \"_${element_36}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find71_v0=\"${index_37}\"\n            return 0\n        fi\n        (( index_37++ )) || true\n    done\n    ret_array_find71_v0=-1\n    return 0\n}\n\nprintf__131_v0() {\n    local format_41=\"${1}\"\n    local args_42=(\"${!2}\")\n    args_42=(\"${format_41}\" \"${args_42[@]}\")\n    printf \"${args_42[@]}\"\n}\n\necho_colored__137_v0() {\n    local message_29=\"${1}\"\n    local color_30=\"${2}\"\n    local color_code_31=0\n        # https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit\n        local colors_name_32=(\"black\" \"red\" \"green\" \"yellow\" \"orange\" \"blue\" \"purple\" \"cyan\" \"gray\" \"white\")\n        local colors_code_33=(30 31 32 93 33 34 35 36 37 97)\n        array_find__71_v0 colors_name_32[@] \"${color_30}\"\n        local color_index_38=\"${ret_array_find71_v0}\"\n        if [ \"$(( color_index_38 == -1 ))\" != 0 ]; then\n            echo_error__141_v0 \"Invalid color name provided\" 1\n        fi\n        color_code_31=\"${colors_code_33[${color_index_38}]}\"\n    local array_2=(\"${message_29}\")\n    printf__131_v0 \"\\\\x1b[${color_code_31}m%s\\\\x1b[0m\n\" array_2[@]\n}\n\necho_colored__137_v1() {\n    local message_43=\"${1}\"\n    local color_44=\"${2}\"\n    local color_code_45=0\n        color_code_45=\"${color_44}\"\n    local array_3=(\"${message_43}\")\n    printf__131_v0 \"\\\\x1b[${color_code_45}m%s\\\\x1b[0m\n\" array_3[@]\n}\n\necho_error__141_v0() {\n    local message_39=\"${1}\"\n    local exit_code_40=\"${2}\"\n    local array_4=(\"${message_39}\")\n    printf__131_v0 \"\\\\x1b[1;3;97;41m%s\\\\x1b[0m\n\" array_4[@]\n    if [ \"$(( exit_code_40 > 0 ))\" != 0 ]; then\n        exit \"${exit_code_40}\"\n    fi\n}\n\n# Output\n# \u001b[33mHello Amber!\u001b[0m\n# \u001b[33mHello Amber!\u001b[0m\necho_colored__137_v0 \"Hello Amber\"'!'\"\" \"orange\"\necho_colored__137_v1 \"Hello Amber\"'!'\"\" 33", "output": "import * from \"std/env\"\n\n// Output\n// \u001b[33mHello Amber!\u001b[0m\n// \u001b[33mHello Amber!\u001b[0m\nmain {\n    echo_colored(\"Hello Amber!\", \"orange\")\n    echo_colored(\"Hello Amber!\", 33)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\ndir_exists__41_v0() {\n    local path_19=\"${1}\"\n    [ -d \"${path_19}\" ]\n    __status=$?\n    ret_dir_exists41_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_0\n        command_0=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_0}\"\n    else\n        local command_1\n        command_1=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_1}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 0\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ndir_exists__41_v0 \"${tmpdir_17}\"\nret_dir_exists41_v0__5_8=\"${ret_dir_exists41_v0}\"\nif [ \"${ret_dir_exists41_v0__5_8}\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Not Found\"\nfi", "output": "import * from \"std/fs\"\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true)?\n    if dir_exists(tmpdir) {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Not Found\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nlpad__28_v0() {\n    local text_8=\"${1}\"\n    local pad_9=\"${2}\"\n    local length_10=\"${3}\"\n    local __length_0=\"${text_8}\"\n    if [ \"$(( length_10 <= ${#__length_0} ))\" != 0 ]; then\n        ret_lpad28_v0=\"${text_8}\"\n        return 0\n    fi\n    local __length_1=\"${text_8}\"\n    local pad_len_11=\"$(( length_10 - ${#__length_1} ))\"\n    local padding_12=\"\"\n    printf -v padding_12 \"%${pad_len_11}s\" \"\"\n    padding_12=\"${padding_12// /${pad_9}}\"\n    ret_lpad28_v0=\"${padding_12}\"\"${text_8}\"\n    return 0\n}\n\n# Output\n# bba\n# aaa\nlpad__28_v0 \"a\" \"b\" 3\nret_lpad28_v0__8_10=\"${ret_lpad28_v0}\"\nprintf '%s\\n' \"${ret_lpad28_v0__8_10}\"\nlpad__28_v0 \"aaa\" \"b\" 3\nret_lpad28_v0__9_10=\"${ret_lpad28_v0}\"\nprintf '%s\\n' \"${ret_lpad28_v0__9_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// bba \n// aaa\n\nmain {\n    echo(lpad(\"a\", \"b\", 3))\n    echo(lpad(\"aaa\", \"b\", 3))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_filled__9_v0() {\n    local size_3=\"${1}\"\n    local value_4=\"${2}\"\n    local array_5=(\"${value_4}\")\n    # Used for type casting array\n    array_5=(\"${array_5[@]:0:0}\")\n    # Resetting the array size to 0\n    if [ \"$(( $(( size_3 <= 0 )) || $(( ! 1 )) ))\" != 0 ]; then\n        ret_array_filled9_v0=(\"${array_5[@]}\")\n        return 0\n    fi\n    local __range_start_6=0\n    local __range_end_6=\"${size_3}\"\n    local __dir_6=$(( ${__range_start_6} <= ${__range_end_6} ? 1 : -1 ))\n    for (( ____6=${__range_start_6}; ____6 * ${__dir_6} < ${__range_end_6} * ${__dir_6}; ____6+=${__dir_6} )); do\n        local array_1=(\"${value_4}\")\n        array_5+=(\"${array_1[@]}\")\ndone\n    ret_array_filled9_v0=(\"${array_5[@]}\")\n    return 0\n}\n\narray_filled__9_v0 0 1\narray_7=(\"${ret_array_filled9_v0[@]}\")\narray_3=()\nif [ \"$(\n    (( ${#array_7[@]} != ${#array_3[@]} )) && echo 0 && exit\n    for (( i=0; i<${#array_7[@]}; i++ )); do [[ \"${array_7[i]}\" != \"${array_3[i]}\" ]] && echo 0 && exit; done\n    echo 1\n)\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Failed\"\nfi", "output": "import { array_filled } from \"std/array\"\n\nmain {\n    const array = array_filled(0, true)\n    if array == [Bool]:\n        echo(\"Succeeded\")\n    else:\n        echo(\"Failed\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_remove_at__5_v0() {\n    local array_5=(\"${1}\")\n    local index_6=\"${2}\"\n    local offset_7=\"$(( index_6 + 1 ))\"\n    eval \"local array_5_deref_15=(\\\"\\${${array_5[0]}[@]}\\\")\"\n    local __length_0=(\"${array_5_deref_15[@]}\")\n    local length_8=\"${#__length_0[@]}\"\n    local slice_upper_1=\"${index_6}\"\n    local slice_offset_2=0\n    local slice_offset_2=$((${slice_offset_2} > 0 ? ${slice_offset_2} : 0))\n    local slice_length_3\n    slice_length_3=\"$(echo \"${slice_upper_1}\" '-' \"${slice_offset_2}\" | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\n    local slice_length_3=$((${slice_length_3} > 0 ? ${slice_length_3} : 0))\n    local slice_upper_4=\"${length_8}\"\n    local slice_offset_5=\"${offset_7}\"\n    local slice_offset_5=$((${slice_offset_5} > 0 ? ${slice_offset_5} : 0))\n    local slice_length_6\n    slice_length_6=\"$(echo \"${slice_upper_4}\" '-' \"${slice_offset_5}\" | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\n    local slice_length_6=$((${slice_length_6} > 0 ? ${slice_length_6} : 0))\n    eval \"local array_5_deref_16=(\\\"\\${${array_5[0]}[@]:\\${slice_offset_2}:\\${slice_length_3}}\\\")\"\n    eval \"local array_5_deref_17=(\\\"\\${${array_5[0]}[@]:\\${slice_offset_5}:\\${slice_length_6}}\\\")\"\n    eval \"${array_5}=(\\\"\\${array_5_deref_16[@]}\\\" \\\"\\${array_5_deref_17[@]}\\\")\"\n}\n\n# Output\n# Array before 1: (4) [zero one two three]\n# Array after 1: (3) [zero two three]\n# Array after 2: (2) [zero three]\n# Array after 3: (1) [zero]\n# Array after 4: (1) [zero]\nnumbers_0=(\"zero\" \"one\" \"two\" \"three\")\n__length_10=(\"${numbers_0[@]}\")\necho \"Array before 1: (${#__length_10[*]}) [${numbers_0[*]}]\"\narray_remove_at__5_v0 \"numbers_0\" 1\n__length_11=(\"${numbers_0[@]}\")\necho \"Array after 1: (${#__length_11[*]}) [${numbers_0[*]}]\"\narray_remove_at__5_v0 \"numbers_0\" 1\n__length_12=(\"${numbers_0[@]}\")\necho \"Array after 2: (${#__length_12[*]}) [${numbers_0[*]}]\"\narray_remove_at__5_v0 \"numbers_0\" 1\n__length_13=(\"${numbers_0[@]}\")\necho \"Array after 3: (${#__length_13[*]}) [${numbers_0[*]}]\"\narray_remove_at__5_v0 \"numbers_0\" 1\n__length_14=(\"${numbers_0[@]}\")\necho \"Array after 4: (${#__length_14[*]}) [${numbers_0[*]}]\"", "output": "import { array_remove_at } from \"std/array\"\n\n// Output\n// Array before 1: (4) [zero one two three]\n// Array after 1: (3) [zero two three]\n// Array after 2: (2) [zero three]\n// Array after 3: (1) [zero]\n// Array after 4: (1) [zero]\n\nmain {\n    const numbers = [\"zero\", \"one\", \"two\", \"three\"]\n    echo(\"Array before 1: ({len(numbers)}) [{numbers}]\")\n    array_remove_at(numbers, 1)\n    echo(\"Array after 1: ({len(numbers)}) [{numbers}]\")\n    array_remove_at(numbers, 1)\n    echo(\"Array after 2: ({len(numbers)}) [{numbers}]\")\n    array_remove_at(numbers, 1)\n    echo(\"Array after 3: ({len(numbers)}) [{numbers}]\")\n    array_remove_at(numbers, 1)\n    echo(\"Array after 4: ({len(numbers)}) [{numbers}]\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nsplit__5_v0() {\n    local text_6=\"${1}\"\n    local delimiter_7=\"${2}\"\n    local result_8=()\n    IFS=\"${delimiter_7}\" read -rd '' -a result_8 < <(printf %s \"$text_6\")\n    ret_split5_v0=(\"${result_8[@]}\")\n    return 0\n}\n\n# Output\n# apple ban\n# ana cherry\nsplit__5_v0 \"apple,ban\nana,cherry\" \",\"\narray_9=(\"${ret_split5_v0[@]}\")\nprintf '%s\\n' \"${array_9[*]}\"", "output": "import * from \"std/text\"\n\n// Output\n// apple ban\n// ana cherry\n\nmain {\n    const array = split(\"apple,ban\\nana,cherry\", \",\")\n    echo(array)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_last__4_v0() {\n    local array_11=(\"${!1}\")\n    local __length_0=(\"${array_11[@]}\")\n    local index_12=\"$(( ${#__length_0[@]} - 1 ))\"\n    if [ \"$(( index_12 < 0 ))\" != 0 ]; then\n        ret_array_last4_v0=''\n        return 1\n    fi\n    ret_array_last4_v0=\"${array_11[${index_12}]}\"\n    return 0\n}\n\n# Output\n# Last of numbers: \"three\" (4) [zero one two three]\n# Last of empty array does not exist\ntest_last__13_v0() {\n    local label_9=\"${1}\"\n    local data_10=(\"${!2}\")\n    array_last__4_v0 data_10[@]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        echo \"Last of empty array does not exist\"\n        ret_test_last13_v0=''\n        return 0\n    fi\n    local value_13=\"${ret_array_last4_v0}\"\n    local __length_1=(\"${data_10[@]}\")\n    echo \"Last of ${label_9}: \\\"${value_13}\\\" (${#__length_1[*]}) [${data_10[*]}]\"\n}\n\nnumbers_0=(\"zero\" \"one\" \"two\" \"three\")\nempty_1=()\ntest_last__13_v0 \"numbers\" numbers_0[@]\ntest_last__13_v0 \"empty\" empty_1[@]", "output": "import { array_last } from \"std/array\"\n\n// Output\n// Last of numbers: \"three\" (4) [zero one two three]\n// Last of empty array does not exist\n\nfun test_last(label: Text, data: [Text]): Null {\n    const value = array_last(data) failed {\n        echo(\"Last of empty array does not exist\")\n        return null\n    }\n    echo(\"Last of {label}: \\\"{value}\\\" ({len(data)}) [{data}]\")\n}\n\nmain {\n    const numbers = [\"zero\", \"one\", \"two\", \"three\"]\n    const empty = [Text]\n    test_last(\"numbers\", numbers)\n    test_last(\"empty\", empty)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nrpad__29_v0() {\n    local text_8=\"${1}\"\n    local pad_9=\"${2}\"\n    local length_10=\"${3}\"\n    local __length_0=\"${text_8}\"\n    if [ \"$(( length_10 <= ${#__length_0} ))\" != 0 ]; then\n        ret_rpad29_v0=\"${text_8}\"\n        return 0\n    fi\n    local __length_1=\"${text_8}\"\n    local pad_len_11=\"$(( length_10 - ${#__length_1} ))\"\n    local padding_12=\"\"\n    printf -v padding_12 \"%${pad_len_11}s\" \"\"\n    padding_12=\"${padding_12// /${pad_9}}\"\n    ret_rpad29_v0=\"${text_8}\"\"${padding_12}\"\n    return 0\n}\n\n# Output\n# abb\n# aaa\nrpad__29_v0 \"a\" \"b\" 3\nret_rpad29_v0__8_10=\"${ret_rpad29_v0}\"\nprintf '%s\\n' \"${ret_rpad29_v0__8_10}\"\nrpad__29_v0 \"aaa\" \"b\" 3\nret_rpad29_v0__9_10=\"${ret_rpad29_v0}\"\nprintf '%s\\n' \"${ret_rpad29_v0__9_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// abb \n// aaa\n\nmain {\n    echo(rpad(\"a\", \"b\", 3))\n    echo(rpad(\"aaa\", \"b\", 3))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nmath_abs__4_v0() {\n    local number_1=\"${1}\"\n    if [ \"$(( number_1 < 0 ))\" != 0 ]; then\n        ret_math_abs4_v0=\"$(( - number_1 ))\"\n        return 0\n    fi\n    ret_math_abs4_v0=\"${number_1}\"\n    return 0\n}\n\nmath_abs__4_v1() {\n    local number_2=\"${1}\"\n    if [ \"$(echo \"${number_2}\" '<' 0 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" != 0 ]; then\n        ret_math_abs4_v1=\"$(echo  '-' \"${number_2}\" | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\n        return 0\n    fi\n    ret_math_abs4_v1=\"${number_2}\"\n    return 0\n}\n\n# Output\n# 1\n# 1\n# 1.2\nmath_abs__4_v0 1\nret_math_abs4_v0__9_10=\"${ret_math_abs4_v0}\"\necho \"${ret_math_abs4_v0__9_10}\"\nmath_abs__4_v0 -1\nret_math_abs4_v0__10_10=\"${ret_math_abs4_v0}\"\necho \"${ret_math_abs4_v0__10_10}\"\nmath_abs__4_v1 1.2\nret_math_abs4_v1__11_10=\"${ret_math_abs4_v1}\"\necho \"${ret_math_abs4_v1__11_10}\"", "output": "import * from \"std/math\"\n\n// Output \n// 1\n// 1\n// 1.2\n\nmain {\n    echo(math_abs(1))\n    echo(math_abs(-1))\n    echo(math_abs(1.2))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_pop__7_v0() {\n    local array_15=(\"${1}\")\n    eval \"local array_15_deref_8=(\\\"\\${${array_15[0]}[@]}\\\")\"\n    local __length_0=(\"${array_15_deref_8[@]}\")\n    local length_16=\"${#__length_0[@]}\"\n    local index_17=\"$(( length_16 - 1 ))\"\n    if [ \"$(( index_17 < 0 ))\" != 0 ]; then\n        ret_array_pop7_v0=''\n        return 1\n    fi\n    eval \"local array_15_deref_9=\\\"\\${${array_15[0]}[${index_17}]}\\\"\"\n    local element_18=\"${array_15_deref_9}\"\n    local slice_upper_1=\"${index_17}\"\n    local slice_offset_2=0\n    local slice_offset_2=$((${slice_offset_2} > 0 ? ${slice_offset_2} : 0))\n    local slice_length_3\n    slice_length_3=\"$(echo \"${slice_upper_1}\" '-' \"${slice_offset_2}\" | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\n    local slice_length_3=$((${slice_length_3} > 0 ? ${slice_length_3} : 0))\n    eval \"local array_15_deref_10=(\\\"\\${${array_15[0]}[@]:\\${slice_offset_2}:\\${slice_length_3}}\\\")\"\n    eval \"${array_15}=(\\\"\\${array_15_deref_10[@]}\\\")\"\n    ret_array_pop7_v0=\"${element_18}\"\n    return 0\n}\n\n# Output\n# Popped from numbers: \"three\" (3) [zero one two]\n# Cannot pop from empty array\ntest_pop__13_v0() {\n    local label_13=\"${1}\"\n    local data_14=(\"${!2}\")\n    array_pop__7_v0 \"data_14\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        echo \"Cannot pop from empty array\"\n        ret_test_pop13_v0=''\n        return 0\n    fi\n    local value_19=\"${ret_array_pop7_v0}\"\n    local __length_4=(\"${data_14[@]}\")\n    echo \"Popped from ${label_13}: \\\"${value_19}\\\" (${#__length_4[*]}) [${data_14[*]}]\"\n}\n\nnumbers_0=(\"zero\" \"one\" \"two\" \"three\")\nempty_1=()\ntest_pop__13_v0 \"numbers\" numbers_0[@]\ntest_pop__13_v0 \"empty\" empty_1[@]", "output": "import { array_pop } from \"std/array\"\n\n// Output\n// Popped from numbers: \"three\" (3) [zero one two]\n// Cannot pop from empty array\n\nfun test_pop(label: Text, data: [Text]): Null {\n    const value = array_pop(data) failed {\n        echo(\"Cannot pop from empty array\")\n        return null\n    }\n    echo(\"Popped from {label}: \\\"{value}\\\" ({len(data)}) [{data}]\")\n}\n\nmain {\n    const numbers = [\"zero\", \"one\", \"two\", \"three\"]\n    const empty = [Text]\n    test_pop(\"numbers\", numbers)\n    test_pop(\"empty\", empty)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_14=(\"${!1}\")\n    local value_15=\"${2}\"\n    index_17=0;\n    for element_16 in \"${array_14[@]}\"; do\n        if [ \"$([ \"_${value_15}\" != \"_${element_16}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_17}\"\n            return 0\n        fi\n        (( index_17++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\n# Output\n# Index of \"zero\": 0\n# Index of \"one\": 1\n# Index of \"two\": 2\n# Index of \"three\": 3\n# Index of \"four\": -1\ntest_index__13_v0() {\n    local data_12=(\"${!1}\")\n    local value_13=\"${2}\"\n    array_find__0_v0 data_12[@] \"${value_13}\"\n    local index_18=\"${ret_array_find0_v0}\"\n    echo \"Index of \\\"${value_13}\\\": ${index_18}\"\n}\n\nnumbers_0=(\"zero\" \"one\" \"two\" \"three\" \"two\" \"one\" \"zero\")\ntest_index__13_v0 numbers_0[@] \"zero\"\ntest_index__13_v0 numbers_0[@] \"one\"\ntest_index__13_v0 numbers_0[@] \"two\"\ntest_index__13_v0 numbers_0[@] \"three\"\ntest_index__13_v0 numbers_0[@] \"four\"", "output": "import { array_find } from \"std/array\"\n\n// Output\n// Index of \"zero\": 0\n// Index of \"one\": 1\n// Index of \"two\": 2\n// Index of \"three\": 3\n// Index of \"four\": -1\n\nfun test_index(data: [Text], value: Text): Null {\n    const index = array_find(data, value)\n    echo(\"Index of \\\"{value}\\\": {index}\")\n}\n\nmain {\n    const numbers = [\"zero\", \"one\", \"two\", \"three\", \"two\", \"one\", \"zero\"]\n    test_index(numbers, \"zero\")\n    test_index(numbers, \"one\")\n    test_index(numbers, \"two\")\n    test_index(numbers, \"three\")\n    test_index(numbers, \"four\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nslice__25_v0() {\n    local text_7=\"${1}\"\n    local index_8=\"${2}\"\n    local length_9=\"${3}\"\n    local result_10=\"\"\n    if [ \"$(( length_9 == 0 ))\" != 0 ]; then\n        local __length_0=\"${text_7}\"\n        length_9=\"$(( ${#__length_0} - index_8 ))\"\n    fi\n    if [ \"$(( length_9 <= 0 ))\" != 0 ]; then\n        ret_slice25_v0=\"${result_10}\"\n        return 0\n    fi\n    result_10=\"${text_7: ${index_8}: ${length_9}}\"\n    ret_slice25_v0=\"${result_10}\"\n    return 0\n}\n\n# Output\n# world\n# world\n# world\nslice__25_v0 \"hello world\" 6 5\nret_slice25_v0__9_10=\"${ret_slice25_v0}\"\nprintf '%s\\n' \"${ret_slice25_v0__9_10}\"\nslice__25_v0 \"hello world\" 6 0\nret_slice25_v0__10_10=\"${ret_slice25_v0}\"\nprintf '%s\\n' \"${ret_slice25_v0__10_10}\"\nslice__25_v0 \"hello world\" -5 5\nret_slice25_v0__11_10=\"${ret_slice25_v0}\"\nprintf '%s\\n' \"${ret_slice25_v0__11_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// world\n// world\n// world\n\nmain {\n    echo(slice(\"hello world\", 6, 5))\n    echo(slice(\"hello world\", 6))\n    echo(slice(\"hello world\", -5, 5))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nfile_read__43_v0() {\n    local path_23=\"${1}\"\n    local command_0\n    command_0=\"$(< \"${path_23}\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_read43_v0=''\n        return \"${__status}\"\n    fi\n    ret_file_read43_v0=\"${command_0}\"\n    return 0\n}\n\nfile_append__45_v0() {\n    local path_20=\"${1}\"\n    local content_21=\"${2}\"\n    local command_1\n    command_1=\"$(printf '%s\n' \"${content_21}\" >> \"${path_20}\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_append45_v0=''\n        return \"${__status}\"\n    fi\n    ret_file_append45_v0=\"${command_1}\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_2\n        command_2=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_2}\"\n    else\n        local command_3\n        command_3=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_3}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\n# Output\n# Succeeded\n# 2\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ncd \"${tmpdir_17}\" || exit\ntouch \"test.txt\"\nfile_append__45_v0 \"test.txt\" \"Succeeded\"\n__status=$?\nfile_read__43_v0 \"test.txt\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"Failed\"\nfi\nf_24=\"${ret_file_read43_v0}\"\nprintf '%s\\n' \"${f_24}\"\ntouch \"dash.txt\"\nfile_append__45_v0 \"dash.txt\" \"-n\"\n__status=$?\nfile_read__43_v0 \"dash.txt\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"Failed\"\nfi\nd_25=\"${ret_file_read43_v0}\"\n__length_5=\"${d_25}\"\nprintf '%s\\n' \"${#__length_5}\"", "output": "// Output\n// Succeeded\n// 2\n\nimport * from \"std/fs\"\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    cd(tmpdir)\n    touch(\"test.txt\")\n    trust file_append(\"test.txt\", \"Succeeded\")\n    const f = file_read(\"test.txt\") failed {\n        echo(\"Failed\")\n    }\n    echo(f)\n\n    touch(\"dash.txt\")\n    trust file_append(\"dash.txt\", \"-n\")\n    const d = file_read(\"dash.txt\") failed {\n        echo(\"Failed\")\n    }\n    echo(len(d))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ncount_chars__33_v0() {\n    local text_4=\"${1}\"\n    ret_count_chars33_v0=\"$(printf \"%s\" \"${text_4}\" | wc -m | tr -d ' ')\"\n    return 0\n}\n\n# Output\n# 5\n# 0\n# 11\ncount_chars__33_v0 \"hello\"\nret_count_chars33_v0__9_10=\"${ret_count_chars33_v0}\"\necho \"${ret_count_chars33_v0__9_10}\"\ncount_chars__33_v0 \"\"\nret_count_chars33_v0__10_10=\"${ret_count_chars33_v0}\"\necho \"${ret_count_chars33_v0__10_10}\"\ncount_chars__33_v0 \"hello world\"\nret_count_chars33_v0__11_10=\"${ret_count_chars33_v0}\"\necho \"${ret_count_chars33_v0__11_10}\"", "output": "import { count_chars } from \"std/text\"\n\n// Output\n// 5\n// 0\n// 11\n\nmain {\n    echo(count_chars(\"hello\"))\n    echo(count_chars(\"\"))\n    echo(count_chars(\"hello world\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# All dates are internally stored as milliseconds since the Epoch (1970-01-01 00:00 UTC).\ndate_from_posix__1_v0() {\n    local date_4=\"${1}\"\n    local format_5=\"${2}\"\n    local utc_6=\"${3}\"\n    local utc_flag_7\n    utc_flag_7=\"$(if [ \"${utc_6}\" != 0 ]; then echo \"-u\"; else echo \"\"; fi)\"\n    # Case if this is a GNU date command\n    local command_1\n    command_1=\"$(date ${utc_flag_7} -d \"$(date -d \"${date_4}\" +\"${format_5}\" 2>/dev/null)\" +%s 2>/dev/null)\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        # Case if this is a BSD date command\n        local command_0\n        command_0=\"$(date ${utc_flag_7} -j -f \"${format_5}\" \"${date_4}\" +%s)\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_date_from_posix1_v0=''\n            return \"${__status}\"\n        fi\n        ret_date_from_posix1_v0=\"${command_0}\"\n        return 0\n    fi\n    ret_date_from_posix1_v0=\"${command_1}\"\n    return 0\n}\n\ndate_from_posix__1_v0 \"2000-01-01 00:00:00\" \"%F %T\" 0\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_date_from_posix1_v0__4_8=\"${ret_date_from_posix1_v0}\"\ndate_from_posix__1_v0 \"2100-01-01 00:00:00\" \"%F %T\" 0\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_date_from_posix1_v0__4_50=\"${ret_date_from_posix1_v0}\"\nif [ \"$(( ret_date_from_posix1_v0__4_8 < ret_date_from_posix1_v0__4_50 ))\" != 0 ]; then\n    echo \"Succeeded\"\nfi", "output": "import * from \"std/date\"\n\nmain {\n    if date_from_posix(\"2000-01-01 00:00:00\")? < date_from_posix(\"2100-01-01 00:00:00\")? {\n        echo(\"Succeeded\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\ndir_exists__41_v0() {\n    local path_28=\"${1}\"\n    [ -d \"${path_28}\" ]\n    __status=$?\n    ret_dir_exists41_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nfile_exists__42_v0() {\n    local path_27=\"${1}\"\n    [ -f \"${path_27}\" ]\n    __status=$?\n    ret_file_exists42_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_0\n        command_0=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_0}\"\n    else\n        local command_1\n        command_1=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_1}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\nfile_chown__51_v0() {\n    local path_25=\"${1}\"\n    local user_26=\"${2}\"\n    file_exists__42_v0 \"${path_25}\"\n    local ret_file_exists42_v0__171_8=\"${ret_file_exists42_v0}\"\n    dir_exists__41_v0 \"${path_25}\"\n    local ret_dir_exists41_v0__171_29=\"${ret_dir_exists41_v0}\"\n    if [ \"$(( ret_file_exists42_v0__171_8 || ret_dir_exists41_v0__171_29 ))\" != 0 ]; then\n        chown -R \"${user_26}\" \"${path_25}\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_file_chown51_v0=''\n            return \"${__status}\"\n        fi\n        ret_file_chown51_v0=''\n        return 0\n    fi\n    echo \"The file ${path_25} doesn't exist\"'!'\"\"\n    ret_file_chown51_v0=''\n    return 1\n}\n\n# We use `whoami` to get the running user to assign again the same user as permission\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"It wasn't possible to create the folder\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ntouch \"${tmpdir_17}/amber-symbolic\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"It wasn't possible to create ${tmpdir_17}/amber-symbolic\"\nfi\ncommand_3=\"$(whoami)\"\n__status=$?\nowner_18=\"${command_3}\"\nfile_chown__51_v0 \"${tmpdir_17}/amber-symbolic\" \"${owner_18}\"\n__status=$?\nif [ \"$(( __status == 0 ))\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"File ${tmpdir_17}/amber-symbolic not exists\"\nfi", "output": "import { file_chown, temp_dir_create } from \"std/fs\"\n\n// We use `whoami` to get the running user to assign again the same user as permission\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true) failed {\n        echo(\"It wasn't possible to create the folder\")\n    }\n    $ touch \"{tmpdir}/amber-symbolic\" $ failed {\n        echo(\"It wasn't possible to create {tmpdir}/amber-symbolic\")\n    }\n    const owner = trust $ whoami $\n    trust file_chown(\"{tmpdir}/amber-symbolic\", owner)\n    if status == 0 {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"File {tmpdir}/amber-symbolic not exists\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntext_contains__17_v0() {\n    local source_5=\"${1}\"\n    local search_6=\"${2}\"\n    [[ \"${source_5}\" == *\"${search_6}\"* ]]\n    __status=$?\n    ret_text_contains17_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\ntext_contains__17_v0 \"Hello World\" \"World\"\nret_text_contains17_v0__3_4=\"${ret_text_contains17_v0}\"\nif [ \"${ret_text_contains17_v0__3_4}\" != 0 ]; then\n    echo \"Succeeded\"\nfi", "output": "import { text_contains } from \"std/text\"\n\nif text_contains(\"Hello World\", \"World\") {\n    echo(\"Succeeded\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\njoin__8_v0() {\n    local list_17=(\"${!1}\")\n    local delimiter_18=\"${2}\"\n    ret_join8_v0=\"$(IFS=\"${delimiter_18}\" ; printf \"%s\n\" \"${list_17[*]}\")\"\n    return 0\n}\n\nbash_version__142_v0() {\n    local major_6\n    major_6=\"$(printf \"%s\n\" \"${BASH_VERSINFO[0]}\")\"\n    local minor_7\n    minor_7=\"$(printf \"%s\n\" \"${BASH_VERSINFO[1]}\")\"\n    local patch_8\n    patch_8=\"$(printf \"%s\n\" \"${BASH_VERSINFO[2]}\")\"\n    ret_bash_version142_v0=(\"${major_6}\" \"${minor_7}\" \"${patch_8}\")\n    return 0\n}\n\nbash_version_to_text__163_v0() {\n    local arr_16=(\"${!1}\")\n    join__8_v0 arr_16[@] \" \"\n    ret_bash_version_to_text163_v0=\"${ret_join8_v0}\"\n    return 0\n}\n\nbash_version__142_v0 \nversion_9=(\"${ret_bash_version142_v0[@]}\")\nbash_verinfo_10=\"$(echo ${BASH_VERSINFO[@]:0:3})\"\nbash_version_to_text__163_v0 version_9[@]\nret_bash_version_to_text163_v0__13_24=\"${ret_bash_version_to_text163_v0}\"\nif [ \"$([ \"_${bash_verinfo_10}\" != \"_${ret_bash_version_to_text163_v0__13_24}\" ]; echo $?)\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Bash versions are not matching ${version_9[*]} vs ${bash_verinfo_10}\"\nfi", "output": "import { bash_version } from \"std/env\"\nimport { join } from \"std/text\"\n\n#[allow_absurd_cast]\nfun bash_version_to_text(arr: [Int]): Text {\n    return join(arr as [Text], \" \")\n}\n\nmain {\n    const version = bash_version()\n    const bash_verinfo = trust $ echo \\$\\{BASH_VERSINFO[@]:0:3} $\n\n    if bash_verinfo == bash_version_to_text(version) {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Bash versions are not matching {version} vs {bash_verinfo}\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nprintf__131_v0() {\n    local format_9=\"${1}\"\n    local args_10=(\"${!2}\")\n    args_10=(\"${format_9}\" \"${args_10[@]}\")\n    printf \"${args_10[@]}\"\n}\n\necho_info__138_v0() {\n    local message_8=\"${1}\"\n    local array_0=(\"${message_8}\")\n    printf__131_v0 \"\\\\x1b[1;3;97;44m%s\\\\x1b[0m\n\" array_0[@]\n}\n\n# Output\n# \u001b[1;3;97;44mHello Amber!\u001b[0m\necho_info__138_v0 \"Hello Amber\"'!'\"\"", "output": "import * from \"std/env\"\n\n// Output\n// \u001b[1;3;97;44mHello Amber!\u001b[0m\n\nmain {\n    echo_info(\"Hello Amber!\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_14=(\"${!1}\")\n    local value_15=\"${2}\"\n    index_17=0;\n    for element_16 in \"${array_14[@]}\"; do\n        if [ \"$([ \"_${value_15}\" != \"_${element_16}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_17}\"\n            return 0\n        fi\n        (( index_17++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_12=(\"${!1}\")\n    local value_13=\"${2}\"\n    array_find__0_v0 array_12[@] \"${value_13}\"\n    local result_18=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_18 >= 0 ))\"\n    return 0\n}\n\n# Output\n# Not Found\narray_0=()\narray_contains__2_v0 array_0[@] \" \"\nret_array_contains2_v0__8_8=\"${ret_array_contains2_v0}\"\nif [ \"${ret_array_contains2_v0__8_8}\" != 0 ]; then\n    echo \"Found\"\nelse\n    echo \"Not Found\"\nfi", "output": "import * from \"std/array\"\n\n// Output\n// Not Found\n\nmain {\n    const array = [Text]\n    if array_contains(array, \" \") {\n        echo(\"Found\")\n    } else {\n        echo(\"Not Found\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_filled__9_v0() {\n    local size_3=\"${1}\"\n    local value_4=\"${2}\"\n    local array_5=(\"${value_4}\")\n    # Used for type casting array\n    array_5=(\"${array_5[@]:0:0}\")\n    # Resetting the array size to 0\n    if [ \"$(( $(( size_3 <= 0 )) || $(( ! 1 )) ))\" != 0 ]; then\n        ret_array_filled9_v0=(\"${array_5[@]}\")\n        return 0\n    fi\n    local __range_start_6=0\n    local __range_end_6=\"${size_3}\"\n    local __dir_6=$(( ${__range_start_6} <= ${__range_end_6} ? 1 : -1 ))\n    for (( ____6=${__range_start_6}; ____6 * ${__dir_6} < ${__range_end_6} * ${__dir_6}; ____6+=${__dir_6} )); do\n        local array_1=(\"${value_4}\")\n        array_5+=(\"${array_1[@]}\")\ndone\n    ret_array_filled9_v0=(\"${array_5[@]}\")\n    return 0\n}\n\narray_filled__9_v0 0 \"\"\narray_7=(\"${ret_array_filled9_v0[@]}\")\narray_3=()\nif [ \"$(\n    (( ${#array_7[@]} != ${#array_3[@]} )) && echo 0 && exit\n    for (( i=0; i<${#array_7[@]}; i++ )); do [[ \"${array_7[i]}\" != \"${array_3[i]}\" ]] && echo 0 && exit; done\n    echo 1\n)\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Failed\"\nfi", "output": "import { array_filled } from \"std/array\"\n\nmain {\n    const array = array_filled(0, \"\")\n    if array == [Text]:\n        echo(\"Succeeded\")\n    else:\n        echo(\"Failed\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_first__3_v0() {\n    local array_9=(\"${!1}\")\n    local __length_0=(\"${array_9[@]}\")\n    if [ \"$(( ${#__length_0[@]} == 0 ))\" != 0 ]; then\n        ret_array_first3_v0=''\n        return 1\n    fi\n    ret_array_first3_v0=\"${array_9[0]}\"\n    return 0\n}\n\n# Output\n# First of numbers: \"zero\" (4) [zero one two three]\n# First of empty array does not exist\ntest_first__13_v0() {\n    local label_7=\"${1}\"\n    local data_8=(\"${!2}\")\n    array_first__3_v0 data_8[@]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        echo \"First of empty array does not exist\"\n        ret_test_first13_v0=''\n        return 0\n    fi\n    local value_10=\"${ret_array_first3_v0}\"\n    local __length_1=(\"${data_8[@]}\")\n    echo \"First of ${label_7}: \\\"${value_10}\\\" (${#__length_1[*]}) [${data_8[*]}]\"\n}\n\nnumbers_0=(\"zero\" \"one\" \"two\" \"three\")\nempty_1=()\ntest_first__13_v0 \"numbers\" numbers_0[@]\ntest_first__13_v0 \"empty\" empty_1[@]", "output": "import { array_first } from \"std/array\"\n\n// Output\n// First of numbers: \"zero\" (4) [zero one two three]\n// First of empty array does not exist\n\nfun test_first(label: Text, data: [Text]): Null {\n    const value = array_first(data) failed {\n        echo(\"First of empty array does not exist\")\n        return null\n    }\n    echo(\"First of {label}: \\\"{value}\\\" ({len(data)}) [{data}]\")\n}\n\nmain {\n    const numbers = [\"zero\", \"one\", \"two\", \"three\"]\n    const empty = [Text]\n    test_first(\"numbers\", numbers)\n    test_first(\"empty\", empty)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_0\n        command_0=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_0}\"\n    else\n        local command_1\n        command_1=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_1}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\ninput_hidden__127_v0() {\n    local prompt_20=\"${1}\"\n    read -s -p \"$prompt_20\" || read -s -p \"$prompt_20\" < /dev/tty\n    __status=$?\n    echo \"\" >&2\n    __status=$?\n    local command_2\n    command_2=\"$(printf '%s\n' $REPLY)\"\n    __status=$?\n    ret_input_hidden127_v0=\"${command_2}\"\n    return 0\n}\n\n# Output\n# Hello, Amber\ntemp_dir_create__49_v0 \"amber-input-test-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ntest_file_18=\"${tmpdir_17}/test_input\"\necho \"Amber\" >> ${test_file_18}\n__status=$?\nexec 0< ${test_file_18}\n__status=$?\ninput_hidden__127_v0 \"Please enter your name:\"\nname_21=\"${ret_input_hidden127_v0}\"\necho \"Hello, \"\"${name_21}\"", "output": "import * from \"std/env\"\nimport { temp_dir_create } from \"std/fs\"\n\n// Output\n// Hello, Amber\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-input-test-XXXX\", true, true)?\n    const test_file = \"{tmpdir}/test_input\"\n    trust $ echo \"Amber\" >> {test_file} $\n    trust $ exec 0< {test_file} $\n    const name = input_hidden(\"Please enter your name:\")\n    echo(\"Hello, \" + name)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nreversed__22_v0() {\n    local text_4=\"${1}\"\n    ret_reversed22_v0=\"$(rev <<< \"${text_4}\")\"\n    return 0\n}\n\n# Output\n# dlrow olleh\n# E-\nreversed__22_v0 \"hello world\"\nret_reversed22_v0__8_10=\"${ret_reversed22_v0}\"\nprintf '%s\\n' \"${ret_reversed22_v0__8_10}\"\nreversed__22_v0 \"-E\"\nret_reversed22_v0__9_10=\"${ret_reversed22_v0}\"\nprintf '%s\\n' \"${ret_reversed22_v0__9_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// dlrow olleh\n// E-\n\nmain {\n    echo(reversed(\"hello world\"))\n    echo(reversed(\"-E\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_filled__9_v0() {\n    local size_3=\"${1}\"\n    local value_4=\"${2}\"\n    local array_5=(\"${value_4}\")\n    # Used for type casting array\n    array_5=(\"${array_5[@]:0:0}\")\n    # Resetting the array size to 0\n    if [ \"$(( $(( size_3 <= 0 )) || $(( ! 1 )) ))\" != 0 ]; then\n        ret_array_filled9_v0=(\"${array_5[@]}\")\n        return 0\n    fi\n    local __range_start_6=0\n    local __range_end_6=\"${size_3}\"\n    local __dir_6=$(( ${__range_start_6} <= ${__range_end_6} ? 1 : -1 ))\n    for (( ____6=${__range_start_6}; ____6 * ${__dir_6} < ${__range_end_6} * ${__dir_6}; ____6+=${__dir_6} )); do\n        local array_1=(\"${value_4}\")\n        array_5+=(\"${array_1[@]}\")\ndone\n    ret_array_filled9_v0=(\"${array_5[@]}\")\n    return 0\n}\n\narray_filled__9_v0 0 1\narray_7=(\"${ret_array_filled9_v0[@]}\")\narray_3=()\nif [ \"$(\n    (( ${#array_7[@]} != ${#array_3[@]} )) && echo 0 && exit\n    for (( i=0; i<${#array_7[@]}; i++ )); do [[ \"${array_7[i]}\" != \"${array_3[i]}\" ]] && echo 0 && exit; done\n    echo 1\n)\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Failed\"\nfi", "output": "import { array_filled } from \"std/array\"\n\nmain {\n    const array = array_filled(0, 1)\n    if array == [Int]:\n        echo(\"Succeeded\")\n    else:\n        echo(\"Failed\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nshopt_disable__160_v0() {\n    local optname_5=\"${1}\"\n    local set_opt_6=\"${2}\"\n    if [ \"${set_opt_6}\" != 0 ]; then\n        shopt -qou \"${optname_5}\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_shopt_disable160_v0=''\n            return \"${__status}\"\n        fi\n    else\n        shopt -qu \"${optname_5}\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_shopt_disable160_v0=''\n            return \"${__status}\"\n        fi\n    fi\n}\n\n# Output\n# .\nshopt_disable__160_v0 \"dotglob\" 0\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\necho .\n__status=$?\nshopt_disable__160_v0 \"noglob\" 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi", "output": "import { shopt_disable } from \"std/env\"\n\n// Output\n// .\n\nmain {\n   shopt_disable(\"dotglob\")?\n   trust $ echo . $\n   shopt_disable(\"noglob\", true)?\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nlpad__28_v0() {\n    local text_17=\"${1}\"\n    local pad_18=\"${2}\"\n    local length_19=\"${3}\"\n    local __length_0=\"${text_17}\"\n    if [ \"$(( length_19 <= ${#__length_0} ))\" != 0 ]; then\n        ret_lpad28_v0=\"${text_17}\"\n        return 0\n    fi\n    local __length_1=\"${text_17}\"\n    local pad_len_20=\"$(( length_19 - ${#__length_1} ))\"\n    local padding_21=\"\"\n    printf -v padding_21 \"%${pad_len_20}s\" \"\"\n    padding_21=\"${padding_21// /${pad_18}}\"\n    ret_lpad28_v0=\"${padding_21}\"\"${text_17}\"\n    return 0\n}\n\nzfill__30_v0() {\n    local text_15=\"${1}\"\n    local length_16=\"${2}\"\n    lpad__28_v0 \"${text_15}\" \"0\" \"${length_16}\"\n    ret_zfill30_v0=\"${ret_lpad28_v0}\"\n    return 0\n}\n\n# Output\n# 001\n# 123\nzfill__30_v0 \"1\" 3\nret_zfill30_v0__8_10=\"${ret_zfill30_v0}\"\nprintf '%s\\n' \"${ret_zfill30_v0__8_10}\"\nzfill__30_v0 \"123\" 3\nret_zfill30_v0__9_10=\"${ret_zfill30_v0}\"\nprintf '%s\\n' \"${ret_zfill30_v0__9_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// 001 \n// 123\n\nmain {\n    echo(zfill(\"1\", 3))\n    echo(zfill(\"123\", 3))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nlowercase__12_v0() {\n    local text_4=\"${1}\"\n    ret_lowercase12_v0=\"$(tr '[:upper:]' '[:lower:]' <<< \"${text_4}\")\"\n    return 0\n}\n\n# Output\n# hello world\nlowercase__12_v0 \"HELLO WORLD\"\nret_lowercase12_v0__7_10=\"${ret_lowercase12_v0}\"\nprintf '%s\\n' \"${ret_lowercase12_v0__7_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// hello world\n\nmain {\n    echo(lowercase(\"HELLO WORLD\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nsplit_chars__16_v0() {\n    local text_5=\"${1}\"\n    local chars_6=()\n    for ((i=0; i<${#text_5}; i++)); do\n        chars_6+=( \"${text_5:$i:1}\" );\n    done\n    ret_split_chars16_v0=(\"${chars_6[@]}\")\n    return 0\n}\n\n# Output\n# h e l l o\nsplit_chars__16_v0 \"hello\"\nret_split_chars16_v0__7_10=(\"${ret_split_chars16_v0[@]}\")\nprintf '%s\\n' \"${ret_split_chars16_v0__7_10[*]}\"", "output": "import * from \"std/text\"\n\n// Output\n// h e l l o\n\nmain {\n    echo(split_chars(\"hello\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nsplit__5_v0() {\n    local text_6=\"${1}\"\n    local delimiter_7=\"${2}\"\n    local result_8=()\n    IFS=\"${delimiter_7}\" read -rd '' -a result_8 < <(printf %s \"$text_6\")\n    ret_split5_v0=(\"${result_8[@]}\")\n    return 0\n}\n\n# Output\n# banana\nsplit__5_v0 \"apple,banana,cherry\" \",\"\narray_9=(\"${ret_split5_v0[@]}\")\nprintf '%s\\n' \"${array_9[1]}\"", "output": "import * from \"std/text\"\n\n// Output\n// banana\n\nmain {\n    const array = split(\"apple,banana,cherry\", \",\")\n    echo(array[1])\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nprintf__131_v0() {\n    local format_9=\"${1}\"\n    local args_10=(\"${!2}\")\n    args_10=(\"${format_9}\" \"${args_10[@]}\")\n    printf \"${args_10[@]}\"\n}\n\necho_warning__140_v0() {\n    local message_8=\"${1}\"\n    local array_0=(\"${message_8}\")\n    printf__131_v0 \"\\\\x1b[1;3;97;43m%s\\\\x1b[0m\n\" array_0[@]\n}\n\n# Output\n# \u001b[1;3;97;43mHello Amber!\u001b[0m\necho_warning__140_v0 \"Hello Amber\"'!'\"\"", "output": "import * from \"std/env\"\n\n// Output\n// \u001b[1;3;97;43mHello Amber!\u001b[0m\n\nmain {\n    echo_warning(\"Hello Amber!\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nfile_exists__42_v0() {\n    local path_19=\"${1}\"\n    [ -f \"${path_19}\" ]\n    __status=$?\n    ret_file_exists42_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_0\n        command_0=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_0}\"\n    else\n        local command_1\n        command_1=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_1}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ntouch \"${tmpdir_17}/test.txt\"\nfile_exists__42_v0 \"${tmpdir_17}/test.txt\"\nret_file_exists42_v0__6_8=\"${ret_file_exists42_v0}\"\nif [ \"${ret_file_exists42_v0__6_8}\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Not Found\"\nfi", "output": "import * from \"std/fs\"\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    touch(\"{tmpdir}/test.txt\")\n    if file_exists(\"{tmpdir}/test.txt\") {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Not Found\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_309=(\"${!1}\")\n    local value_310=\"${2}\"\n    index_312=0;\n    for element_311 in \"${array_309[@]}\"; do\n        if [ \"$([ \"_${value_310}\" != \"_${element_311}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_312}\"\n            return 0\n        fi\n        (( index_312++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_307=(\"${!1}\")\n    local value_308=\"${2}\"\n    array_find__0_v0 array_307[@] \"${value_308}\"\n    local result_313=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_313 >= 0 ))\"\n    return 0\n}\n\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__24_v0() {\n    local major_271=0\n    local minor_272=0\n    local patch_273=0\n    major_271=${BASH_VERSINFO[0]}\n        minor_272=${BASH_VERSINFO[1]}\n        patch_273=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version24_v0=(\"${major_271}\" \"${minor_272}\" \"${patch_273}\")\n    return 0\n}\n\nreplace__25_v0() {\n    local source_267=\"${1}\"\n    local search_268=\"${2}\"\n    local replace_269=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_270=\"\"\n    bash_version__24_v0 \n    left_comp=(\"${ret_bash_version24_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_270=\"${source_267//\"${search_268}\"/\"${replace_269}\"}\"\n        __status=$?\n    else\n        result_270=\"${source_267//\"${search_268}\"/${replace_269}}\"\n        __status=$?\n    fi\n    ret_replace25_v0=\"${result_270}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__27_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version27_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nreplace_regex__28_v0() {\n    local source_262=\"${1}\"\n    local search_263=\"${2}\"\n    local replace_text_264=\"${3}\"\n    local extended_265=\"${4}\"\n    sed_version__27_v0 \n    local sed_version_266=\"${ret_sed_version27_v0}\"\n    replace__25_v0 \"${search_263}\" \"/\" \"\\\\/\"\n    search_263=\"${ret_replace25_v0}\"\n    replace__25_v0 \"${replace_text_264}\" \"/\" \"\\\\/\"\n    replace_text_264=\"${ret_replace25_v0}\"\n    if [ \"$(( $(( sed_version_266 == __SED_VERSION_GNU_1 )) || $(( sed_version_266 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__25_v0 \"${search_263}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_263=\"${ret_replace25_v0}\"\n    fi\n    if [ \"${extended_265}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_266 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            local command_2\n            command_2=\"$(sed -r -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_2}\"\n            return 0\n        else\n            local command_3\n            command_3=\"$(sed -E -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_3}\"\n            return 0\n        fi\n    else\n        if [ \"$(( $(( sed_version_266 == __SED_VERSION_GNU_1 )) || $(( sed_version_266 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__25_v0 \"${search_263}\" \"\\\\|\" \"|\"\n            search_263=\"${ret_replace25_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n        __status=$?\n        ret_replace_regex28_v0=\"${command_4}\"\n        return 0\n    fi\n}\n\nsplit__29_v0() {\n    local text_279=\"${1}\"\n    local delimiter_280=\"${2}\"\n    local result_281=()\n    IFS=\"${delimiter_280}\" read -rd '' -a result_281 < <(printf %s \"$text_279\")\n    __status=$?\n    ret_split29_v0=(\"${result_281[@]}\")\n    return 0\n}\n\njoin__32_v0() {\n    local list_276=(\"${!1}\")\n    local delimiter_277=\"${2}\"\n    local command_6\n    command_6=\"$(IFS=\"${delimiter_277}\" ; printf \"%s\n\" \"${list_276[*]}\")\"\n    __status=$?\n    ret_join32_v0=\"${command_6}\"\n    return 0\n}\n\ntrim__35_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    __status=$?\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim35_v0=\"${result_15}\"\n    return 0\n}\n\nis_mac_os_mktemp__72_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp72_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp72_v0=0\n    return 0\n}\n\ntemp_dir_create__73_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__35_v0 \"${template_11}\"\n    local ret_trim35_v0__113_8=\"${ret_trim35_v0}\"\n    if [ \"$([ \"_${ret_trim35_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__72_v0 \n    local ret_is_mac_os_mktemp72_v0__119_8=\"${ret_is_mac_os_mktemp72_v0}\"\n    if [ \"${ret_is_mac_os_mktemp72_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_7\n        command_7=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_7}\"\n    else\n        local command_8\n        command_8=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_8}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create73_v0=\"${filename_16}\"\n    return 0\n}\n\nescape_non_glob_chars__76_v0() {\n    local path_261=\"${1}\"\n    replace_regex__28_v0 \"${path_261}\" \"\\\\([^*?/]\\\\)\" \"\\\\\\\\\\\\1\" 0\n    ret_escape_non_glob_chars76_v0=\"${ret_replace_regex28_v0}\"\n    return 0\n}\n\nfile_glob_all__77_v0() {\n    local paths_259=(\"${!1}\")\n    local combined_260=\"\"\n    local __length_9=(\"${paths_259[@]}\")\n    if [ \"$(( ${#__length_9[@]} == 1 ))\" != 0 ]; then\n        escape_non_glob_chars__76_v0 \"${paths_259[0]}\"\n        combined_260=\"${ret_escape_non_glob_chars76_v0}\"\n    else\n        local items_274=()\n        for item_275 in \"${paths_259[@]}\"; do\n            escape_non_glob_chars__76_v0 \"${item_275}\"\n            item_275=\"${ret_escape_non_glob_chars76_v0}\"\n            items_274+=(\"${item_275}\")\n        done\n        join__32_v0 items_274[@] \" \"\n        combined_260=\"${ret_join32_v0}\"\n    fi\n    local command_12\n    command_12=\"$(eval \"for file in ${combined_260}; do [ -e \\\"\\$file\\\" ] && printf \\\"%s\\n\\\" \\\"\\$file\\\"; done\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob_all77_v0=()\n        return \"${__status}\"\n    fi\n    local files_278=\"${command_12}\"\n    split__29_v0 \"${files_278}\" \"\n\"\n    ret_file_glob_all77_v0=(\"${ret_split29_v0[@]}\")\n    return 0\n}\n\nfile_glob__78_v0() {\n    local path_258=\"${1}\"\n    local array_13=(\"${path_258}\")\n    file_glob_all__77_v0 array_13[@]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob78_v0=()\n        return \"${__status}\"\n    fi\n    ret_file_glob78_v0=(\"${ret_file_glob_all77_v0[@]}\")\n    return 0\n}\n\ncompare__129_v0() {\n    local actual_304=(\"${!1}\")\n    local expected_305=(\"${!2}\")\n    local __length_14=(\"${actual_304[@]}\")\n    local __length_15=(\"${expected_305[@]}\")\n    if [ \"$(( ${#__length_14[@]} != ${#__length_15[@]} ))\" != 0 ]; then\n        ret_compare129_v0=0\n        return 0\n    fi\n    for file_306 in \"${expected_305[@]}\"; do\n        array_contains__2_v0 actual_304[@] \"${file_306}\"\n        local ret_array_contains2_v0__10_16=\"${ret_array_contains2_v0}\"\n        if [ \"$(( ! ret_array_contains2_v0__10_16 ))\" != 0 ]; then\n            ret_compare129_v0=0\n            return 0\n        fi\n    done\n    ret_compare129_v0=1\n    return 0\n}\n\ntemp_dir_create__73_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create73_v0}\"\ntouch \"${tmpdir_17}/1st file with spaces.txt\"\ntouch \"${tmpdir_17}/2nd file with spaces.txt\"\ntouch \"${tmpdir_17}/file.txt\"\ntouch \"${tmpdir_17}/file1.txt\"\ntouch \"${tmpdir_17}/file2.txt\"\ntouch \"${tmpdir_17}/file99.txt\"\ntouch \"${tmpdir_17}/other.csv\"\nexpected_18=(\"${tmpdir_17}/file1.txt\" \"${tmpdir_17}/file2.txt\")\nfile_glob__78_v0 \"${tmpdir_17}/file?.txt\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"FAILED\"\nfi\nactual_282=(\"${ret_file_glob78_v0[@]}\")\ncompare__129_v0 actual_282[@] expected_18[@]\nret_compare129_v0__36_8=\"${ret_compare129_v0}\"\nif [ \"${ret_compare129_v0__36_8}\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Expected: ${expected_18[*]}\"\n    echo \"Actual: ${actual_282[*]}\"\nfi", "output": "import * from \"std/array\"\nimport * from \"std/fs\"\nimport * from \"std/text\"\n\nfun compare(actual: [Text], expected: [Text]): Bool {\n    if len(actual) != len(expected) {\n        return false\n    }\n    for file in expected {\n        if not array_contains(actual, file) {\n            return false\n        }\n    }\n    return true\n}\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    trust {\n        touch(\"{tmpdir}/1st file with spaces.txt\")\n        touch(\"{tmpdir}/2nd file with spaces.txt\")\n        touch(\"{tmpdir}/file.txt\")\n        touch(\"{tmpdir}/file1.txt\")\n        touch(\"{tmpdir}/file2.txt\")\n        touch(\"{tmpdir}/file99.txt\")\n        touch(\"{tmpdir}/other.csv\")\n    }\n\n    const expected = [\n        \"{tmpdir}/file1.txt\",\n        \"{tmpdir}/file2.txt\",\n    ]\n    const actual = file_glob(\"{tmpdir}/file?.txt\") failed {\n        echo(\"FAILED\")\n    }\n    if compare(actual, expected) {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Expected: {expected}\")\n        echo(\"Actual: {actual}\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nprintf__131_v0() {\n    local format_9=\"${1}\"\n    local args_10=(\"${!2}\")\n    args_10=(\"${format_9}\" \"${args_10[@]}\")\n    printf \"${args_10[@]}\"\n}\n\necho_success__139_v0() {\n    local message_8=\"${1}\"\n    local array_0=(\"${message_8}\")\n    printf__131_v0 \"\\\\x1b[1;3;97;42m%s\\\\x1b[0m\n\" array_0[@]\n}\n\n# Output\n# \u001b[1;3;97;42mHello Amber!\u001b[0m\necho_success__139_v0 \"Hello Amber\"'!'\"\"", "output": "import * from \"std/env\"\n\n// Output\n// \u001b[1;3;97;42mHello Amber!\u001b[0m\n\nmain {\n    echo_success(\"Hello Amber!\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nsplit__5_v0() {\n    local text_11=\"${1}\"\n    local delimiter_12=\"${2}\"\n    local result_13=()\n    IFS=\"${delimiter_12}\" read -rd '' -a result_13 < <(printf %s \"$text_11\")\n    ret_split5_v0=(\"${result_13[@]}\")\n    return 0\n}\n\nsplit_lines__6_v0() {\n    local text_10=\"${1}\"\n    split__5_v0 \"${text_10}\" \"\n\"\n    ret_split_lines6_v0=(\"${ret_split5_v0[@]}\")\n    return 0\n}\n\n# Output\n# line: hello\n# line: world\nsplit_lines__6_v0 \"hello\nworld\"\nret_split_lines6_v0__8_17=(\"${ret_split_lines6_v0[@]}\")\nfor line_14 in \"${ret_split_lines6_v0__8_17[@]}\"; do\n    echo \"line: \"\"${line_14}\"\ndone", "output": "import { split_lines } from \"std/text\"\n\n// Output\n// line: hello\n// line: world\n\nmain {\n    for line in split_lines(\"hello\\nworld\") {\n        echo(\"line: \" + line)\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_309=(\"${!1}\")\n    local value_310=\"${2}\"\n    index_312=0;\n    for element_311 in \"${array_309[@]}\"; do\n        if [ \"$([ \"_${value_310}\" != \"_${element_311}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_312}\"\n            return 0\n        fi\n        (( index_312++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_307=(\"${!1}\")\n    local value_308=\"${2}\"\n    array_find__0_v0 array_307[@] \"${value_308}\"\n    local result_313=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_313 >= 0 ))\"\n    return 0\n}\n\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__24_v0() {\n    local major_271=0\n    local minor_272=0\n    local patch_273=0\n    major_271=${BASH_VERSINFO[0]}\n        minor_272=${BASH_VERSINFO[1]}\n        patch_273=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version24_v0=(\"${major_271}\" \"${minor_272}\" \"${patch_273}\")\n    return 0\n}\n\nreplace__25_v0() {\n    local source_267=\"${1}\"\n    local search_268=\"${2}\"\n    local replace_269=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_270=\"\"\n    bash_version__24_v0 \n    left_comp=(\"${ret_bash_version24_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_270=\"${source_267//\"${search_268}\"/\"${replace_269}\"}\"\n        __status=$?\n    else\n        result_270=\"${source_267//\"${search_268}\"/${replace_269}}\"\n        __status=$?\n    fi\n    ret_replace25_v0=\"${result_270}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__27_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version27_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nreplace_regex__28_v0() {\n    local source_262=\"${1}\"\n    local search_263=\"${2}\"\n    local replace_text_264=\"${3}\"\n    local extended_265=\"${4}\"\n    sed_version__27_v0 \n    local sed_version_266=\"${ret_sed_version27_v0}\"\n    replace__25_v0 \"${search_263}\" \"/\" \"\\\\/\"\n    search_263=\"${ret_replace25_v0}\"\n    replace__25_v0 \"${replace_text_264}\" \"/\" \"\\\\/\"\n    replace_text_264=\"${ret_replace25_v0}\"\n    if [ \"$(( $(( sed_version_266 == __SED_VERSION_GNU_1 )) || $(( sed_version_266 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__25_v0 \"${search_263}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_263=\"${ret_replace25_v0}\"\n    fi\n    if [ \"${extended_265}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_266 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            local command_2\n            command_2=\"$(sed -r -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_2}\"\n            return 0\n        else\n            local command_3\n            command_3=\"$(sed -E -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_3}\"\n            return 0\n        fi\n    else\n        if [ \"$(( $(( sed_version_266 == __SED_VERSION_GNU_1 )) || $(( sed_version_266 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__25_v0 \"${search_263}\" \"\\\\|\" \"|\"\n            search_263=\"${ret_replace25_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n        __status=$?\n        ret_replace_regex28_v0=\"${command_4}\"\n        return 0\n    fi\n}\n\nsplit__29_v0() {\n    local text_279=\"${1}\"\n    local delimiter_280=\"${2}\"\n    local result_281=()\n    IFS=\"${delimiter_280}\" read -rd '' -a result_281 < <(printf %s \"$text_279\")\n    __status=$?\n    ret_split29_v0=(\"${result_281[@]}\")\n    return 0\n}\n\njoin__32_v0() {\n    local list_276=(\"${!1}\")\n    local delimiter_277=\"${2}\"\n    local command_6\n    command_6=\"$(IFS=\"${delimiter_277}\" ; printf \"%s\n\" \"${list_276[*]}\")\"\n    __status=$?\n    ret_join32_v0=\"${command_6}\"\n    return 0\n}\n\ntrim__35_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    __status=$?\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim35_v0=\"${result_15}\"\n    return 0\n}\n\nis_mac_os_mktemp__72_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp72_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp72_v0=0\n    return 0\n}\n\ntemp_dir_create__73_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__35_v0 \"${template_11}\"\n    local ret_trim35_v0__113_8=\"${ret_trim35_v0}\"\n    if [ \"$([ \"_${ret_trim35_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__72_v0 \n    local ret_is_mac_os_mktemp72_v0__119_8=\"${ret_is_mac_os_mktemp72_v0}\"\n    if [ \"${ret_is_mac_os_mktemp72_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_7\n        command_7=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_7}\"\n    else\n        local command_8\n        command_8=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_8}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create73_v0=\"${filename_16}\"\n    return 0\n}\n\nescape_non_glob_chars__76_v0() {\n    local path_261=\"${1}\"\n    replace_regex__28_v0 \"${path_261}\" \"\\\\([^*?/]\\\\)\" \"\\\\\\\\\\\\1\" 0\n    ret_escape_non_glob_chars76_v0=\"${ret_replace_regex28_v0}\"\n    return 0\n}\n\nfile_glob_all__77_v0() {\n    local paths_259=(\"${!1}\")\n    local combined_260=\"\"\n    local __length_9=(\"${paths_259[@]}\")\n    if [ \"$(( ${#__length_9[@]} == 1 ))\" != 0 ]; then\n        escape_non_glob_chars__76_v0 \"${paths_259[0]}\"\n        combined_260=\"${ret_escape_non_glob_chars76_v0}\"\n    else\n        local items_274=()\n        for item_275 in \"${paths_259[@]}\"; do\n            escape_non_glob_chars__76_v0 \"${item_275}\"\n            item_275=\"${ret_escape_non_glob_chars76_v0}\"\n            items_274+=(\"${item_275}\")\n        done\n        join__32_v0 items_274[@] \" \"\n        combined_260=\"${ret_join32_v0}\"\n    fi\n    local command_12\n    command_12=\"$(eval \"for file in ${combined_260}; do [ -e \\\"\\$file\\\" ] && printf \\\"%s\\n\\\" \\\"\\$file\\\"; done\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob_all77_v0=()\n        return \"${__status}\"\n    fi\n    local files_278=\"${command_12}\"\n    split__29_v0 \"${files_278}\" \"\n\"\n    ret_file_glob_all77_v0=(\"${ret_split29_v0[@]}\")\n    return 0\n}\n\nfile_glob__78_v0() {\n    local path_258=\"${1}\"\n    local array_13=(\"${path_258}\")\n    file_glob_all__77_v0 array_13[@]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob78_v0=()\n        return \"${__status}\"\n    fi\n    ret_file_glob78_v0=(\"${ret_file_glob_all77_v0[@]}\")\n    return 0\n}\n\ncompare__129_v0() {\n    local actual_304=(\"${!1}\")\n    local expected_305=(\"${!2}\")\n    local __length_14=(\"${actual_304[@]}\")\n    local __length_15=(\"${expected_305[@]}\")\n    if [ \"$(( ${#__length_14[@]} != ${#__length_15[@]} ))\" != 0 ]; then\n        ret_compare129_v0=0\n        return 0\n    fi\n    for file_306 in \"${expected_305[@]}\"; do\n        array_contains__2_v0 actual_304[@] \"${file_306}\"\n        local ret_array_contains2_v0__10_16=\"${ret_array_contains2_v0}\"\n        if [ \"$(( ! ret_array_contains2_v0__10_16 ))\" != 0 ]; then\n            ret_compare129_v0=0\n            return 0\n        fi\n    done\n    ret_compare129_v0=1\n    return 0\n}\n\ntemp_dir_create__73_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create73_v0}\"\ntouch \"${tmpdir_17}/1st file with spaces.txt\"\ntouch \"${tmpdir_17}/2nd file with spaces.txt\"\ntouch \"${tmpdir_17}/file.txt\"\ntouch \"${tmpdir_17}/file1.txt\"\ntouch \"${tmpdir_17}/file2.txt\"\ntouch \"${tmpdir_17}/file99.txt\"\ntouch \"${tmpdir_17}/other.csv\"\ncd \"${tmpdir_17}\" || exit\nexpected_18=(\"file.txt\" \"file1.txt\" \"file2.txt\" \"file99.txt\")\nfile_glob__78_v0 \"file*.txt\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"FAILED\"\nfi\nactual_282=(\"${ret_file_glob78_v0[@]}\")\ncompare__129_v0 actual_282[@] expected_18[@]\nret_compare129_v0__39_8=\"${ret_compare129_v0}\"\nif [ \"${ret_compare129_v0__39_8}\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Expected: ${expected_18[*]}\"\n    echo \"Actual: ${actual_282[*]}\"\nfi", "output": "import * from \"std/array\"\nimport * from \"std/fs\"\nimport * from \"std/text\"\n\nfun compare(actual: [Text], expected: [Text]): Bool {\n    if len(actual) != len(expected) {\n        return false\n    }\n    for file in expected {\n        if not array_contains(actual, file) {\n            return false\n        }\n    }\n    return true\n}\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    trust {\n        touch(\"{tmpdir}/1st file with spaces.txt\")\n        touch(\"{tmpdir}/2nd file with spaces.txt\")\n        touch(\"{tmpdir}/file.txt\")\n        touch(\"{tmpdir}/file1.txt\")\n        touch(\"{tmpdir}/file2.txt\")\n        touch(\"{tmpdir}/file99.txt\")\n        touch(\"{tmpdir}/other.csv\")\n    }\n    cd(tmpdir)\n\n    const expected = [\n        \"file.txt\",\n        \"file1.txt\",\n        \"file2.txt\",\n        \"file99.txt\",\n    ]\n    const actual = file_glob(\"file*.txt\") failed {\n        echo(\"FAILED\")\n    }\n    if compare(actual, expected) {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Expected: {expected}\")\n        echo(\"Actual: {actual}\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_filled__9_v0() {\n    local size_3=\"${1}\"\n    local value_4=\"${2}\"\n    local array_5=(\"${value_4}\")\n    # Used for type casting array\n    array_5=(\"${array_5[@]:0:0}\")\n    # Resetting the array size to 0\n    if [ \"$(( $(( size_3 <= 0 )) || $(( ! 1 )) ))\" != 0 ]; then\n        ret_array_filled9_v0=(\"${array_5[@]}\")\n        return 0\n    fi\n    local __range_start_6=0\n    local __range_end_6=\"${size_3}\"\n    local __dir_6=$(( ${__range_start_6} <= ${__range_end_6} ? 1 : -1 ))\n    for (( ____6=${__range_start_6}; ____6 * ${__dir_6} < ${__range_end_6} * ${__dir_6}; ____6+=${__dir_6} )); do\n        local array_1=(\"${value_4}\")\n        array_5+=(\"${array_1[@]}\")\ndone\n    ret_array_filled9_v0=(\"${array_5[@]}\")\n    return 0\n}\n\narray_filled__9_v0 0 1.0\narray_7=(\"${ret_array_filled9_v0[@]}\")\narray_3=()\nif [ \"$(\n    (( ${#array_7[@]} != ${#array_3[@]} )) && echo 0 && exit\n    for (( i=0; i<${#array_7[@]}; i++ )); do [[ \"${array_7[i]}\" != \"${array_3[i]}\" ]] && echo 0 && exit; done\n    echo 1\n)\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Failed\"\nfi", "output": "import { array_filled } from \"std/array\"\n\nmain {\n    const array = array_filled(0, 1.0)\n    if array == [Num]:\n        echo(\"Succeeded\")\n    else:\n        echo(\"Failed\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ndir_exists__41_v0() {\n    local path_7=\"${1}\"\n    [ -d \"${path_7}\" ]\n    __status=$?\n    ret_dir_exists41_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\ndir_create__47_v0() {\n    local path_6=\"${1}\"\n    dir_exists__41_v0 \"${path_6}\"\n    local ret_dir_exists41_v0__87_12=\"${ret_dir_exists41_v0}\"\n    if [ \"$(( ! ret_dir_exists41_v0__87_12 ))\" != 0 ]; then\n        mkdir -p \"${path_6}\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_dir_create47_v0=''\n            return \"${__status}\"\n        fi\n    fi\n}\n\ndir_create__47_v0 \"/tmp/amber-test\"\n__status=$?\nif [ \"${__status}\" = 0 ]; then\n    dir_exists__41_v0 \"/tmp/amber-test\"\n    ret_dir_exists41_v0__5_12=\"${ret_dir_exists41_v0}\"\n    if [ \"${ret_dir_exists41_v0__5_12}\" != 0 ]; then\n        rm -rf /tmp/amber-test\n        __status=$?\n        echo \"Succeeded\"\n    fi\nfi", "output": "import { dir_create, dir_exists } from \"std/fs\"\n\nmain {\n    dir_create(\"/tmp/amber-test\") succeeded {\n        if dir_exists(\"/tmp/amber-test\") {\n            trust $ rm -rf /tmp/amber-test $\n            echo(\"Succeeded\")\n        }\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nfile_exists__42_v0() {\n    local path_30=\"${1}\"\n    [ -f \"${path_30}\" ]\n    __status=$?\n    ret_file_exists42_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nfile_write__44_v0() {\n    local path_20=\"${1}\"\n    local content_21=\"${2}\"\n    local command_0\n    command_0=\"$(printf '%s\n' \"${content_21}\" > \"${path_20}\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_write44_v0=''\n        return \"${__status}\"\n    fi\n    ret_file_write44_v0=\"${command_0}\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_1\n        command_1=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_1}\"\n    else\n        local command_2\n        command_2=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_2}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\nenv_var_load__118_v0() {\n    local var_27=\"${1}\"\n    local file_28=\"${2}\"\n    local command_3\n    command_3=\"$(printf \"%s\n\" \"${!var_27}\")\"\n    __status=$?\n    local _var_29=\"${command_3}\"\n    if [ \"$([ \"_${_var_29}\" == \"_\" ]; echo $?)\" != 0 ]; then\n        ret_env_var_load118_v0=\"${_var_29}\"\n        return 0\n    fi\n    file_exists__42_v0 \"${file_28}\"\n    local ret_file_exists42_v0__17_8=\"${ret_file_exists42_v0}\"\n    if [ \"${ret_file_exists42_v0__17_8}\" != 0 ]; then\n        source \"${file_28}\"\n        __status=$?\n        local command_4\n        command_4=\"$(printf \"%s\n\" \"${!var_27}\")\"\n        __status=$?\n        ret_env_var_load118_v0=\"${command_4}\"\n        return 0\n    fi\n    ret_env_var_load118_v0=\"\"\n    return 0\n}\n\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ncd \"${tmpdir_17}\" || exit\nfile_write__44_v0 \".env\" \"TEST=1\"\n__status=$?\nenv_var_load__118_v0 \"TEST\" \".env\"\nret_env_var_load118_v0__8_8=\"${ret_env_var_load118_v0}\"\nif [ \"$([ \"_${ret_env_var_load118_v0__8_8}\" != \"_1\" ]; echo $?)\" != 0 ]; then\n    echo \"Succeeded\"\nfi", "output": "import { env_var_load } from \"std/env\"\nimport { file_write, temp_dir_create } from \"std/fs\"\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    cd(tmpdir)\n    trust file_write(\".env\", \"TEST=1\")\n    if env_var_load(\"TEST\") == \"1\" {\n        echo(\"Succeeded\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_229=(\"${!1}\")\n    local value_230=\"${2}\"\n    index_232=0;\n    for element_231 in \"${array_229[@]}\"; do\n        if [ \"$([ \"_${value_230}\" != \"_${element_231}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_232}\"\n            return 0\n        fi\n        (( index_232++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_227=(\"${!1}\")\n    local value_228=\"${2}\"\n    array_find__0_v0 array_227[@] \"${value_228}\"\n    local result_233=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_233 >= 0 ))\"\n    return 0\n}\n\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__24_v0() {\n    local major_191=0\n    local minor_192=0\n    local patch_193=0\n    major_191=${BASH_VERSINFO[0]}\n        minor_192=${BASH_VERSINFO[1]}\n        patch_193=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version24_v0=(\"${major_191}\" \"${minor_192}\" \"${patch_193}\")\n    return 0\n}\n\nreplace__25_v0() {\n    local source_187=\"${1}\"\n    local search_188=\"${2}\"\n    local replace_189=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_190=\"\"\n    bash_version__24_v0 \n    left_comp=(\"${ret_bash_version24_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_190=\"${source_187//\"${search_188}\"/\"${replace_189}\"}\"\n        __status=$?\n    else\n        result_190=\"${source_187//\"${search_188}\"/${replace_189}}\"\n        __status=$?\n    fi\n    ret_replace25_v0=\"${result_190}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__27_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version27_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nreplace_regex__28_v0() {\n    local source_182=\"${1}\"\n    local search_183=\"${2}\"\n    local replace_text_184=\"${3}\"\n    local extended_185=\"${4}\"\n    sed_version__27_v0 \n    local sed_version_186=\"${ret_sed_version27_v0}\"\n    replace__25_v0 \"${search_183}\" \"/\" \"\\\\/\"\n    search_183=\"${ret_replace25_v0}\"\n    replace__25_v0 \"${replace_text_184}\" \"/\" \"\\\\/\"\n    replace_text_184=\"${ret_replace25_v0}\"\n    if [ \"$(( $(( sed_version_186 == __SED_VERSION_GNU_1 )) || $(( sed_version_186 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__25_v0 \"${search_183}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_183=\"${ret_replace25_v0}\"\n    fi\n    if [ \"${extended_185}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_186 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            local command_2\n            command_2=\"$(sed -r -e \"s/${search_183}/${replace_text_184}/g\" <<<\"${source_182}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_2}\"\n            return 0\n        else\n            local command_3\n            command_3=\"$(sed -E -e \"s/${search_183}/${replace_text_184}/g\" <<<\"${source_182}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_3}\"\n            return 0\n        fi\n    else\n        if [ \"$(( $(( sed_version_186 == __SED_VERSION_GNU_1 )) || $(( sed_version_186 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__25_v0 \"${search_183}\" \"\\\\|\" \"|\"\n            search_183=\"${ret_replace25_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -e \"s/${search_183}/${replace_text_184}/g\" <<<\"${source_182}\")\"\n        __status=$?\n        ret_replace_regex28_v0=\"${command_4}\"\n        return 0\n    fi\n}\n\nsplit__29_v0() {\n    local text_199=\"${1}\"\n    local delimiter_200=\"${2}\"\n    local result_201=()\n    IFS=\"${delimiter_200}\" read -rd '' -a result_201 < <(printf %s \"$text_199\")\n    __status=$?\n    ret_split29_v0=(\"${result_201[@]}\")\n    return 0\n}\n\njoin__32_v0() {\n    local list_196=(\"${!1}\")\n    local delimiter_197=\"${2}\"\n    local command_6\n    command_6=\"$(IFS=\"${delimiter_197}\" ; printf \"%s\n\" \"${list_196[*]}\")\"\n    __status=$?\n    ret_join32_v0=\"${command_6}\"\n    return 0\n}\n\ntrim__35_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    __status=$?\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim35_v0=\"${result_15}\"\n    return 0\n}\n\nis_mac_os_mktemp__72_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp72_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp72_v0=0\n    return 0\n}\n\ntemp_dir_create__73_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__35_v0 \"${template_11}\"\n    local ret_trim35_v0__113_8=\"${ret_trim35_v0}\"\n    if [ \"$([ \"_${ret_trim35_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__72_v0 \n    local ret_is_mac_os_mktemp72_v0__119_8=\"${ret_is_mac_os_mktemp72_v0}\"\n    if [ \"${ret_is_mac_os_mktemp72_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_7\n        command_7=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_7}\"\n    else\n        local command_8\n        command_8=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_8}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create73_v0=\"${filename_16}\"\n    return 0\n}\n\nescape_non_glob_chars__76_v0() {\n    local path_181=\"${1}\"\n    replace_regex__28_v0 \"${path_181}\" \"\\\\([^*?/]\\\\)\" \"\\\\\\\\\\\\1\" 0\n    ret_escape_non_glob_chars76_v0=\"${ret_replace_regex28_v0}\"\n    return 0\n}\n\nfile_glob_all__77_v0() {\n    local paths_179=(\"${!1}\")\n    local combined_180=\"\"\n    local __length_9=(\"${paths_179[@]}\")\n    if [ \"$(( ${#__length_9[@]} == 1 ))\" != 0 ]; then\n        escape_non_glob_chars__76_v0 \"${paths_179[0]}\"\n        combined_180=\"${ret_escape_non_glob_chars76_v0}\"\n    else\n        local items_194=()\n        for item_195 in \"${paths_179[@]}\"; do\n            escape_non_glob_chars__76_v0 \"${item_195}\"\n            item_195=\"${ret_escape_non_glob_chars76_v0}\"\n            items_194+=(\"${item_195}\")\n        done\n        join__32_v0 items_194[@] \" \"\n        combined_180=\"${ret_join32_v0}\"\n    fi\n    local command_12\n    command_12=\"$(eval \"for file in ${combined_180}; do [ -e \\\"\\$file\\\" ] && printf \\\"%s\\n\\\" \\\"\\$file\\\"; done\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob_all77_v0=()\n        return \"${__status}\"\n    fi\n    local files_198=\"${command_12}\"\n    split__29_v0 \"${files_198}\" \"\n\"\n    ret_file_glob_all77_v0=(\"${ret_split29_v0[@]}\")\n    return 0\n}\n\ncompare__129_v0() {\n    local actual_224=(\"${!1}\")\n    local expected_225=(\"${!2}\")\n    local __length_13=(\"${actual_224[@]}\")\n    local __length_14=(\"${expected_225[@]}\")\n    if [ \"$(( ${#__length_13[@]} != ${#__length_14[@]} ))\" != 0 ]; then\n        ret_compare129_v0=0\n        return 0\n    fi\n    for file_226 in \"${expected_225[@]}\"; do\n        array_contains__2_v0 actual_224[@] \"${file_226}\"\n        local ret_array_contains2_v0__10_16=\"${ret_array_contains2_v0}\"\n        if [ \"$(( ! ret_array_contains2_v0__10_16 ))\" != 0 ]; then\n            ret_compare129_v0=0\n            return 0\n        fi\n    done\n    ret_compare129_v0=1\n    return 0\n}\n\ntemp_dir_create__73_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create73_v0}\"\ntouch \"${tmpdir_17}/1st file with spaces.txt\"\ntouch \"${tmpdir_17}/2nd file with spaces.txt\"\ntouch \"${tmpdir_17}/file.txt\"\ntouch \"${tmpdir_17}/file1.txt\"\ntouch \"${tmpdir_17}/file2.txt\"\ntouch \"${tmpdir_17}/file99.txt\"\ntouch \"${tmpdir_17}/other.csv\"\nexpected_18=(\"${tmpdir_17}/file.txt\" \"${tmpdir_17}/file1.txt\" \"${tmpdir_17}/file2.txt\" \"${tmpdir_17}/file99.txt\" \"${tmpdir_17}/other.csv\")\narray_17=(\"${tmpdir_17}/missing*\" \"${tmpdir_17}/file*.txt\" \"${tmpdir_17}/other*.csv\")\nfile_glob_all__77_v0 array_17[@]\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"FAILED\"\nfi\nactual_202=(\"${ret_file_glob_all77_v0[@]}\")\ncompare__129_v0 actual_202[@] expected_18[@]\nret_compare129_v0__39_8=\"${ret_compare129_v0}\"\nif [ \"${ret_compare129_v0__39_8}\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Expected: ${expected_18[*]}\"\n    echo \"Actual: ${actual_202[*]}\"\nfi", "output": "import * from \"std/array\"\nimport * from \"std/fs\"\nimport * from \"std/text\"\n\nfun compare(actual: [Text], expected: [Text]): Bool {\n    if len(actual) != len(expected) {\n        return false\n    }\n    for file in expected {\n        if not array_contains(actual, file) {\n            return false\n        }\n    }\n    return true\n}\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    trust {\n        touch(\"{tmpdir}/1st file with spaces.txt\")\n        touch(\"{tmpdir}/2nd file with spaces.txt\")\n        touch(\"{tmpdir}/file.txt\")\n        touch(\"{tmpdir}/file1.txt\")\n        touch(\"{tmpdir}/file2.txt\")\n        touch(\"{tmpdir}/file99.txt\")\n        touch(\"{tmpdir}/other.csv\")\n    }\n\n    const expected = [\n        \"{tmpdir}/file.txt\",\n        \"{tmpdir}/file1.txt\",\n        \"{tmpdir}/file2.txt\",\n        \"{tmpdir}/file99.txt\",\n        \"{tmpdir}/other.csv\",\n    ]\n    const actual = file_glob_all([\"{tmpdir}/missing*\", \"{tmpdir}/file*.txt\", \"{tmpdir}/other*.csv\"]) failed {\n        echo(\"FAILED\")\n    }\n    if compare(actual, expected) {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Expected: {expected}\")\n        echo(\"Actual: {actual}\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_filled__9_v0() {\n    local size_11=\"${1}\"\n    local value_12=\"${2}\"\n    local array_13=(\"${value_12}\")\n    # Used for type casting array\n    array_13=(\"${array_13[@]:0:0}\")\n    # Resetting the array size to 0\n    if [ \"$(( $(( size_11 <= 0 )) || $(( ! 1 )) ))\" != 0 ]; then\n        ret_array_filled9_v0=(\"${array_13[@]}\")\n        return 0\n    fi\n    local __range_start_14=0\n    local __range_end_14=\"${size_11}\"\n    local __dir_14=$(( ${__range_start_14} <= ${__range_end_14} ? 1 : -1 ))\n    for (( ____14=${__range_start_14}; ____14 * ${__dir_14} < ${__range_end_14} * ${__dir_14}; ____14+=${__dir_14} )); do\n        local array_1=(\"${value_12}\")\n        array_13+=(\"${array_1[@]}\")\ndone\n    ret_array_filled9_v0=(\"${array_13[@]}\")\n    return 0\n}\n\n# Output\n# Array length for size=-1: 0\n# Array length for size=0: 0\n# Array length for size=1: 1\n# Array length for size=2: 2\n# Array length for size=3: 3\ntest_size__13_v0() {\n    local size_10=\"${1}\"\n    array_filled__9_v0 \"${size_10}\" 0\n    local array_15=(\"${ret_array_filled9_v0[@]}\")\n    local __length_2=(\"${array_15[@]}\")\n    echo \"Array length for size=${size_10}: ${#__length_2[*]}\"\n}\n\nfor (( i_0=-1; i_0 <= 3; i_0++ )); do\n    test_size__13_v0 \"${i_0}\"\ndone", "output": "import { array_filled } from \"std/array\"\n\n// Output\n// Array length for size=-1: 0\n// Array length for size=0: 0\n// Array length for size=1: 1 \n// Array length for size=2: 2 \n// Array length for size=3: 3\n\nfun test_size(size: Int): Null {\n    const array = array_filled(size, 0)\n    echo(\"Array length for size={size}: {len(array)}\")\n}\n\nmain {\n    for i in -1..=3 {\n        test_size(i)\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nenv_const_set__121_v0() {\n    local name_5=\"${1}\"\n    local val_6=\"${2}\"\n    readonly $name_5=\"$val_6\" 2> /dev/null\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_env_const_set121_v0=''\n        return \"${__status}\"\n    fi\n}\n\nenv_const_set__121_v0 \"test_shell_constant_set\" \"Succe\"\n__status=$?\nstr_7=\"\"\ncommand_1=\"$(echo \"$test_shell_constant_set\")\"\n__status=$?\nstr_7+=\"${command_1}\"\nenv_const_set__121_v0 \"test_shell_constant_set\" \"Succe\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    str_7+=\"eded\"\nfi\nprintf '%s\\n' \"${str_7}\"", "output": "import * from \"std/env\"\n\nmain {\n    trust env_const_set(\"test_shell_constant_set\", \"Succe\")\n    let str = \"\"\n    str += trust $ echo \"\\$test_shell_constant_set\" $\n    env_const_set(\"test_shell_constant_set\", \"Succe\") failed {\n        str += \"eded\"\n    }\n    echo(str)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntext_contains__17_v0() {\n    local source_25=\"${1}\"\n    local search_26=\"${2}\"\n    [[ \"${source_25}\" == *\"${search_26}\"* ]]\n    __status=$?\n    ret_text_contains17_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\ntext_contains_any__18_v0() {\n    local source_22=\"${1}\"\n    local searches_23=(\"${!2}\")\n    for search_24 in \"${searches_23[@]}\"; do\n        text_contains__17_v0 \"${source_22}\" \"${search_24}\"\n        local ret_text_contains17_v0__283_12=\"${ret_text_contains17_v0}\"\n        if [ \"${ret_text_contains17_v0__283_12}\" != 0 ]; then\n            ret_text_contains_any18_v0=1\n            return 0\n        fi\n    done\n    ret_text_contains_any18_v0=0\n    return 0\n}\n\n# Output\n# Empty: 0\n# None: 0\n# Left: 1\n# Right: 1\n# Both: 1\ntest_multiple__37_v0() {\n    local label_19=\"${1}\"\n    local text_20=\"${2}\"\n    local terms_21=(\"${!3}\")\n    text_contains_any__18_v0 \"${text_20}\" terms_21[@]\n    local result_27=\"${ret_text_contains_any18_v0}\"\n    printf '%s\\n' \"${label_19}: ${result_27}\"\n}\n\narray_1=()\ntest_multiple__37_v0 \"Empty\" \"Hello World\" array_1[@]\narray_2=(\"Other\" \"Other\")\ntest_multiple__37_v0 \"None\" \"Hello World\" array_2[@]\narray_3=(\"Hello\" \"Other\")\ntest_multiple__37_v0 \"Left\" \"Hello World\" array_3[@]\narray_4=(\"Other\" \"World\")\ntest_multiple__37_v0 \"Right\" \"Hello World\" array_4[@]\narray_5=(\"Hello\" \"World\")\ntest_multiple__37_v0 \"Both\" \"Hello World\" array_5[@]", "output": "import { text_contains_any } from \"std/text\"\n\n// Output\n// Empty: 0\n// None: 0\n// Left: 1\n// Right: 1\n// Both: 1\n\nfun test_multiple(label, text, terms) {\n    const result = text_contains_any(text, terms)\n    echo(\"{label}: {result}\")\n}\n\nmain {\n    test_multiple(\"Empty\", \"Hello World\", [Text])\n    test_multiple(\"None\", \"Hello World\", [\"Other\", \"Other\"])\n    test_multiple(\"Left\", \"Hello World\", [\"Hello\", \"Other\"])\n    test_multiple(\"Right\", \"Hello World\", [\"Other\", \"World\"])\n    test_multiple(\"Both\", \"Hello World\", [\"Hello\", \"World\"])\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__0_v0() {\n    local major_270=0\n    local minor_271=0\n    local patch_272=0\n    major_270=${BASH_VERSINFO[0]}\n        minor_271=${BASH_VERSINFO[1]}\n        patch_272=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version0_v0=(\"${major_270}\" \"${minor_271}\" \"${patch_272}\")\n    return 0\n}\n\nreplace__1_v0() {\n    local source_266=\"${1}\"\n    local search_267=\"${2}\"\n    local replace_268=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_269=\"\"\n    bash_version__0_v0 \n    left_comp=(\"${ret_bash_version0_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_269=\"${source_266//\"${search_267}\"/\"${replace_268}\"}\"\n        __status=$?\n    else\n        result_269=\"${source_266//\"${search_267}\"/${replace_268}}\"\n        __status=$?\n    fi\n    ret_replace1_v0=\"${result_269}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__3_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version3_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nreplace_regex__4_v0() {\n    local source_261=\"${1}\"\n    local search_262=\"${2}\"\n    local replace_text_263=\"${3}\"\n    local extended_264=\"${4}\"\n    sed_version__3_v0 \n    local sed_version_265=\"${ret_sed_version3_v0}\"\n    replace__1_v0 \"${search_262}\" \"/\" \"\\\\/\"\n    search_262=\"${ret_replace1_v0}\"\n    replace__1_v0 \"${replace_text_263}\" \"/\" \"\\\\/\"\n    replace_text_263=\"${ret_replace1_v0}\"\n    if [ \"$(( $(( sed_version_265 == __SED_VERSION_GNU_1 )) || $(( sed_version_265 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__1_v0 \"${search_262}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_262=\"${ret_replace1_v0}\"\n    fi\n    if [ \"${extended_264}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_265 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            local command_2\n            command_2=\"$(sed -r -e \"s/${search_262}/${replace_text_263}/g\" <<<\"${source_261}\")\"\n            __status=$?\n            ret_replace_regex4_v0=\"${command_2}\"\n            return 0\n        else\n            local command_3\n            command_3=\"$(sed -E -e \"s/${search_262}/${replace_text_263}/g\" <<<\"${source_261}\")\"\n            __status=$?\n            ret_replace_regex4_v0=\"${command_3}\"\n            return 0\n        fi\n    else\n        if [ \"$(( $(( sed_version_265 == __SED_VERSION_GNU_1 )) || $(( sed_version_265 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__1_v0 \"${search_262}\" \"\\\\|\" \"|\"\n            search_262=\"${ret_replace1_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -e \"s/${search_262}/${replace_text_263}/g\" <<<\"${source_261}\")\"\n        __status=$?\n        ret_replace_regex4_v0=\"${command_4}\"\n        return 0\n    fi\n}\n\nsplit__5_v0() {\n    local text_278=\"${1}\"\n    local delimiter_279=\"${2}\"\n    local result_280=()\n    IFS=\"${delimiter_279}\" read -rd '' -a result_280 < <(printf %s \"$text_278\")\n    __status=$?\n    ret_split5_v0=(\"${result_280[@]}\")\n    return 0\n}\n\njoin__8_v0() {\n    local list_275=(\"${!1}\")\n    local delimiter_276=\"${2}\"\n    local command_6\n    command_6=\"$(IFS=\"${delimiter_276}\" ; printf \"%s\n\" \"${list_275[*]}\")\"\n    __status=$?\n    ret_join8_v0=\"${command_6}\"\n    return 0\n}\n\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    __status=$?\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_7\n        command_7=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_7}\"\n    else\n        local command_8\n        command_8=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_8}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\nescape_non_glob_chars__52_v0() {\n    local path_260=\"${1}\"\n    replace_regex__4_v0 \"${path_260}\" \"\\\\([^*?/]\\\\)\" \"\\\\\\\\\\\\1\" 0\n    ret_escape_non_glob_chars52_v0=\"${ret_replace_regex4_v0}\"\n    return 0\n}\n\nfile_glob_all__53_v0() {\n    local paths_258=(\"${!1}\")\n    local combined_259=\"\"\n    local __length_9=(\"${paths_258[@]}\")\n    if [ \"$(( ${#__length_9[@]} == 1 ))\" != 0 ]; then\n        escape_non_glob_chars__52_v0 \"${paths_258[0]}\"\n        combined_259=\"${ret_escape_non_glob_chars52_v0}\"\n    else\n        local items_273=()\n        for item_274 in \"${paths_258[@]}\"; do\n            escape_non_glob_chars__52_v0 \"${item_274}\"\n            item_274=\"${ret_escape_non_glob_chars52_v0}\"\n            items_273+=(\"${item_274}\")\n        done\n        join__8_v0 items_273[@] \" \"\n        combined_259=\"${ret_join8_v0}\"\n    fi\n    local command_12\n    command_12=\"$(eval \"for file in ${combined_259}; do [ -e \\\"\\$file\\\" ] && printf \\\"%s\\n\\\" \\\"\\$file\\\"; done\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob_all53_v0=()\n        return \"${__status}\"\n    fi\n    local files_277=\"${command_12}\"\n    split__5_v0 \"${files_277}\" \"\n\"\n    ret_file_glob_all53_v0=(\"${ret_split5_v0[@]}\")\n    return 0\n}\n\nfile_glob__54_v0() {\n    local path_257=\"${1}\"\n    local array_13=(\"${path_257}\")\n    file_glob_all__53_v0 array_13[@]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob54_v0=()\n        return \"${__status}\"\n    fi\n    ret_file_glob54_v0=(\"${ret_file_glob_all53_v0[@]}\")\n    return 0\n}\n\n# Output\n# FAILED\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ntouch \"${tmpdir_17}/1st file with spaces.txt\"\ntouch \"${tmpdir_17}/2nd file with spaces.txt\"\ntouch \"${tmpdir_17}/file.txt\"\ntouch \"${tmpdir_17}/file1.txt\"\ntouch \"${tmpdir_17}/file2.txt\"\ntouch \"${tmpdir_17}/file99.txt\"\ntouch \"${tmpdir_17}/other.csv\"\ncd \"${tmpdir_17}\" || exit\nfile_glob__54_v0 \"missing*\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"FAILED\"\nfi\nfiles_281=(\"${ret_file_glob54_v0[@]}\")\nfor file_282 in \"${files_281[@]}\"; do\n    echo \"[${file_282}]\"\ndone", "output": "import * from \"std/fs\"\n\n// Output\n// FAILED\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    trust {\n        touch(\"{tmpdir}/1st file with spaces.txt\")\n        touch(\"{tmpdir}/2nd file with spaces.txt\")\n        touch(\"{tmpdir}/file.txt\")\n        touch(\"{tmpdir}/file1.txt\")\n        touch(\"{tmpdir}/file2.txt\")\n        touch(\"{tmpdir}/file99.txt\")\n        touch(\"{tmpdir}/other.csv\")\n    }\n    cd(tmpdir)\n\n    const files = file_glob(\"missing*\") failed {\n        echo(\"FAILED\")\n    }\n    for file in files {\n        echo(\"[{file}]\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nparse_int__14_v0() {\n    local text_4=\"${1}\"\n    [ -n \"${text_4}\" ] && [ \"${text_4}\" -eq \"${text_4}\" ] 2>/dev/null\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_parse_int14_v0=''\n        return \"${__status}\"\n    fi\n    ret_parse_int14_v0=\"${text_4}\"\n    return 0\n}\n\n# Output\n# 123\n# -12\n# 0\nparse_int__14_v0 \"123\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_parse_int14_v0__9_10=\"${ret_parse_int14_v0}\"\necho \"${ret_parse_int14_v0__9_10}\"\nparse_int__14_v0 \"-12\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_parse_int14_v0__10_10=\"${ret_parse_int14_v0}\"\necho \"${ret_parse_int14_v0__10_10}\"\nparse_int__14_v0 \"0\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_parse_int14_v0__11_10=\"${ret_parse_int14_v0}\"\necho \"${ret_parse_int14_v0__11_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// 123\n// -12\n// 0\n\nmain {\n    echo(parse_int(\"123\")?)\n    echo(parse_int(\"-12\")?)\n    echo(parse_int(\"0\")?)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nuniq_lines__35_v0() {\n    local text_5=\"${1}\"\n    local remove_all_6=\"${2}\"\n    if [ \"$(( ! remove_all_6 ))\" != 0 ]; then\n        ret_uniq_lines35_v0=\"$(uniq <<< \"${text_5}\")\"\n        return 0\n    else\n        ret_uniq_lines35_v0=\"$(awk '!seen[$0]++' <<< \"${text_5}\")\"\n        return 0\n    fi\n}\n\n# Output\n# foo\n# bar\n# baz\n# foo\n# bar\n# baz\nuniq_lines__35_v0 \"foo\nfoo\nbar\nbar\nbaz\" 0\nret_uniq_lines35_v0__12_10=\"${ret_uniq_lines35_v0}\"\nprintf '%s\\n' \"${ret_uniq_lines35_v0__12_10}\"\nuniq_lines__35_v0 \"foo\nbar\nfoo\nbaz\nbar\" 1\nret_uniq_lines35_v0__13_10=\"${ret_uniq_lines35_v0}\"\nprintf '%s\\n' \"${ret_uniq_lines35_v0__13_10}\"", "output": "import { uniq_lines } from \"std/text\"\n\n// Output\n// foo\n// bar\n// baz\n// foo\n// bar\n// baz\n\nmain {\n    echo(uniq_lines(\"foo\\nfoo\\nbar\\nbar\\nbaz\"))\n    echo(uniq_lines(\"foo\\nbar\\nfoo\\nbaz\\nbar\", true))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nsplit__5_v0() {\n    local text_27=\"${1}\"\n    local delimiter_28=\"${2}\"\n    local result_29=()\n    IFS=\"${delimiter_28}\" read -rd '' -a result_29 < <(printf %s \"$text_27\")\n    __status=$?\n    ret_split5_v0=(\"${result_29[@]}\")\n    return 0\n}\n\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    __status=$?\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nstarts_with__23_v0() {\n    local text_34=\"${1}\"\n    local prefix_35=\"${2}\"\n    [[ \"${text_34}\" == \"${prefix_35}\"* ]]\n    __status=$?\n    ret_starts_with23_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\ndir_exists__41_v0() {\n    local path_37=\"${1}\"\n    [ -d \"${path_37}\" ]\n    __status=$?\n    ret_dir_exists41_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_1\n        command_1=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_1}\"\n    else\n        local command_2\n        command_2=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_2}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\nfilename__73_v0() {\n    local path_26=\"${1}\"\n    split__5_v0 \"${path_26}\" \"/\"\n    local parts_30=(\"${ret_split5_v0[@]}\")\n    local __length_3=(\"${parts_30[@]}\")\n    ret_filename73_v0=\"${parts_30[$(( ${#__length_3[@]} - 1 ))]}\"\n    return 0\n}\n\ntemp_dir_create__49_v0 \"amber-XXXX\" 0 0\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\npath_17=\"${ret_temp_dir_create49_v0}\"\nfilename__73_v0 \"${path_17}\"\nfilename_31=\"${ret_filename73_v0}\"\nstarts_with__23_v0 \"${filename_31}\" \"amber-\"\nret_starts_with23_v0__13_13=\"${ret_starts_with23_v0}\"\n__length_5=\"${filename_31}\"\n__length_6=\"amber-XXXX\"\ndir_exists__41_v0 \"${path_17}\"\nret_dir_exists41_v0__19_9=\"${ret_dir_exists41_v0}\"\nif [ \"$(( ! ret_starts_with23_v0__13_13 ))\" != 0 ]; then\n    echo \"filename should start with \\\"amber-\\\", ${filename_31} given\"\nelif [ \"$(( ${#__length_5} != ${#__length_6} ))\" != 0 ]; then\n    __length_7=\"amber-XXXX\"\n    echo \"The length of filename should be ${#__length_7}. ${filename_31} given\"\nelif [ \"${ret_dir_exists41_v0__19_9}\" != 0 ]; then\n    echo \"Succeeded\"\nfi\nrmdir ${path_17}\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\n# It is hard to test auto delete functionality. Just creating here only.\ntemp_dir_create__49_v0 \"should-not-exist-after-test-ends-1-XXXX\" 1 0\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntemp_dir_create__49_v0 \"should-not-exist-after-test-ends-2-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nfile_containng_dir_38=\"${ret_temp_dir_create49_v0}\"\ntouch \"${file_containng_dir_38}/test.txt\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi", "output": "import * from \"std/fs\"\nimport {split, starts_with} from \"std/text\"\n\nfun filename(path: Text): Text {\n    const parts = split(path, \"/\")\n    return parts[len(parts) - 1]\n}\n\nmain {\n    const path = temp_dir_create(\"amber-XXXX\")?\n    const filename = filename(path)\n    if {\n        not starts_with(filename, \"amber-\") {\n            echo(\"filename should start with \\\"amber-\\\", {filename} given\")\n        }\n        len(filename) != len(\"amber-XXXX\") {\n            echo(\"The length of filename should be {len(\"amber-XXXX\")}. {filename} given\")\n        }\n        dir_exists(path) {\n            echo(\"Succeeded\")\n        }\n    }\n    $ rmdir {path} $?\n    // It is hard to test auto delete functionality. Just creating here only.\n    temp_dir_create(\"should-not-exist-after-test-ends-1-XXXX\", true)?\n    const file_containng_dir = temp_dir_create(\"should-not-exist-after-test-ends-2-XXXX\", true, true)?\n    $ touch \"{file_containng_dir}/test.txt\" $?\n\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nlowercase__12_v0() {\n    local text_28=\"${1}\"\n    local command_0\n    command_0=\"$(tr '[:upper:]' '[:lower:]' <<< \"${text_28}\")\"\n    __status=$?\n    ret_lowercase12_v0=\"${command_0}\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_1\n        command_1=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_1}\"\n    else\n        local command_2\n        command_2=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_2}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\ninput_confirm__128_v0() {\n    local prompt_25=\"${1}\"\n    local default_yes_26=\"${2}\"\n    local choice_default_27\n    choice_default_27=\"$(if [ \"${default_yes_26}\" != 0 ]; then echo \" [\\\\x1b[1mY/\\\\x1b[0mn]\"; else echo \" [y/\\\\x1b[1mN\\\\x1b[0m]\"; fi)\"\n    printf \"\\x1b[1m${prompt_25}\\x1b[0m${choice_default_27}\"\n    __status=$?\n    read -s -n 1 || read -s -n 1 < /dev/tty\n    __status=$?\n    printf \"\n\"\n    __status=$?\n    local command_3\n    command_3=\"$(printf '%s\n' $REPLY)\"\n    __status=$?\n    lowercase__12_v0 \"${command_3}\"\n    local result_29=\"${ret_lowercase12_v0}\"\n    ret_input_confirm128_v0=\"$(( $([ \"_${result_29}\" != \"_y\" ]; echo $?) || $(( $([ \"_${result_29}\" != \"_\" ]; echo $?) && default_yes_26 )) ))\"\n    return 0\n}\n\ntemp_dir_create__49_v0 \"amber-confirm-test-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ntest_file_18=\"${tmpdir_17}/test_confirm\"\necho \"Y\" > ${test_file_18}\n__status=$?\nexec 0< ${test_file_18}\n__status=$?\ninput_confirm__128_v0 \"Yes\" 0\nret_input_confirm128_v0__9_8=\"${ret_input_confirm128_v0}\"\nif [ \"${ret_input_confirm128_v0__9_8}\" != 0 ]; then\n    echo \"Confirm Yes\"\nfi\necho \"N\" > ${test_file_18}\n__status=$?\nexec 0< ${test_file_18}\n__status=$?\ninput_confirm__128_v0 \"No\" 0\nret_input_confirm128_v0__12_12=\"${ret_input_confirm128_v0}\"\nif [ \"$(( ! ret_input_confirm128_v0__12_12 ))\" != 0 ]; then\n    echo \"Confirm No\"\nfi\necho \"\" > ${test_file_18}\n__status=$?\nexec 0< ${test_file_18}\n__status=$?\ninput_confirm__128_v0 \"Default\" 1\nret_input_confirm128_v0__15_8=\"${ret_input_confirm128_v0}\"\nif [ \"${ret_input_confirm128_v0__15_8}\" != 0 ]; then\n    echo \"Confirm Default\"\nfi", "output": "import * from \"std/env\"\nimport { temp_dir_create } from \"std/fs\"\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-confirm-test-XXXX\", true, true)?\n    const test_file = \"{tmpdir}/test_confirm\"\n    trust $ echo \"Y\" > {test_file} $\n    trust $ exec 0< {test_file} $\n    if input_confirm(\"Yes\"): echo(\"Confirm Yes\")\n    trust $ echo \"N\" > {test_file} $\n    trust $ exec 0< {test_file} $\n    if not input_confirm(\"No\"): echo(\"Confirm No\")\n    trust $ echo \"\" > {test_file} $\n    trust $ exec 0< {test_file} $\n    if input_confirm(\"Default\", true): echo(\"Confirm Default\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__0_v0() {\n    local major_55=0\n    local minor_56=0\n    local patch_57=0\n    major_55=${BASH_VERSINFO[0]}\n        minor_56=${BASH_VERSINFO[1]}\n        patch_57=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version0_v0=(\"${major_55}\" \"${minor_56}\" \"${patch_57}\")\n    return 0\n}\n\nreplace__1_v0() {\n    local source_51=\"${1}\"\n    local search_52=\"${2}\"\n    local replace_53=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_54=\"\"\n    bash_version__0_v0 \n    left_comp=(\"${ret_bash_version0_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_54=\"${source_51//\"${search_52}\"/\"${replace_53}\"}\"\n        __status=$?\n    else\n        result_54=\"${source_51//\"${search_52}\"/${replace_53}}\"\n        __status=$?\n    fi\n    ret_replace1_v0=\"${result_54}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__3_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version3_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nreplace_regex__4_v0() {\n    local source_46=\"${1}\"\n    local search_47=\"${2}\"\n    local replace_text_48=\"${3}\"\n    local extended_49=\"${4}\"\n    sed_version__3_v0 \n    local sed_version_50=\"${ret_sed_version3_v0}\"\n    replace__1_v0 \"${search_47}\" \"/\" \"\\\\/\"\n    search_47=\"${ret_replace1_v0}\"\n    replace__1_v0 \"${replace_text_48}\" \"/\" \"\\\\/\"\n    replace_text_48=\"${ret_replace1_v0}\"\n    if [ \"$(( $(( sed_version_50 == __SED_VERSION_GNU_1 )) || $(( sed_version_50 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__1_v0 \"${search_47}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_47=\"${ret_replace1_v0}\"\n    fi\n    if [ \"${extended_49}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_50 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            local command_2\n            command_2=\"$(sed -r -e \"s/${search_47}/${replace_text_48}/g\" <<<\"${source_46}\")\"\n            __status=$?\n            ret_replace_regex4_v0=\"${command_2}\"\n            return 0\n        else\n            local command_3\n            command_3=\"$(sed -E -e \"s/${search_47}/${replace_text_48}/g\" <<<\"${source_46}\")\"\n            __status=$?\n            ret_replace_regex4_v0=\"${command_3}\"\n            return 0\n        fi\n    else\n        if [ \"$(( $(( sed_version_50 == __SED_VERSION_GNU_1 )) || $(( sed_version_50 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__1_v0 \"${search_47}\" \"\\\\|\" \"|\"\n            search_47=\"${ret_replace1_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -e \"s/${search_47}/${replace_text_48}/g\" <<<\"${source_46}\")\"\n        __status=$?\n        ret_replace_regex4_v0=\"${command_4}\"\n        return 0\n    fi\n}\n\n# Output\n# z\n# ccc\n# E\n# abc[123]def\n# aeon aeons eon eons\n# #path#to#file.txt\n# Succeeded\n# Put number (255) in brackets\n# One or more matching\nreplace_regex__4_v0 \"aaa\" \"a+\" \"z\" 1\nret_replace_regex4_v0__15_10=\"${ret_replace_regex4_v0}\"\nprintf '%s\\n' \"${ret_replace_regex4_v0__15_10}\"\n# Single character bracket expression\nreplace_regex__4_v0 \"abc\" \"[ab]\" \"c\" 1\nret_replace_regex4_v0__17_10=\"${ret_replace_regex4_v0}\"\nprintf '%s\\n' \"${ret_replace_regex4_v0__17_10}\"\n# Range bracket expression\nreplace_regex__4_v0 \"E\" \"[A-Z]\" \"E\" 1\nret_replace_regex4_v0__19_10=\"${ret_replace_regex4_v0}\"\nprintf '%s\\n' \"${ret_replace_regex4_v0__19_10}\"\n# Combination of bracket exp, caupturing group and one or more\nreplace_regex__4_v0 \"abc123def\" \"([0-9]+)\" \"[\\\\1]\" 1\nret_replace_regex4_v0__21_10=\"${ret_replace_regex4_v0}\"\nprintf '%s\\n' \"${ret_replace_regex4_v0__21_10}\"\n# Word boundary should not be handled, because it is not POSIX standard\nreplace_regex__4_v0 \"aeon aeons eon eons\" \"\\\\beon\\\\b\" \"###\" 1\nret_replace_regex4_v0__23_10=\"${ret_replace_regex4_v0}\"\nprintf '%s\\n' \"${ret_replace_regex4_v0__23_10}\"\n# Replacing forward slash\nreplace_regex__4_v0 \"/path/to/file.txt\" \"/\" \"#\" 1\nret_replace_regex4_v0__25_10=\"${ret_replace_regex4_v0}\"\nprintf '%s\\n' \"${ret_replace_regex4_v0__25_10}\"\n# A pipe (|) should be treated as OR in POSIX Standards ERE.\nreplace_regex__4_v0 \".tar.gz\" \"\\\\.(tar\\\\.gz|tgz)\\$\" \"Succeeded\" 1\nret_replace_regex4_v0__27_10=\"${ret_replace_regex4_v0}\"\nprintf '%s\\n' \"${ret_replace_regex4_v0__27_10}\"\n# Capture groups\nreplace_regex__4_v0 \"Put number 255 in brackets\" \"([0-9]+)\" \"(\\\\1)\" 1\nret_replace_regex4_v0__29_10=\"${ret_replace_regex4_v0}\"\nprintf '%s\\n' \"${ret_replace_regex4_v0__29_10}\"", "output": "import * from \"std/text\"\n\n// Output\n// z\n// ccc\n// E\n// abc[123]def\n// aeon aeons eon eons\n// #path#to#file.txt\n// Succeeded\n// Put number (255) in brackets\n\nmain {\n    // One or more matching\n    echo(replace_regex(\"aaa\", \"a+\", \"z\", true))\n    // Single character bracket expression\n    echo(replace_regex(\"abc\", \"[ab]\", \"c\", true))\n    // Range bracket expression\n    echo(replace_regex(\"E\", \"[A-Z]\", \"E\", true))\n    // Combination of bracket exp, caupturing group and one or more\n    echo(replace_regex(\"abc123def\", \"([0-9]+)\", \"[\\1]\", true))\n    // Word boundary should not be handled, because it is not POSIX standard\n    echo(replace_regex(\"aeon aeons eon eons\", \"\\beon\\b\", \"###\", true))\n    // Replacing forward slash\n    echo(replace_regex(\"/path/to/file.txt\", \"/\", \"#\", true))\n    // A pipe (|) should be treated as OR in POSIX Standards ERE.\n    echo(replace_regex(\".tar.gz\", \"\\.(tar\\.gz|tgz)$\", \"Succeeded\", true))\n    // Capture groups\n    echo(replace_regex(\"Put number 255 in brackets\", \"([0-9]+)\", \"(\\1)\", true))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__0_v0() {\n    local major_136=0\n    local minor_137=0\n    local patch_138=0\n    major_136=${BASH_VERSINFO[0]}\n        minor_137=${BASH_VERSINFO[1]}\n        patch_138=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version0_v0=(\"${major_136}\" \"${minor_137}\" \"${patch_138}\")\n    return 0\n}\n\nreplace__1_v0() {\n    local source_132=\"${1}\"\n    local search_133=\"${2}\"\n    local replace_134=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_135=\"\"\n    bash_version__0_v0 \n    left_comp=(\"${ret_bash_version0_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_135=\"${source_132//\"${search_133}\"/\"${replace_134}\"}\"\n        __status=$?\n    else\n        result_135=\"${source_132//\"${search_133}\"/${replace_134}}\"\n        __status=$?\n    fi\n    ret_replace1_v0=\"${result_135}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__3_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version3_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nmatch_regex__20_v0() {\n    local source_128=\"${1}\"\n    local search_129=\"${2}\"\n    local extended_130=\"${3}\"\n    sed_version__3_v0 \n    local sed_version_131=\"${ret_sed_version3_v0}\"\n    replace__1_v0 \"${search_129}\" \"/\" \"\\\\/\"\n    search_129=\"${ret_replace1_v0}\"\n    local output_139=\"\"\n    if [ \"$(( $(( sed_version_131 == __SED_VERSION_GNU_1 )) || $(( sed_version_131 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__1_v0 \"${search_129}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_129=\"${ret_replace1_v0}\"\n    fi\n    if [ \"${extended_130}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_131 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            # '\\b' is not in POSIX standards. Disable it\n            replace__1_v0 \"${search_129}\" \"\\\\b\" \"\\\\b\"\n            search_129=\"${ret_replace1_v0}\"\n            local command_2\n            command_2=\"$(sed -r -ne \"/${search_129}/p\" <<<\"${source_128}\")\"\n            __status=$?\n            output_139=\"${command_2}\"\n        else\n            local command_3\n            command_3=\"$(sed -E -ne \"/${search_129}/p\" <<<\"${source_128}\")\"\n            __status=$?\n            output_139=\"${command_3}\"\n        fi\n    else\n        if [ \"$(( $(( sed_version_131 == __SED_VERSION_GNU_1 )) || $(( sed_version_131 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__1_v0 \"${search_129}\" \"\\\\|\" \"|\"\n            search_129=\"${ret_replace1_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -ne \"/${search_129}/p\" <<<\"${source_128}\")\"\n        __status=$?\n        output_139=\"${command_4}\"\n    fi\n    if [ \"$([ \"_${output_139}\" == \"_\" ]; echo $?)\" != 0 ]; then\n        ret_match_regex20_v0=1\n        return 0\n    fi\n    ret_match_regex20_v0=0\n    return 0\n}\n\nmatch_regex_any__21_v0() {\n    local text_125=\"${1}\"\n    local terms_126=(\"${!2}\")\n    for term_127 in \"${terms_126[@]}\"; do\n        match_regex__20_v0 \"${text_125}\" \"${term_127}\" 0\n        local ret_match_regex20_v0__361_12=\"${ret_match_regex20_v0}\"\n        if [ \"${ret_match_regex20_v0__361_12}\" != 0 ]; then\n            ret_match_regex_any21_v0=1\n            return 0\n        fi\n    done\n    ret_match_regex_any21_v0=0\n    return 0\n}\n\n# Output\n# Empty: 0\n# None: 0\n# Right: 1\n# Left: 1\n# Both: 1\ntest_multiple__37_v0() {\n    local label_122=\"${1}\"\n    local text_123=\"${2}\"\n    local terms_124=(\"${!3}\")\n    match_regex_any__21_v0 \"${text_123}\" terms_124[@]\n    local result_140=\"${ret_match_regex_any21_v0}\"\n    printf '%s\\n' \"${label_122}: ${result_140}\"\n}\n\narray_6=()\ntest_multiple__37_v0 \"Empty\" \"Hello World\" array_6[@]\narray_7=(\"Other\" \"Other\\$\")\ntest_multiple__37_v0 \"None\" \"Hello World\" array_7[@]\narray_8=(\"Other\" \"World\\$\")\ntest_multiple__37_v0 \"Right\" \"Hello World\" array_8[@]\narray_9=(\"^Hello\" \"Other\")\ntest_multiple__37_v0 \"Left\" \"Hello World\" array_9[@]\narray_10=(\"^Hello\" \"\\$World\")\ntest_multiple__37_v0 \"Both\" \"Hello World\" array_10[@]", "output": "import { match_regex_any } from \"std/text\"\n\n// Output\n// Empty: 0\n// None: 0\n// Right: 1\n// Left: 1\n// Both: 1\n\nfun test_multiple(label, text, terms) {\n    const result = match_regex_any(text, terms)\n    echo(\"{label}: {result}\")\n}\n\nmain {\n    test_multiple(\"Empty\", \"Hello World\", [Text])\n    test_multiple(\"None\", \"Hello World\", [\"Other\", \"Other$\"])\n    test_multiple(\"Right\", \"Hello World\", [\"Other\", \"World$\"])\n    test_multiple(\"Left\", \"Hello World\", [\"^Hello\", \"Other\"])\n    test_multiple(\"Both\", \"Hello World\", [\"^Hello\", \"$World\"])\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nmath_sum__0_v0() {\n    local list_3=(\"${!1}\")\n    local sum_4=0\n    for item_5 in \"${list_3[@]}\"; do\n        sum_4=\"$(( sum_4 + item_5 ))\"\n    done\n    ret_math_sum0_v0=\"${sum_4}\"\n    return 0\n}\n\n# Output\n# 10\narray_1=(1 2 3 4)\nmath_sum__0_v0 array_1[@]\nret_math_sum0_v0__7_10=\"${ret_math_sum0_v0}\"\necho \"${ret_math_sum0_v0__7_10}\"", "output": "import * from \"std/math\"\n\n// Output\n// 10\n\nmain {\n    echo(math_sum([1, 2, 3, 4]))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_5=\"${1}\"\n    local result_6=\"\"\n    result_6=\"${text_5#${text_5%%[![:space:]]*}}\"\n    result_6=\"${result_6%${result_6##*[![:space:]]}}\"\n    ret_trim11_v0=\"${result_6}\"\n    return 0\n}\n\ntrim__11_v0 \"  hello   world  \"\nret_trim11_v0__4_10=\"${ret_trim11_v0}\"\nprintf '%s\\n' \"${ret_trim11_v0__4_10}\"", "output": "import * from \"std/text\"\n\nmain {\n    echo(trim(\"  hello   world  \"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nescaped__132_v0() {\n    local text_4=\"${1}\"\n    ret_escaped132_v0=\"$(printf \"%s\n\" \"$text_4\" | sed -e 's/\\\\/\\\\\\\\/g' -e \"s/%/%%/g\")\"\n    return 0\n}\n\n# Output\n# Hello \\\\v Amber %%T\nescaped__132_v0 \"Hello \\\\v Amber %T\"\nret_escaped132_v0__7_10=\"${ret_escaped132_v0}\"\nprintf '%s\\n' \"${ret_escaped132_v0__7_10}\"", "output": "import * from \"std/env\"\n\n// Output\n// Hello \\\\v Amber %%T\n\nmain {\n    echo(escaped(\"Hello \\\\v Amber %T\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# All dates are internally stored as milliseconds since the Epoch (1970-01-01 00:00 UTC).\ndate_format_posix__0_v0() {\n    local date_4=\"${1}\"\n    local format_5=\"${2}\"\n    local utc_6=\"${3}\"\n    local utc_flag_7\n    utc_flag_7=\"$(if [ \"${utc_6}\" != 0 ]; then echo \"-u\"; else echo \"\"; fi)\"\n    # Case if this is a GNU date command\n    local command_1\n    command_1=\"$(date ${utc_flag_7} -d \"@${date_4}\" +\"${format_5}\" 2>/dev/null)\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        # Case if this is a BSD date command\n        local command_0\n        command_0=\"$(date ${utc_flag_7} -j -r \"${date_4}\" +\"${format_5}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_date_format_posix0_v0=''\n            return \"${__status}\"\n        fi\n        ret_date_format_posix0_v0=\"${command_0}\"\n        return 0\n    fi\n    ret_date_format_posix0_v0=\"${command_1}\"\n    return 0\n}\n\ndate_from_posix__1_v0() {\n    local date_12=\"${1}\"\n    local format_13=\"${2}\"\n    local utc_14=\"${3}\"\n    local utc_flag_15\n    utc_flag_15=\"$(if [ \"${utc_14}\" != 0 ]; then echo \"-u\"; else echo \"\"; fi)\"\n    # Case if this is a GNU date command\n    local command_3\n    command_3=\"$(date ${utc_flag_15} -d \"$(date -d \"${date_12}\" +\"${format_13}\" 2>/dev/null)\" +%s 2>/dev/null)\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        # Case if this is a BSD date command\n        local command_2\n        command_2=\"$(date ${utc_flag_15} -j -f \"${format_13}\" \"${date_12}\" +%s)\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_date_from_posix1_v0=''\n            return \"${__status}\"\n        fi\n        ret_date_from_posix1_v0=\"${command_2}\"\n        return 0\n    fi\n    ret_date_from_posix1_v0=\"${command_3}\"\n    return 0\n}\n\n# Output\n# 2009-02-07 09:46:40\n# 1234000000\ndate_format_posix__0_v0 1234000000 \"%F %T\" 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_date_format_posix0_v0__8_10=\"${ret_date_format_posix0_v0}\"\nprintf '%s\\n' \"${ret_date_format_posix0_v0__8_10}\"\ndate_from_posix__1_v0 \"2009-02-07 09:46:40\" \"%F %T\" 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_date_from_posix1_v0__9_10=\"${ret_date_from_posix1_v0}\"\necho \"${ret_date_from_posix1_v0__9_10}\"", "output": "import * from \"std/date\"\n\n// Output\n// 2009-02-07 09:46:40\n// 1234000000\n\nmain {\n    echo(date_format_posix(1234000000, \"%F %T\", true)?)\n    echo(date_from_posix(\"2009-02-07 09:46:40\", \"%F %T\", true)?)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nescaped__132_v0() {\n    local text_7=\"${1}\"\n    ret_escaped132_v0=\"$(printf \"%s\n\" \"$text_7\" | sed -e 's/\\\\/\\\\\\\\/g' -e \"s/%/%%/g\")\"\n    return 0\n}\n\nunderlined__136_v0() {\n    local message_6=\"${1}\"\n    escaped__132_v0 \"${message_6}\"\n    local ret_escaped132_v0__278_21=\"${ret_escaped132_v0}\"\n    ret_underlined136_v0=\"\\\\x1b[4m${ret_escaped132_v0__278_21}\\\\x1b[0m\"\n    return 0\n}\n\n# Output\n# \\x1b[4mHello Amber!\\x1b[0m\nunderlined__136_v0 \"Hello Amber\"'!'\"\"\nret_underlined136_v0__7_10=\"${ret_underlined136_v0}\"\nprintf '%s\\n' \"${ret_underlined136_v0__7_10}\"", "output": "import * from \"std/env\"\n\n// Output\n// \\x1b[4mHello Amber!\\x1b[0m\n\nmain {\n    echo(underlined(\"Hello Amber!\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nfile_exists__42_v0() {\n    local path_32=\"${1}\"\n    [ -f \"${path_32}\" ]\n    __status=$?\n    ret_file_exists42_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nfile_write__44_v0() {\n    local path_20=\"${1}\"\n    local content_21=\"${2}\"\n    local command_0\n    command_0=\"$(printf '%s\n' \"${content_21}\" > \"${path_20}\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_write44_v0=''\n        return \"${__status}\"\n    fi\n    ret_file_write44_v0=\"${command_0}\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_1\n        command_1=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_1}\"\n    else\n        local command_2\n        command_2=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_2}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\nenv_var_load__118_v0() {\n    local var_29=\"${1}\"\n    local file_30=\"${2}\"\n    local command_3\n    command_3=\"$(printf \"%s\n\" \"${!var_29}\")\"\n    __status=$?\n    local _var_31=\"${command_3}\"\n    if [ \"$([ \"_${_var_31}\" == \"_\" ]; echo $?)\" != 0 ]; then\n        ret_env_var_load118_v0=\"${_var_31}\"\n        return 0\n    fi\n    file_exists__42_v0 \"${file_30}\"\n    local ret_file_exists42_v0__17_8=\"${ret_file_exists42_v0}\"\n    if [ \"${ret_file_exists42_v0__17_8}\" != 0 ]; then\n        source \"${file_30}\"\n        __status=$?\n        local command_4\n        command_4=\"$(printf \"%s\n\" \"${!var_29}\")\"\n        __status=$?\n        ret_env_var_load118_v0=\"${command_4}\"\n        return 0\n    fi\n    ret_env_var_load118_v0=\"\"\n    return 0\n}\n\nenv_file_load__119_v0() {\n    local file_23=\"${1}\"\n    export \"$(xargs < ${file_23})\" > /dev/null\n    __status=$?\n}\n\n# Output\n# yes\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ncd \"${tmpdir_17}\" || exit\nfile_write__44_v0 \".env\" \"TEST=1\"\n__status=$?\nenv_file_load__119_v0 \".env\"\nenv_var_load__118_v0 \"TEST\" \".env\"\nret_env_var_load118_v0__12_8=\"${ret_env_var_load118_v0}\"\nif [ \"$([ \"_${ret_env_var_load118_v0__12_8}\" != \"_1\" ]; echo $?)\" != 0 ]; then\n    echo \"yes\"\nfi", "output": "import { env_file_load, env_var_load } from \"std/env\"\nimport { file_write, temp_dir_create } from \"std/fs\"\n\n// Output\n// yes\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    cd(tmpdir)\n    trust file_write(\".env\", \"TEST=1\")\n    env_file_load()\n    if env_var_load(\"TEST\") == \"1\" {\n        echo(\"yes\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_14=(\"${!1}\")\n    local value_15=\"${2}\"\n    index_17=0;\n    for element_16 in \"${array_14[@]}\"; do\n        if [ \"$([ \"_${value_15}\" != \"_${element_16}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_17}\"\n            return 0\n        fi\n        (( index_17++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_12=(\"${!1}\")\n    local value_13=\"${2}\"\n    array_find__0_v0 array_12[@] \"${value_13}\"\n    local result_18=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_18 >= 0 ))\"\n    return 0\n}\n\n# Output\n# Not Found\narray_0=()\narray_contains__2_v0 array_0[@] 0\nret_array_contains2_v0__8_8=\"${ret_array_contains2_v0}\"\nif [ \"${ret_array_contains2_v0__8_8}\" != 0 ]; then\n    echo \"Found\"\nelse\n    echo \"Not Found\"\nfi", "output": "import * from \"std/array\"\n\n// Output\n// Not Found\n\nmain {\n    const array = [Num]\n    if array_contains(array, 0) {\n        echo(\"Found\")\n    } else {\n        echo(\"Not Found\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__0_v0() {\n    local major_227=0\n    local minor_228=0\n    local patch_229=0\n    major_227=${BASH_VERSINFO[0]}\n        minor_228=${BASH_VERSINFO[1]}\n        patch_229=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version0_v0=(\"${major_227}\" \"${minor_228}\" \"${patch_229}\")\n    return 0\n}\n\nreplace__1_v0() {\n    local source_223=\"${1}\"\n    local search_224=\"${2}\"\n    local replace_225=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_226=\"\"\n    bash_version__0_v0 \n    left_comp=(\"${ret_bash_version0_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_226=\"${source_223//\"${search_224}\"/\"${replace_225}\"}\"\n        __status=$?\n    else\n        result_226=\"${source_223//\"${search_224}\"/${replace_225}}\"\n        __status=$?\n    fi\n    ret_replace1_v0=\"${result_226}\"\n    return 0\n}\n\nreplace_one__2_v0() {\n    local source_233=\"${1}\"\n    local search_234=\"${2}\"\n    local replace_235=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_236=\"\"\n    bash_version__0_v0 \n    left_comp=(\"${ret_bash_version0_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_236=\"${source_233/\"${search_234}\"/\"${replace_235}\"}\"\n        __status=$?\n    else\n        result_236=\"${source_233/\"${search_234}\"/${replace_235}}\"\n        __status=$?\n    fi\n    ret_replace_one2_v0=\"${result_236}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__3_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version3_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version3_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nsplit__5_v0() {\n    local text_238=\"${1}\"\n    local delimiter_239=\"${2}\"\n    local result_240=()\n    IFS=\"${delimiter_239}\" read -rd '' -a result_240 < <(printf %s \"$text_238\")\n    __status=$?\n    ret_split5_v0=(\"${result_240[@]}\")\n    return 0\n}\n\nsplit_lines__6_v0() {\n    local text_237=\"${1}\"\n    split__5_v0 \"${text_237}\" \"\n\"\n    ret_split_lines6_v0=(\"${ret_split5_v0[@]}\")\n    return 0\n}\n\nparse_int__14_v0() {\n    local text_242=\"${1}\"\n    [ -n \"${text_242}\" ] && [ \"${text_242}\" -eq \"${text_242}\" ] 2>/dev/null\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_parse_int14_v0=''\n        return \"${__status}\"\n    fi\n    ret_parse_int14_v0=\"${text_242}\"\n    return 0\n}\n\ntext_contains__17_v0() {\n    local source_251=\"${1}\"\n    local search_252=\"${2}\"\n    [[ \"${source_251}\" == *\"${search_252}\"* ]]\n    __status=$?\n    ret_text_contains17_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nmatch_regex__20_v0() {\n    local source_219=\"${1}\"\n    local search_220=\"${2}\"\n    local extended_221=\"${3}\"\n    sed_version__3_v0 \n    local sed_version_222=\"${ret_sed_version3_v0}\"\n    replace__1_v0 \"${search_220}\" \"/\" \"\\\\/\"\n    search_220=\"${ret_replace1_v0}\"\n    local output_230=\"\"\n    if [ \"$(( $(( sed_version_222 == __SED_VERSION_GNU_1 )) || $(( sed_version_222 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__1_v0 \"${search_220}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_220=\"${ret_replace1_v0}\"\n    fi\n    if [ \"${extended_221}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_222 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            # '\\b' is not in POSIX standards. Disable it\n            replace__1_v0 \"${search_220}\" \"\\\\b\" \"\\\\b\"\n            search_220=\"${ret_replace1_v0}\"\n            local command_4\n            command_4=\"$(sed -r -ne \"/${search_220}/p\" <<<\"${source_219}\")\"\n            __status=$?\n            output_230=\"${command_4}\"\n        else\n            local command_5\n            command_5=\"$(sed -E -ne \"/${search_220}/p\" <<<\"${source_219}\")\"\n            __status=$?\n            output_230=\"${command_5}\"\n        fi\n    else\n        if [ \"$(( $(( sed_version_222 == __SED_VERSION_GNU_1 )) || $(( sed_version_222 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__1_v0 \"${search_220}\" \"\\\\|\" \"|\"\n            search_220=\"${ret_replace1_v0}\"\n        fi\n        local command_6\n        command_6=\"$(sed -ne \"/${search_220}/p\" <<<\"${source_219}\")\"\n        __status=$?\n        output_230=\"${command_6}\"\n    fi\n    if [ \"$([ \"_${output_230}\" == \"_\" ]; echo $?)\" != 0 ]; then\n        ret_match_regex20_v0=1\n        return 0\n    fi\n    ret_match_regex20_v0=0\n    return 0\n}\n\nis_command__125_v0() {\n    local command_209=\"${1}\"\n    [ -x \"$(command -v \"${command_209}\")\" ]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_command125_v0=0\n        return 0\n    fi\n    ret_is_command125_v0=1\n    return 0\n}\n\nprintf__131_v0() {\n    local format_215=\"${1}\"\n    local args_216=(\"${!2}\")\n    args_216=(\"${format_215}\" \"${args_216[@]}\")\n    __status=$?\n    printf \"${args_216[@]}\"\n    __status=$?\n}\n\necho_error__141_v0() {\n    local message_213=\"${1}\"\n    local exit_code_214=\"${2}\"\n    local array_7=(\"${message_213}\")\n    printf__131_v0 \"\\\\x1b[1;3;97;41m%s\\\\x1b[0m\n\" array_7[@]\n    if [ \"$(( exit_code_214 > 0 ))\" != 0 ]; then\n        exit \"${exit_code_214}\"\n    fi\n}\n\nbash_version__142_v0() {\n    local command_8\n    command_8=\"$(printf \"%s\n\" \"${BASH_VERSINFO[0]}\")\"\n    __status=$?\n    local major_245=\"${command_8}\"\n    local command_9\n    command_9=\"$(printf \"%s\n\" \"${BASH_VERSINFO[1]}\")\"\n    __status=$?\n    local minor_246=\"${command_9}\"\n    local command_10\n    command_10=\"$(printf \"%s\n\" \"${BASH_VERSINFO[2]}\")\"\n    __status=$?\n    local patch_247=\"${command_10}\"\n    ret_bash_version142_v0=(\"${major_245}\" \"${minor_246}\" \"${patch_247}\")\n    return 0\n}\n\nfetch__240_v0() {\n    local url_204=\"${1}\"\n    local method_205=\"${2}\"\n    local data_206=\"${3}\"\n    local headers_207=(\"${!4}\")\n    local full_headers_208=\"\"\n    is_command__125_v0 \"curl\"\n    local ret_is_command125_v0__46_9=\"${ret_is_command125_v0}\"\n    is_command__125_v0 \"wget\"\n    local ret_is_command125_v0__58_9=\"${ret_is_command125_v0}\"\n    if [ \"${ret_is_command125_v0__46_9}\" != 0 ]; then\n        local __length_12=\"${data_206}\"\n        local post_data_210\n        post_data_210=\"$(if [ \"$(( ${#__length_12} > 0 ))\" != 0 ]; then echo \"-d ${data_206}\"; else echo \"\"; fi)\"\n        local __length_13=\"${headers_207[0]}\"\n        if [ \"$(( ${#__length_13} > 0 ))\" != 0 ]; then\n            for header_211 in \"${headers_207[@]}\"; do\n                full_headers_208=\"${full_headers_208}\"\" -H \\\"${header_211}\\\"\"\n            done\n        fi\n        local command_14\n        command_14=\"$(curl -L \"${url_204}\" --silent -S -X ${method_205} ${full_headers_208} ${post_data_210} 2>&1)\"\n        __status=$?\n        local output_212=\"${command_14}\"\n        if [ \"$(( __status > 0 ))\" != 0 ]; then\n            echo_error__141_v0 \"curl request failed with error: ${output_212}\" \"${__status}\"\n        fi\n        ret_fetch240_v0=\"${output_212}\"\n        return 0\n    elif [ \"${ret_is_command125_v0__58_9}\" != 0 ]; then\n        local __length_15=\"${data_206}\"\n        local post_data_217\n        post_data_217=\"$(if [ \"$(( ${#__length_15} > 0 ))\" != 0 ]; then echo \"--body-data ${data_206}\"; else echo \"\"; fi)\"\n        local __length_16=\"${headers_207[0]}\"\n        if [ \"$(( ${#__length_16} > 0 ))\" != 0 ]; then\n            for header_218 in \"${headers_207[@]}\"; do\n                full_headers_208=\"${full_headers_208}\"\" --header='${header_218}'\"\n            done\n        fi\n        local command_17\n        command_17=\"$(wget \"${url_204}\" -qO- --method=\"${method_205}\" ${full_headers_208} ${post_data_217})\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            echo_error__141_v0 \"wget request failed with exit code ${__status}\" \"${__status}\"\n        fi\n        ret_fetch240_v0=\"${command_17}\"\n        return 0\n    else\n        match_regex__20_v0 \"${url_204}\" \"http://\" 0\n        local ret_match_regex20_v0__68_16=\"${ret_match_regex20_v0}\"\n        if [ \"${ret_match_regex20_v0__68_16}\" != 0 ]; then\n            local port_231=80\n            local path_232=\"\"\n            replace__1_v0 \"${url_204}\" \"http://\" \"\"\n            url_204=\"${ret_replace1_v0}\"\n            replace_one__2_v0 \"${url_204}\" \"/\" \"\n\"\n            local ret_replace_one2_v0__72_41=\"${ret_replace_one2_v0}\"\n            split_lines__6_v0 \"${ret_replace_one2_v0__72_41}\"\n            local parts_241=(\"${ret_split_lines6_v0[@]}\")\n            # split host and path\n            url_204=\"${parts_241[0]}\"\n            match_regex__20_v0 \"${url_204}\" \":([0-9][0-9]+)\" 1\n            local ret_match_regex20_v0__75_20=\"${ret_match_regex20_v0}\"\n            if [ \"${ret_match_regex20_v0__75_20}\" != 0 ]; then\n                # https://github.com/amber-lang/amber/pull/906#discussion_r2616210649\n                path_232=\"${parts_241[1]}\"\n                replace_one__2_v0 \"${url_204}\" \":\" \"\n\"\n                local ret_replace_one2_v0__77_41=\"${ret_replace_one2_v0}\"\n                split_lines__6_v0 \"${ret_replace_one2_v0__77_41}\"\n                parts_241=(\"${ret_split_lines6_v0[@]}\")\n                # split IP/domain and port\n                url_204=\"${parts_241[0]}\"\n                parse_int__14_v0 \"${parts_241[1]}\"\n                __status=$?\n                if [ \"${__status}\" != 0 ]; then\n                    ret_fetch240_v0=''\n                    return \"${__status}\"\n                fi\n                port_231=\"${ret_parse_int14_v0}\"\n            else\n                local __length_18=\"${parts_241[1]}\"\n                path_232=\"$(if [ \"$(( ${#__length_18} > 0 ))\" != 0 ]; then echo \"${parts_241[1]}\"; else echo \"\"; fi)\"\n            fi\n            local __length_19=\"${headers_207[0]}\"\n            if [ \"$(( ${#__length_19} > 1 ))\" != 0 ]; then\n                for header_243 in \"${headers_207[@]}\"; do\n                    full_headers_208=\"${full_headers_208}\"\"${header_243}\n\"\n                done\n            fi\n            local __length_20=\"${data_206}\"\n            if [ \"$(( ${#__length_20} > 0 ))\" != 0 ]; then\n                local __length_21=\"${data_206}\"\n                full_headers_208=\"${full_headers_208}\"\"content-length: ${#__length_21}\n\"\n                local __length_22=\"${headers_207[0]}\"\n                if [ \"$(( ${#__length_22} == 0 ))\" != 0 ]; then\n                    full_headers_208=\"${full_headers_208}\"\"content-type: application/x-www-form-urlencoded\n\"\n                fi\n                full_headers_208=\"${full_headers_208}\"\"\n${data_206}\n\"\n            fi\n            exec 3<>/dev/tcp/${url_204}/${port_231}\n            __status=$?\n            if [ \"${__status}\" = 0 ]; then\n                local http_code_244=0\n                url_204=\"$(if [ \"$(( port_231 != 80 ))\" != 0 ]; then echo \"${url_204}:${port_231}\"; else echo \"${url_204}\"; fi)\"\n                bash_version__142_v0 \n                local vers_248=(\"${ret_bash_version142_v0[@]}\")\n                printf \"%s\n\" \"${method_205} /${path_232} HTTP/1.1\nhost: ${url_204}\nconnection: close\nuser-agent: Amber/bash-${vers_248[0]}.${vers_248[1]}.${vers_248[2]}\naccept: */*\n${full_headers_208}\" >&3\n                __status=$?\n                read _ http_code_244 _ <&3\n                  while IFS= read -r line; do \n                    [[ \"$line\" == $'\n' || -z \"$line\" ]] && break \n                  done <&3\n                __status=$?\n                if [ \"$(( http_code_244 > 226 ))\" != 0 ]; then\n                    # all official HTTP 2** codes go up to 226\n                    ret_fetch240_v0=\"${http_code_244}\"\n                    return 0\n                    # as for now, the best way is to return HTTP code since exit codes can't be >255\n                else\n                    local command_23\n                    command_23=\"$(cat <&3 && exec 3>&-)\"\n                    __status=$?\n                    ret_fetch240_v0=\"${command_23}\"\n                    return 0\n                fi\n            fi\n            echo_error__141_v0 \"Request failed with exit code ${__status}\" \"${__status}\"\n        else\n            echo_error__141_v0 \"No connection method is available, aborting\" 1\n        fi\n    fi\n}\n\narray_25=(\"\")\nfetch__240_v0 \"http://echo.free.beeceptor.com\" \"GET\" \"\" array_25[@]\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_fetch240_v0__4_26=\"${ret_fetch240_v0}\"\ntext_contains__17_v0 \"${ret_fetch240_v0__4_26}\" \"GET\"\nret_text_contains17_v0__4_12=\"${ret_text_contains17_v0}\"\nif [ \"$(( ! ret_text_contains17_v0__4_12 ))\" != 0 ]; then\n    exit 1\nfi\narray_26=(\"\")\nfetch__240_v0 \"http://echo.free.beeceptor.com\" \"POST\" \"\" array_26[@]\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_fetch240_v0__6_26=\"${ret_fetch240_v0}\"\ntext_contains__17_v0 \"${ret_fetch240_v0__6_26}\" \"POST\"\nret_text_contains17_v0__6_12=\"${ret_text_contains17_v0}\"\nif [ \"$(( ! ret_text_contains17_v0__6_12 ))\" != 0 ]; then\n    exit 1\nfi\narray_27=(\"\")\nfetch__240_v0 \"http://echo.free.beeceptor.com\" \"PUT\" \"\" array_27[@]\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_fetch240_v0__8_26=\"${ret_fetch240_v0}\"\ntext_contains__17_v0 \"${ret_fetch240_v0__8_26}\" \"PUT\"\nret_text_contains17_v0__8_12=\"${ret_text_contains17_v0}\"\nif [ \"$(( ! ret_text_contains17_v0__8_12 ))\" != 0 ]; then\n    exit 1\nfi\narray_28=(\"\")\nfetch__240_v0 \"http://echo.free.beeceptor.com\" \"DELETE\" \"\" array_28[@]\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_fetch240_v0__10_26=\"${ret_fetch240_v0}\"\ntext_contains__17_v0 \"${ret_fetch240_v0__10_26}\" \"DELETE\"\nret_text_contains17_v0__10_12=\"${ret_text_contains17_v0}\"\nif [ \"$(( ! ret_text_contains17_v0__10_12 ))\" != 0 ]; then\n    exit 1\nfi\necho \"Succeeded\"", "output": "import { fetch } from \"std/http\"\nimport { text_contains } from \"std/text\"\nmain {\n    if not text_contains(fetch(\"http://echo.free.beeceptor.com\")?, \"GET\"): fail 1\n\n    if not text_contains(fetch(\"http://echo.free.beeceptor.com\", \"POST\")?, \"POST\"): fail 1\n\n    if not text_contains(fetch(\"http://echo.free.beeceptor.com\", \"PUT\")?, \"PUT\"): fail 1\n\n    if not text_contains(fetch(\"http://echo.free.beeceptor.com\", \"DELETE\")?, \"DELETE\"): fail 1\n\n    echo(\"Succeeded\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find__0_v0() {\n    local array_309=(\"${!1}\")\n    local value_310=\"${2}\"\n    index_312=0;\n    for element_311 in \"${array_309[@]}\"; do\n        if [ \"$([ \"_${value_310}\" != \"_${element_311}\" ]; echo $?)\" != 0 ]; then\n            ret_array_find0_v0=\"${index_312}\"\n            return 0\n        fi\n        (( index_312++ )) || true\n    done\n    ret_array_find0_v0=-1\n    return 0\n}\n\narray_contains__2_v0() {\n    local array_307=(\"${!1}\")\n    local value_308=\"${2}\"\n    array_find__0_v0 array_307[@] \"${value_308}\"\n    local result_313=\"${ret_array_find0_v0}\"\n    ret_array_contains2_v0=\"$(( result_313 >= 0 ))\"\n    return 0\n}\n\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nbash_version__24_v0() {\n    local major_271=0\n    local minor_272=0\n    local patch_273=0\n    major_271=${BASH_VERSINFO[0]}\n        minor_272=${BASH_VERSINFO[1]}\n        patch_273=${BASH_VERSINFO[2]}\n    __status=$?\n    ret_bash_version24_v0=(\"${major_271}\" \"${minor_272}\" \"${patch_273}\")\n    return 0\n}\n\nreplace__25_v0() {\n    local source_267=\"${1}\"\n    local search_268=\"${2}\"\n    local replace_269=\"${3}\"\n    # Here we use a command to avoid #646\n    local result_270=\"\"\n    bash_version__24_v0 \n    left_comp=(\"${ret_bash_version24_v0[@]}\")\n    right_comp=(4 3)\n    local comp\n    comp=\"$(\n        # Compare if left array >= right array\n        len_comp=\"$( (( \"${#left_comp[@]}\" < \"${#right_comp[@]}\" )) && echo \"${#left_comp[@]}\"|| echo \"${#right_comp[@]}\")\"\n        for (( i=0; i<len_comp; i++ )); do\n            left=\"${left_comp[i]:-0}\"\n            right=\"${right_comp[i]:-0}\"\n            if (( \"${left}\" > \"${right}\" )); then\n                echo 1\n                exit\n            elif (( \"${left}\" < \"${right}\" )); then\n                echo 0\n                exit\n            fi\n        done\n        (( \"${#left_comp[@]}\" == \"${#right_comp[@]}\" || \"${#left_comp[@]}\" > \"${#right_comp[@]}\" )) && echo 1 || echo 0\n)\"\n    if [ \"${comp}\" != 0 ]; then\n        result_270=\"${source_267//\"${search_268}\"/\"${replace_269}\"}\"\n        __status=$?\n    else\n        result_270=\"${source_267//\"${search_268}\"/${replace_269}}\"\n        __status=$?\n    fi\n    ret_replace25_v0=\"${result_270}\"\n    return 0\n}\n\n__SED_VERSION_UNKNOWN_0=0\n__SED_VERSION_GNU_1=1\n__SED_VERSION_BUSYBOX_2=2\nsed_version__27_v0() {\n    # We can't match against a word \"GNU\" because\n    # alpine's busybox sed returns \"This is not GNU sed version\"\n    re='Copyright.+Free Software Foundation'; [[ $(sed --version 2>/dev/null) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_GNU_1}\"\n        return 0\n    fi\n    # On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.\n    re='BusyBox'; [[ $(sed --help 2>&1) =~ $re ]]\n    __status=$?\n    if [ \"$(( __status == 0 ))\" != 0 ]; then\n        ret_sed_version27_v0=\"${__SED_VERSION_BUSYBOX_2}\"\n        return 0\n    fi\n    ret_sed_version27_v0=\"${__SED_VERSION_UNKNOWN_0}\"\n    return 0\n}\n\nreplace_regex__28_v0() {\n    local source_262=\"${1}\"\n    local search_263=\"${2}\"\n    local replace_text_264=\"${3}\"\n    local extended_265=\"${4}\"\n    sed_version__27_v0 \n    local sed_version_266=\"${ret_sed_version27_v0}\"\n    replace__25_v0 \"${search_263}\" \"/\" \"\\\\/\"\n    search_263=\"${ret_replace25_v0}\"\n    replace__25_v0 \"${replace_text_264}\" \"/\" \"\\\\/\"\n    replace_text_264=\"${ret_replace25_v0}\"\n    if [ \"$(( $(( sed_version_266 == __SED_VERSION_GNU_1 )) || $(( sed_version_266 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n        # '\\b' is supported but not in POSIX standards. Disable it\n        replace__25_v0 \"${search_263}\" \"\\\\b\" \"\\\\\\\\b\"\n        search_263=\"${ret_replace25_v0}\"\n    fi\n    if [ \"${extended_265}\" != 0 ]; then\n        # GNU sed versions 4.0 through 4.2 support extended regex syntax,\n        # but only via the \"-r\" option\n        if [ \"$(( sed_version_266 == __SED_VERSION_GNU_1 ))\" != 0 ]; then\n            local command_2\n            command_2=\"$(sed -r -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_2}\"\n            return 0\n        else\n            local command_3\n            command_3=\"$(sed -E -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n            __status=$?\n            ret_replace_regex28_v0=\"${command_3}\"\n            return 0\n        fi\n    else\n        if [ \"$(( $(( sed_version_266 == __SED_VERSION_GNU_1 )) || $(( sed_version_266 == __SED_VERSION_BUSYBOX_2 )) ))\" != 0 ]; then\n            # GNU Sed BRE handle \\| as a metacharacter, but it is not POSIX standands. Disable it\n            replace__25_v0 \"${search_263}\" \"\\\\|\" \"|\"\n            search_263=\"${ret_replace25_v0}\"\n        fi\n        local command_4\n        command_4=\"$(sed -e \"s/${search_263}/${replace_text_264}/g\" <<<\"${source_262}\")\"\n        __status=$?\n        ret_replace_regex28_v0=\"${command_4}\"\n        return 0\n    fi\n}\n\nsplit__29_v0() {\n    local text_279=\"${1}\"\n    local delimiter_280=\"${2}\"\n    local result_281=()\n    IFS=\"${delimiter_280}\" read -rd '' -a result_281 < <(printf %s \"$text_279\")\n    __status=$?\n    ret_split29_v0=(\"${result_281[@]}\")\n    return 0\n}\n\njoin__32_v0() {\n    local list_276=(\"${!1}\")\n    local delimiter_277=\"${2}\"\n    local command_6\n    command_6=\"$(IFS=\"${delimiter_277}\" ; printf \"%s\n\" \"${list_276[*]}\")\"\n    __status=$?\n    ret_join32_v0=\"${command_6}\"\n    return 0\n}\n\ntrim__35_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    __status=$?\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim35_v0=\"${result_15}\"\n    return 0\n}\n\nis_mac_os_mktemp__72_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp72_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp72_v0=0\n    return 0\n}\n\ntemp_dir_create__73_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__35_v0 \"${template_11}\"\n    local ret_trim35_v0__113_8=\"${ret_trim35_v0}\"\n    if [ \"$([ \"_${ret_trim35_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__72_v0 \n    local ret_is_mac_os_mktemp72_v0__119_8=\"${ret_is_mac_os_mktemp72_v0}\"\n    if [ \"${ret_is_mac_os_mktemp72_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_7\n        command_7=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_7}\"\n    else\n        local command_8\n        command_8=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create73_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_8}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create73_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create73_v0=\"${filename_16}\"\n    return 0\n}\n\nescape_non_glob_chars__76_v0() {\n    local path_261=\"${1}\"\n    replace_regex__28_v0 \"${path_261}\" \"\\\\([^*?/]\\\\)\" \"\\\\\\\\\\\\1\" 0\n    ret_escape_non_glob_chars76_v0=\"${ret_replace_regex28_v0}\"\n    return 0\n}\n\nfile_glob_all__77_v0() {\n    local paths_259=(\"${!1}\")\n    local combined_260=\"\"\n    local __length_9=(\"${paths_259[@]}\")\n    if [ \"$(( ${#__length_9[@]} == 1 ))\" != 0 ]; then\n        escape_non_glob_chars__76_v0 \"${paths_259[0]}\"\n        combined_260=\"${ret_escape_non_glob_chars76_v0}\"\n    else\n        local items_274=()\n        for item_275 in \"${paths_259[@]}\"; do\n            escape_non_glob_chars__76_v0 \"${item_275}\"\n            item_275=\"${ret_escape_non_glob_chars76_v0}\"\n            items_274+=(\"${item_275}\")\n        done\n        join__32_v0 items_274[@] \" \"\n        combined_260=\"${ret_join32_v0}\"\n    fi\n    local command_12\n    command_12=\"$(eval \"for file in ${combined_260}; do [ -e \\\"\\$file\\\" ] && printf \\\"%s\\n\\\" \\\"\\$file\\\"; done\")\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob_all77_v0=()\n        return \"${__status}\"\n    fi\n    local files_278=\"${command_12}\"\n    split__29_v0 \"${files_278}\" \"\n\"\n    ret_file_glob_all77_v0=(\"${ret_split29_v0[@]}\")\n    return 0\n}\n\nfile_glob__78_v0() {\n    local path_258=\"${1}\"\n    local array_13=(\"${path_258}\")\n    file_glob_all__77_v0 array_13[@]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_file_glob78_v0=()\n        return \"${__status}\"\n    fi\n    ret_file_glob78_v0=(\"${ret_file_glob_all77_v0[@]}\")\n    return 0\n}\n\ncompare__129_v0() {\n    local actual_304=(\"${!1}\")\n    local expected_305=(\"${!2}\")\n    local __length_14=(\"${actual_304[@]}\")\n    local __length_15=(\"${expected_305[@]}\")\n    if [ \"$(( ${#__length_14[@]} != ${#__length_15[@]} ))\" != 0 ]; then\n        ret_compare129_v0=0\n        return 0\n    fi\n    for file_306 in \"${expected_305[@]}\"; do\n        array_contains__2_v0 actual_304[@] \"${file_306}\"\n        local ret_array_contains2_v0__10_16=\"${ret_array_contains2_v0}\"\n        if [ \"$(( ! ret_array_contains2_v0__10_16 ))\" != 0 ]; then\n            ret_compare129_v0=0\n            return 0\n        fi\n    done\n    ret_compare129_v0=1\n    return 0\n}\n\ntemp_dir_create__73_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create73_v0}\"\ntouch \"${tmpdir_17}/1st file with spaces.txt\"\ntouch \"${tmpdir_17}/2nd file with spaces.txt\"\ntouch \"${tmpdir_17}/file.txt\"\ntouch \"${tmpdir_17}/file1.txt\"\ntouch \"${tmpdir_17}/file2.txt\"\ntouch \"${tmpdir_17}/file99.txt\"\ntouch \"${tmpdir_17}/other.csv\"\nexpected_18=(\"${tmpdir_17}/file.txt\" \"${tmpdir_17}/file1.txt\" \"${tmpdir_17}/file2.txt\" \"${tmpdir_17}/file99.txt\")\nfile_glob__78_v0 \"${tmpdir_17}/file*.txt\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    echo \"FAILED\"\nfi\nactual_282=(\"${ret_file_glob78_v0[@]}\")\ncompare__129_v0 actual_282[@] expected_18[@]\nret_compare129_v0__38_8=\"${ret_compare129_v0}\"\nif [ \"${ret_compare129_v0__38_8}\" != 0 ]; then\n    echo \"Succeeded\"\nelse\n    echo \"Expected: ${expected_18[*]}\"\n    echo \"Actual: ${actual_282[*]}\"\nfi", "output": "import * from \"std/array\"\nimport * from \"std/fs\"\nimport * from \"std/text\"\n\nfun compare(actual: [Text], expected: [Text]): Bool {\n    if len(actual) != len(expected) {\n        return false\n    }\n    for file in expected {\n        if not array_contains(actual, file) {\n            return false\n        }\n    }\n    return true\n}\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    trust {\n        touch(\"{tmpdir}/1st file with spaces.txt\")\n        touch(\"{tmpdir}/2nd file with spaces.txt\")\n        touch(\"{tmpdir}/file.txt\")\n        touch(\"{tmpdir}/file1.txt\")\n        touch(\"{tmpdir}/file2.txt\")\n        touch(\"{tmpdir}/file99.txt\")\n        touch(\"{tmpdir}/other.csv\")\n    }\n\n    const expected = [\n        \"{tmpdir}/file.txt\",\n        \"{tmpdir}/file1.txt\",\n        \"{tmpdir}/file2.txt\",\n        \"{tmpdir}/file99.txt\",\n    ]\n    const actual = file_glob(\"{tmpdir}/file*.txt\") failed {\n        echo(\"FAILED\")\n    }\n    if compare(actual, expected) {\n        echo(\"Succeeded\")\n    } else {\n        echo(\"Expected: {expected}\")\n        echo(\"Actual: {actual}\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# All dates are internally stored as milliseconds since the Epoch (1970-01-01 00:00 UTC).\ndate_from_posix__1_v0() {\n    local date_4=\"${1}\"\n    local format_5=\"${2}\"\n    local utc_6=\"${3}\"\n    local utc_flag_7\n    utc_flag_7=\"$(if [ \"${utc_6}\" != 0 ]; then echo \"-u\"; else echo \"\"; fi)\"\n    # Case if this is a GNU date command\n    local command_1\n    command_1=\"$(date ${utc_flag_7} -d \"$(date -d \"${date_4}\" +\"${format_5}\" 2>/dev/null)\" +%s 2>/dev/null)\"\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        # Case if this is a BSD date command\n        local command_0\n        command_0=\"$(date ${utc_flag_7} -j -f \"${format_5}\" \"${date_4}\" +%s)\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_date_from_posix1_v0=''\n            return \"${__status}\"\n        fi\n        ret_date_from_posix1_v0=\"${command_0}\"\n        return 0\n    fi\n    ret_date_from_posix1_v0=\"${command_1}\"\n    return 0\n}\n\ndate_add__3_v0() {\n    local date_12=\"${1}\"\n    local amount_13=\"${2}\"\n    local unit_14=\"${3}\"\n    if [ \"$([ \"_${unit_14}\" != \"_years\" ]; echo $?)\" != 0 ]; then\n        ret_date_add3_v0=\"$(( date_12 + $(( $(( $(( $(( amount_13 * 365 )) * 24 )) * 60 )) * 60 )) ))\"\n        return 0\n    elif [ \"$([ \"_${unit_14}\" != \"_months\" ]; echo $?)\" != 0 ]; then\n        ret_date_add3_v0=\"$(( date_12 + $(( $(( $(( $(( amount_13 * 30 )) * 24 )) * 60 )) * 60 )) ))\"\n        return 0\n    elif [ \"$([ \"_${unit_14}\" != \"_days\" ]; echo $?)\" != 0 ]; then\n        ret_date_add3_v0=\"$(( date_12 + $(( $(( $(( amount_13 * 24 )) * 60 )) * 60 )) ))\"\n        return 0\n    elif [ \"$([ \"_${unit_14}\" != \"_hours\" ]; echo $?)\" != 0 ]; then\n        ret_date_add3_v0=\"$(( date_12 + $(( $(( amount_13 * 60 )) * 60 )) ))\"\n        return 0\n    elif [ \"$([ \"_${unit_14}\" != \"_minutes\" ]; echo $?)\" != 0 ]; then\n        ret_date_add3_v0=\"$(( date_12 + $(( amount_13 * 60 )) ))\"\n        return 0\n    elif [ \"$([ \"_${unit_14}\" != \"_seconds\" ]; echo $?)\" != 0 ]; then\n        ret_date_add3_v0=\"$(( date_12 + amount_13 ))\"\n        return 0\n    else\n        ret_date_add3_v0=''\n        return 1\n    fi\n}\n\ndate_from_posix__1_v0 \"2009-02-07 09:46:40\" \"%F %T\" 0\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ndate_8=\"${ret_date_from_posix1_v0}\"\ndate_add__3_v0 \"${date_8}\" 17 \"days\"\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_date_add3_v0__5_8=\"${ret_date_add3_v0}\"\ndate_from_posix__1_v0 \"2009-02-24 09:46:40\" \"%F %T\" 0\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\nret_date_from_posix1_v0__5_39=\"${ret_date_from_posix1_v0}\"\nif [ \"$(( ret_date_add3_v0__5_8 == ret_date_from_posix1_v0__5_39 ))\" != 0 ]; then\n    echo \"Succeeded\"\nfi", "output": "import * from \"std/date\"\n\nmain {\n    const date = date_from_posix(\"2009-02-07 09:46:40\")?\n    if date_add(date, 17, \"days\")? == date_from_posix(\"2009-02-24 09:46:40\")? {\n        echo(\"Succeeded\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim_left__9_v0() {\n    local text_5=\"${1}\"\n    local result_6=\"\"\n    result_6=\"${text_5#${text_5%%[![:space:]]*}}\"\n    ret_trim_left9_v0=\"${result_6}\"\n    return 0\n}\n\ntrim_left__9_v0 \"  hello   world  \"\nret_trim_left9_v0__4_10=\"${ret_trim_left9_v0}\"\nprintf '%s\\n' \"${ret_trim_left9_v0__4_10}\"", "output": "import * from \"std/text\"\n\n main {\n    echo(trim_left(\"  hello   world  \"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nshopt_enable__159_v0() {\n    local optname_5=\"${1}\"\n    local set_opt_6=\"${2}\"\n    if [ \"${set_opt_6}\" != 0 ]; then\n        shopt -qso \"${optname_5}\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_shopt_enable159_v0=''\n            return \"${__status}\"\n        fi\n    else\n        shopt -qs \"${optname_5}\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_shopt_enable159_v0=''\n            return \"${__status}\"\n        fi\n    fi\n}\n\n# Output\n# hello\n# world\n# *\nshopt_enable__159_v0 \"xpg_echo\" 0\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\necho \"hello\\nworld\"\n__status=$?\nshopt_enable__159_v0 \"noglob\" 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\necho *\n__status=$?", "output": "import { shopt_enable } from \"std/env\"\n\n// Output\n// hello\n// world\n// *\n\nmain {\n   shopt_enable(\"xpg_echo\")?\n   trust $ echo \"hello\\\\nworld\" $\n   shopt_enable(\"noglob\", true)?\n   trust $ echo * $\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nenv_const_set__121_v0() {\n    local name_5=\"${1}\"\n    local val_6=\"${2}\"\n    readonly $name_5=\"$val_6\" 2> /dev/null\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_env_const_set121_v0=''\n        return \"${__status}\"\n    fi\n}\n\nenv_const_set__121_v0 \"test_shell_constant_get\" \"Succeeded\"\n__status=$?\necho \"$test_shell_constant_get\"\n__status=$?", "output": "import * from \"std/env\"\n\nmain {\n    trust env_const_set(\"test_shell_constant_get\", \"Succeeded\")\n    trust $ echo \"\\$test_shell_constant_get\" $\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nis_root__130_v0() {\n    local command_0\n    command_0=\"$(id -u)\"\n    if [ \"$([ \"_${command_0}\" != \"_0\" ]; echo $?)\" != 0 ]; then\n        ret_is_root130_v0=1\n        return 0\n    fi\n    ret_is_root130_v0=0\n    return 0\n}\n\nis_root__130_v0 \nret_is_root130_v0__4_12=\"${ret_is_root130_v0}\"\nif [ \"$(( ! ret_is_root130_v0__4_12 ))\" != 0 ]; then\n    echo \"Succeeded\"\nfi", "output": "import { is_root } from \"std/env\"\n\nmain {\n    if not is_root() {\n        echo(\"Succeeded\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nprintf__131_v0() {\n    local format_11=\"${1}\"\n    local args_12=(\"${!2}\")\n    args_12=(\"${format_11}\" \"${args_12[@]}\")\n    printf \"${args_12[@]}\"\n}\n\necho_error__141_v0() {\n    local message_9=\"${1}\"\n    local exit_code_10=\"${2}\"\n    local array_0=(\"${message_9}\")\n    printf__131_v0 \"\\\\x1b[1;3;97;41m%s\\\\x1b[0m\n\" array_0[@]\n    if [ \"$(( exit_code_10 > 0 ))\" != 0 ]; then\n        exit \"${exit_code_10}\"\n    fi\n}\n\n# Output\n# \u001b[1;3;97;41mHello Amber!\u001b[0m\necho_error__141_v0 \"Hello Amber\"'!'\"\" 0", "output": "import * from \"std/env\"\n\n// Output\n// \u001b[1;3;97;41mHello Amber!\u001b[0m\n\nmain {\n    echo_error(\"Hello Amber!\", 0)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nescaped__132_v0() {\n    local text_7=\"${1}\"\n    ret_escaped132_v0=\"$(printf \"%s\n\" \"$text_7\" | sed -e 's/\\\\/\\\\\\\\/g' -e \"s/%/%%/g\")\"\n    return 0\n}\n\nitalic__135_v0() {\n    local message_6=\"${1}\"\n    escaped__132_v0 \"${message_6}\"\n    local ret_escaped132_v0__268_21=\"${ret_escaped132_v0}\"\n    ret_italic135_v0=\"\\\\x1b[3m${ret_escaped132_v0__268_21}\\\\x1b[0m\"\n    return 0\n}\n\n# Output\n# \\x1b[3mHello Amber!\\x1b[0m\nitalic__135_v0 \"Hello Amber\"'!'\"\"\nret_italic135_v0__7_10=\"${ret_italic135_v0}\"\nprintf '%s\\n' \"${ret_italic135_v0__7_10}\"", "output": "import * from \"std/env\"\n\n// Output\n// \\x1b[3mHello Amber!\\x1b[0m\n\nmain {\n    echo(italic(\"Hello Amber!\"))\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_find_all__1_v0() {\n    local array_16=(\"${!1}\")\n    local value_17=\"${2}\"\n    local result_18=()\n    index_20=0;\n    for element_19 in \"${array_16[@]}\"; do\n        if [ \"$([ \"_${value_17}\" != \"_${element_19}\" ]; echo $?)\" != 0 ]; then\n            result_18+=(\"${index_20}\")\n        fi\n        (( index_20++ )) || true\n    done\n    ret_array_find_all1_v0=(\"${result_18[@]}\")\n    return 0\n}\n\n# Output\n# Indices of \"zero\": [0 6]\n# Indices of \"one\": [1 5]\n# Indices of \"two\": [2 4]\n# Indices of \"three\": [3]\n# Indices of \"four\": []\ntest_search__13_v0() {\n    local data_14=(\"${!1}\")\n    local value_15=\"${2}\"\n    array_find_all__1_v0 data_14[@] \"${value_15}\"\n    local indices_21=(\"${ret_array_find_all1_v0[@]}\")\n    echo \"Indices of \\\"${value_15}\\\": [${indices_21[*]}]\"\n}\n\nnumbers_0=(\"zero\" \"one\" \"two\" \"three\" \"two\" \"one\" \"zero\")\ntest_search__13_v0 numbers_0[@] \"zero\"\ntest_search__13_v0 numbers_0[@] \"one\"\ntest_search__13_v0 numbers_0[@] \"two\"\ntest_search__13_v0 numbers_0[@] \"three\"\ntest_search__13_v0 numbers_0[@] \"four\"", "output": "import { array_find_all } from \"std/array\"\n\n// Output\n// Indices of \"zero\": [0 6]\n// Indices of \"one\": [1 5]\n// Indices of \"two\": [2 4]\n// Indices of \"three\": [3]\n// Indices of \"four\": []\n\nfun test_search(data: [Text], value: Text): Null {\n    const indices = array_find_all(data, value)\n    echo(\"Indices of \\\"{value}\\\": [{indices}]\")\n}\n\nmain {\n    const numbers = [\"zero\", \"one\", \"two\", \"three\", \"two\", \"one\", \"zero\"]\n    test_search(numbers, \"zero\")\n    test_search(numbers, \"one\")\n    test_search(numbers, \"two\")\n    test_search(numbers, \"three\")\n    test_search(numbers, \"four\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nsorted__10_v0() {\n    local array_19=(\"${!1}\")\n    local desc_20=\"${2}\"\n    local version_sort_21=\"${3}\"\n    local __length_0=(\"${array_19[@]}\")\n    if [ \"$(( 0 || $(( ${#__length_0[@]} <= 1 )) ))\" != 0 ]; then\n        ret_sorted10_v0=(\"${array_19[@]}\")\n        return 0\n    fi\n    local desc_flag_22\n    desc_flag_22=\"$(if [ \"${desc_20}\" != 0 ]; then echo \"-r\"; else echo \"\"; fi)\"\n    local sort_flag_23=\"\"\n    if [ \"$(( 1 && version_sort_21 ))\" != 0 ]; then\n        sort_flag_23=\"-V\"\n    fi\n    local result_24=()\n    IFS=\"\n\" read -rd '' -a result_24 < <(printf \"%s\n\" \"${array_19[@]}\" | sort ${sort_flag_23} ${desc_flag_22})\n    ret_sorted10_v0=(\"${result_24[@]}\")\n    return 0\n}\n\nsorted__10_v1() {\n    local array_29=(\"${!1}\")\n    local desc_30=\"${2}\"\n    local version_sort_31=\"${3}\"\n    local __length_2=(\"${array_29[@]}\")\n    if [ \"$(( 0 || $(( ${#__length_2[@]} <= 1 )) ))\" != 0 ]; then\n        ret_sorted10_v1=(\"${array_29[@]}\")\n        return 0\n    fi\n    local desc_flag_32\n    desc_flag_32=\"$(if [ \"${desc_30}\" != 0 ]; then echo \"-r\"; else echo \"\"; fi)\"\n    local sort_flag_33=\"\"\n        sort_flag_33=\"-n\"\n    local result_34=()\n    IFS=\"\n\" read -rd '' -a result_34 < <(printf \"%s\n\" \"${array_29[@]}\" | sort ${sort_flag_33} ${desc_flag_32})\n    ret_sorted10_v1=(\"${result_34[@]}\")\n    return 0\n}\n\nsorted__10_v2() {\n    local array_39=(\"${!1}\")\n    local desc_40=\"${2}\"\n    local version_sort_41=\"${3}\"\n    local __length_4=(\"${array_39[@]}\")\n    if [ \"$(( 0 || $(( ${#__length_4[@]} <= 1 )) ))\" != 0 ]; then\n        ret_sorted10_v2=(\"${array_39[@]}\")\n        return 0\n    fi\n    local desc_flag_42\n    desc_flag_42=\"$(if [ \"${desc_40}\" != 0 ]; then echo \"-r\"; else echo \"\"; fi)\"\n    local sort_flag_43=\"\"\n        sort_flag_43=\"-n\"\n    local result_44=()\n    IFS=\"\n\" read -rd '' -a result_44 < <(printf \"%s\n\" \"${array_39[@]}\" | sort ${sort_flag_43} ${desc_flag_42})\n    ret_sorted10_v2=(\"${result_44[@]}\")\n    return 0\n}\n\nsorted__10_v3() {\n    local array_49=(\"${!1}\")\n    local desc_50=\"${2}\"\n    local version_sort_51=\"${3}\"\n    local __length_6=(\"${array_49[@]}\")\n    if [ \"$(( 0 || $(( ${#__length_6[@]} <= 1 )) ))\" != 0 ]; then\n        ret_sorted10_v3=(\"${array_49[@]}\")\n        return 0\n    fi\n    local desc_flag_52\n    desc_flag_52=\"$(if [ \"${desc_50}\" != 0 ]; then echo \"-r\"; else echo \"\"; fi)\"\n    local sort_flag_53=\"\"\n        sort_flag_53=\"-n\"\n    local result_54=()\n    IFS=\"\n\" read -rd '' -a result_54 < <(printf \"%s\n\" \"${array_49[@]}\" | sort ${sort_flag_53} ${desc_flag_52})\n    ret_sorted10_v3=(\"${result_54[@]}\")\n    return 0\n}\n\nsorted__10_v4() {\n    local array_59=(\"${!1}\")\n    local desc_60=\"${2}\"\n    local version_sort_61=\"${3}\"\n        ret_sorted10_v4=(\"${array_59[@]}\")\n        return 0\n    local desc_flag_62\n    desc_flag_62=\"$(if [ \"${desc_60}\" != 0 ]; then echo \"-r\"; else echo \"\"; fi)\"\n    local sort_flag_63=\"\"\n    local result_64=()\n    IFS=\"\n\" read -rd '' -a result_64 < <(printf \"%s\n\" \"${array_59[@]}\" | sort ${sort_flag_63} ${desc_flag_62})\n    ret_sorted10_v4=(\"${result_64[@]}\")\n    return 0\n}\n\n# Output\n# Array length: 7\n# [-5 1 12 2 a c d]\n# Array length: 7\n# [1 2 12 a c d -5]\n# Array length: 7\n# [d c a 2 12 1 -5]\n# Array length: 4\n# [-2 5 7 10]\n# Array length: 4\n# [10 7 5 -2]\n# Array length: 4\n# [-2 5 7 10]\n# Array length: 4\n# [-5.4 2.34 6.1 11.5]\n# Array length: 4\n# [11.5 6.1 2.34 -5.4]\n# Array length: 2\n# [0 1]\n# Array length: 2\n# [ ]\ntest_sorted__13_v0() {\n    local arr_16=(\"${!1}\")\n    local desc_17=\"${2}\"\n    local version_sort_18=\"${3}\"\n    sorted__10_v0 arr_16[@] \"${desc_17}\" \"${version_sort_18}\"\n    local result_25=(\"${ret_sorted10_v0[@]}\")\n    local __length_9=(\"${result_25[@]}\")\n    echo \"Array length: ${#__length_9[*]}\"\n    echo \"[${result_25[*]}]\"\n}\n\ntest_sorted__13_v1() {\n    local arr_26=(\"${!1}\")\n    local desc_27=\"${2}\"\n    local version_sort_28=\"${3}\"\n    sorted__10_v1 arr_26[@] \"${desc_27}\" \"${version_sort_28}\"\n    local result_35=(\"${ret_sorted10_v1[@]}\")\n    local __length_10=(\"${result_35[@]}\")\n    echo \"Array length: ${#__length_10[*]}\"\n    echo \"[${result_35[*]}]\"\n}\n\ntest_sorted__13_v2() {\n    local arr_36=(\"${!1}\")\n    local desc_37=\"${2}\"\n    local version_sort_38=\"${3}\"\n    sorted__10_v2 arr_36[@] \"${desc_37}\" \"${version_sort_38}\"\n    local result_45=(\"${ret_sorted10_v2[@]}\")\n    local __length_11=(\"${result_45[@]}\")\n    echo \"Array length: ${#__length_11[*]}\"\n    echo \"[${result_45[*]}]\"\n}\n\ntest_sorted__13_v3() {\n    local arr_46=(\"${!1}\")\n    local desc_47=\"${2}\"\n    local version_sort_48=\"${3}\"\n    sorted__10_v3 arr_46[@] \"${desc_47}\" \"${version_sort_48}\"\n    local result_55=(\"${ret_sorted10_v3[@]}\")\n    local __length_12=(\"${result_55[@]}\")\n    echo \"Array length: ${#__length_12[*]}\"\n    echo \"[${result_55[*]}]\"\n}\n\ntest_sorted__13_v4() {\n    local arr_56=(\"${!1}\")\n    local desc_57=\"${2}\"\n    local version_sort_58=\"${3}\"\n    sorted__10_v4 arr_56[@] \"${desc_57}\" \"${version_sort_58}\"\n    local result_65=(\"${ret_sorted10_v4[@]}\")\n    local __length_13=(\"${result_65[@]}\")\n    echo \"Array length: ${#__length_13[*]}\"\n    echo \"[${result_65[*]}]\"\n}\n\narray_15=(\"c\" \"d\" \"a\" \"1\" \"12\" \"2\" \"-5\")\ntest_sorted__13_v0 array_15[@] 0 0\narray_16=(\"c\" \"d\" \"a\" \"1\" \"12\" \"2\" \"-5\")\ntest_sorted__13_v0 array_16[@] 0 1\narray_17=(\"c\" \"d\" \"a\" \"1\" \"12\" \"2\" \"-5\")\ntest_sorted__13_v0 array_17[@] 1 0\narray_18=(7 10 5 -2)\ntest_sorted__13_v1 array_18[@] 0 0\narray_19=(7 10 5 -2)\ntest_sorted__13_v1 array_19[@] 1 0\narray_20=(7 10 5 -2)\ntest_sorted__13_v1 array_20[@] 0 1\narray_21=(11.5 6.1 -5.4 2.34)\ntest_sorted__13_v2 array_21[@] 0 0\narray_22=(11.5 6.1 -5.4 2.34)\ntest_sorted__13_v2 array_22[@] 1 0\narray_23=(1 0)\ntest_sorted__13_v3 array_23[@] 0 0\narray_24=('' '')\ntest_sorted__13_v4 array_24[@] 0 0", "output": "import { sorted } from \"std/array\"\n\n// Output\n// Array length: 7\n// [-5 1 12 2 a c d]\n// Array length: 7\n// [1 2 12 a c d -5]\n// Array length: 7\n// [d c a 2 12 1 -5]\n// Array length: 4\n// [-2 5 7 10]\n// Array length: 4\n// [10 7 5 -2]\n// Array length: 4\n// [-2 5 7 10]\n// Array length: 4\n// [-5.4 2.34 6.1 11.5]\n// Array length: 4\n// [11.5 6.1 2.34 -5.4]\n// Array length: 2\n// [0 1]\n// Array length: 2\n// [ ]\n\nfun test_sorted(arr: [], desc: Bool, version_sort: Bool) {\n    const result = sorted(arr, desc, version_sort)\n    echo(\"Array length: {len(result)}\")\n    echo(\"[{result}]\")\n}\n\nmain {\n    test_sorted([\"c\", \"d\", \"a\", \"1\", \"12\", \"2\", \"-5\"], false, false)\n    test_sorted([\"c\", \"d\", \"a\", \"1\", \"12\", \"2\", \"-5\"], false, true)\n    test_sorted([\"c\", \"d\", \"a\", \"1\", \"12\", \"2\", \"-5\"], true, false)\n    test_sorted([7, 10, 5, -2], false, false)\n    test_sorted([7, 10, 5, -2], true, false)\n    test_sorted([7, 10, 5, -2], false, true)\n    test_sorted([11.5, 6.1, -5.4, 2.34], false, false)\n    test_sorted([11.5, 6.1, -5.4, 2.34], true, false)\n    test_sorted([true, false], false, false)\n    test_sorted([null, null], false, false)\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\ntrim__11_v0() {\n    local text_14=\"${1}\"\n    local result_15=\"\"\n    result_15=\"${text_14#${text_14%%[![:space:]]*}}\"\n    result_15=\"${result_15%${result_15##*[![:space:]]}}\"\n    __status=$?\n    ret_trim11_v0=\"${result_15}\"\n    return 0\n}\n\nfile_exists__42_v0() {\n    local path_28=\"${1}\"\n    [ -f \"${path_28}\" ]\n    __status=$?\n    ret_file_exists42_v0=\"$(( __status == 0 ))\"\n    return 0\n}\n\nis_mac_os_mktemp__48_v0() {\n    # macOS's mktemp does not have --version\n    mktemp --version >/dev/null 2>&1\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_mac_os_mktemp48_v0=1\n        return 0\n    fi\n    ret_is_mac_os_mktemp48_v0=0\n    return 0\n}\n\ntemp_dir_create__49_v0() {\n    local template_11=\"${1}\"\n    local auto_delete_12=\"${2}\"\n    local force_delete_13=\"${3}\"\n    trim__11_v0 \"${template_11}\"\n    local ret_trim11_v0__113_8=\"${ret_trim11_v0}\"\n    if [ \"$([ \"_${ret_trim11_v0__113_8}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"The template cannot be an empty string\"'!'\"\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    local filename_16=\"\"\n    is_mac_os_mktemp__48_v0 \n    local ret_is_mac_os_mktemp48_v0__119_8=\"${ret_is_mac_os_mktemp48_v0}\"\n    if [ \"${ret_is_mac_os_mktemp48_v0__119_8}\" != 0 ]; then\n        # usage: mktemp [-d] [-p tmpdir] [-q] [-t prefix] [-u] template ...\n        # mktemp [-d] [-p tmpdir] [-q] [-u] -t prefix\n        local command_0\n        command_0=\"$(mktemp -d -p \"$TMPDIR\" \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_0}\"\n    else\n        local command_1\n        command_1=\"$(mktemp -d -p \"$TMPDIR\" -t \"${template_11}\")\"\n        __status=$?\n        if [ \"${__status}\" != 0 ]; then\n            ret_temp_dir_create49_v0=''\n            return \"${__status}\"\n        fi\n        filename_16=\"${command_1}\"\n    fi\n    if [ \"$([ \"_${filename_16}\" != \"_\" ]; echo $?)\" != 0 ]; then\n        echo \"Failed to make a temporary directory\"\n        ret_temp_dir_create49_v0=''\n        return 1\n    fi\n    if [ \"${auto_delete_12}\" != 0 ]; then\n        if [ \"${force_delete_13}\" != 0 ]; then\n            trap 'rm -rf '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        else\n            trap 'rmdir '\"${filename_16}\"'' EXIT\n            __status=$?\n            if [ \"${__status}\" != 0 ]; then\n                echo \"Setting auto deletion fails. You must delete temporary dir ${filename_16}.\"\n            fi\n        fi\n    fi\n    ret_temp_dir_create49_v0=\"${filename_16}\"\n    return 0\n}\n\nis_command__125_v0() {\n    local command_26=\"${1}\"\n    [ -x \"$(command -v \"${command_26}\")\" ]\n    __status=$?\n    if [ \"${__status}\" != 0 ]; then\n        ret_is_command125_v0=0\n        return 0\n    fi\n    ret_is_command125_v0=1\n    return 0\n}\n\nfile_download__239_v0() {\n    local url_24=\"${1}\"\n    local path_25=\"${2}\"\n    is_command__125_v0 \"curl\"\n    local ret_is_command125_v0__15_9=\"${ret_is_command125_v0}\"\n    is_command__125_v0 \"wget\"\n    local ret_is_command125_v0__18_9=\"${ret_is_command125_v0}\"\n    is_command__125_v0 \"aria2c\"\n    local ret_is_command125_v0__21_9=\"${ret_is_command125_v0}\"\n    if [ \"${ret_is_command125_v0__15_9}\" != 0 ]; then\n        curl -L -o \"${path_25}\" \"${url_24}\" >/dev/null 2>&1\n        __status=$?\n    elif [ \"${ret_is_command125_v0__18_9}\" != 0 ]; then\n        wget \"${url_24}\" -P \"${path_25}\" >/dev/null 2>&1\n        __status=$?\n    elif [ \"${ret_is_command125_v0__21_9}\" != 0 ]; then\n        aria2c \"${url_24}\" -d \"${path_25}\" >/dev/null 2>&1\n        __status=$?\n    else\n        ret_file_download239_v0=''\n        return 1\n    fi\n}\n\ntemp_dir_create__49_v0 \"amber-XXXX\" 1 1\n__status=$?\nif [ \"${__status}\" != 0 ]; then\n    exit \"${__status}\"\nfi\ntmpdir_17=\"${ret_temp_dir_create49_v0}\"\ncd \"${tmpdir_17}\" || exit\nfile_download__239_v0 \"http://127.0.0.1:8081/\" \"./test.txt\"\n__status=$?\nif [ \"$(( __status == 0 ))\" != 0 ]; then\n    file_exists__42_v0 \"./test.txt\"\n    ret_file_exists42_v0__9_12=\"${ret_file_exists42_v0}\"\n    if [ \"${ret_file_exists42_v0__9_12}\" != 0 ]; then\n        echo \"ok\"\n    fi\nfi", "output": "import * from \"std/http\"\nimport * from \"std/fs\"\n\nmain {\n    const tmpdir = temp_dir_create(\"amber-XXXX\", true, true)?\n    cd(tmpdir)\n    trust file_download(\"http://127.0.0.1:8081/\", \"./test.txt\")\n    if status == 0 {\n        if file_exists(\"./test.txt\") {\n            echo(\"ok\")\n        }\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nuname_kernel_release__145_v0() {\n    ret_uname_kernel_release145_v0=\"$(uname -r)\"\n    return 0\n}\n\nuname_kernel_release__145_v0 \nrelease_3=\"${ret_uname_kernel_release145_v0}\"\n# Should return non-empty kernel release version\nif [ \"$([ \"_${release_3}\" == \"_\" ]; echo $?)\" != 0 ]; then\n    echo \"Succeeded\"\nfi", "output": "import { uname_kernel_release } from \"std/env\"\n\nmain {\n    let release = uname_kernel_release()\n    // Should return non-empty kernel release version\n    if release != \"\" {\n        echo(\"Succeeded\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nuname_nodename__144_v0() {\n    ret_uname_nodename144_v0=\"$(uname -n)\"\n    return 0\n}\n\nuname_nodename__144_v0 \nhostname_3=\"${ret_uname_nodename144_v0}\"\n# Should return non-empty hostname\nif [ \"$([ \"_${hostname_3}\" == \"_\" ]; echo $?)\" != 0 ]; then\n    echo \"Succeeded\"\nfi", "output": "import { uname_nodename } from \"std/env\"\n\nmain {\n    let hostname = uname_nodename()\n    // Should return non-empty hostname\n    if hostname != \"\" {\n        echo(\"Succeeded\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nuname_machine__147_v0() {\n    ret_uname_machine147_v0=\"$(uname -m)\"\n    return 0\n}\n\nuname_machine__147_v0 \narch_3=\"${ret_uname_machine147_v0}\"\n# Should return non-empty string like \"x86_64\" or \"arm64\"\nif [ \"$([ \"_${arch_3}\" == \"_\" ]; echo $?)\" != 0 ]; then\n    echo \"Succeeded\"\nfi", "output": "import { uname_machine } from \"std/env\"\n\nmain {\n    let arch = uname_machine()\n    // Should return non-empty string like \"x86_64\" or \"arm64\"\n    if arch != \"\" {\n        echo(\"Succeeded\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nuname_kernel_name__143_v0() {\n    ret_uname_kernel_name143_v0=\"$(uname -s)\"\n    return 0\n}\n\nuname_kernel_name__143_v0 \nkernel_3=\"${ret_uname_kernel_name143_v0}\"\n# Should return non-empty string like \"Linux\" or \"Darwin\"\nif [ \"$([ \"_${kernel_3}\" == \"_\" ]; echo $?)\" != 0 ]; then\n    echo \"Succeeded\"\nfi", "output": "import { uname_kernel_name } from \"std/env\"\n\nmain {\n    let kernel = uname_kernel_name()\n    // Should return non-empty string like \"Linux\" or \"Darwin\"\n    if kernel != \"\" {\n        echo(\"Succeeded\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\n[ \"$EUID\" -ne 0 ] && { { command -v sudo >/dev/null 2>&1 && __sudo=sudo; } || { command -v doas >/dev/null 2>&1 && __sudo=doas; }; }\n# We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.\n# This is a workaround to avoid that issue and the import system should be improved in the future.\nuname_all__149_v0() {\n    ret_uname_all149_v0=\"$(uname -a)\"\n    return 0\n}\n\nuname_all__149_v0 \ninfo_3=\"${ret_uname_all149_v0}\"\n# Should return non-empty string with full system info\nif [ \"$([ \"_${info_3}\" == \"_\" ]; echo $?)\" != 0 ]; then\n    echo \"Succeeded\"\nfi", "output": "import { uname_all } from \"std/env\"\n\nmain {\n    let info = uname_all()\n    // Should return non-empty string with full system info\n    if info != \"\" {\n        echo(\"Succeeded\")\n    }\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f", "output": "let x = 10\nx += 5\nlet y = 20\ny += 15"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nx_0=20.8\nx_0=\"$(echo \"${x_0}\" '/' 4.2 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\ny_1=35.5\ny_1=\"$(echo \"${y_1}\" '/' 5.0 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"", "output": "let x = 20.8\nx /= 4.2\nlet y = 35.5\ny /= 5.0"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nprintf '%s\\n' \"$(echo 5.5 '*' 3.2 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\nprintf '%s\\n' \"$(echo \"$(echo 2.1 '*' 4.0 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '*' 6.3 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\nprintf '%s\\n' \"$(echo \"$(echo \"$(echo 1.0 '*' 2.5 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '*' 3.1 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '*' 4.7 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"", "output": "echo(5.5 * 3.2)\necho(2.1 * 4.0 * 6.3)\necho(1.0 * 2.5 * 3.1 * 4.7)"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nprintf '%s\\n' \"$(echo 10.5 '/' 2.1 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\nprintf '%s\\n' \"$(echo \"$(echo 20.4 '/' 4.0 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '/' 2.0 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\nprintf '%s\\n' \"$(echo \"$(echo \"$(echo 100.0 '/' 5.0 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '/' 2.5 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '/' 2.0 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"", "output": "echo(10.5 / 2.1)\necho(20.4 / 4.0 / 2.0)\necho(100.0 / 5.0 / 2.5 / 2.0)"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nx_0=20.5\nx_0=\"$(echo \"${x_0}\" '-' 8.2 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\ny_1=50.8\ny_1=\"$(echo \"${y_1}\" '-' 25.3 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"", "output": "let x = 20.5\nx -= 8.2\nlet y = 50.8\ny -= 25.3"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nx_0=10.5\nx_0=\"$(echo \"${x_0}\" '+' 5.2 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\ny_1=20.1\ny_1=\"$(echo \"${y_1}\" '+' 15.7 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"", "output": "let x = 10.5\nx += 5.2\nlet y = 20.1\ny += 15.7"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nx_0=5.5\nx_0=\"$(echo \"${x_0}\" '*' 4.2 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\ny_1=7.1\ny_1=\"$(echo \"${y_1}\" '*' 6.8 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"", "output": "let x = 5.5\nx *= 4.2\nlet y = 7.1\ny *= 6.8"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nprintf '%s\\n' \"$(echo 21.2 '-' 7.3 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\nprintf '%s\\n' \"$(echo \"$(echo 2.32 '-' 1.12 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '-' 3.32 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\nprintf '%s\\n' \"$(echo \"$(echo 1.5 '-' 3.5 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '-' 2.5 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"", "output": "echo(21.2 - 7.3)\necho(2.32 - 1.12 - 3.32)\necho(1.5 - 3.5 - 2.5)"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\narray_0=(1 2 3)\nfor item_0 in \"${array_0[@]}\"; do\n    echo \"Item: ${item_0}\"\ndone\nitems_1=(\"A\" \"B\" \"C\")\narray_2=(1 2 3)\nindex_3=0;\nfor item_2 in \"${array_2[@]}\"; do\n    echo \"Index: ${index_3}, Item: ${item_2}\"\n    echo \"Item from list: ${items_1[${index_3}]}\"\n    (( index_3++ )) || true\ndone", "output": "for item in [1, 2, 3] {\n    echo(\"Item: {item}\")\n}\n\nlet items = [\"A\", \"B\", \"C\"]\n\nfor index, item in [1, 2, 3] {\n    echo(\"Index: {index}, Item: {item}\")\n    echo(\"Item from list: {items[index]}\")\n}"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f", "output": "let x = 20\nx /= 4\nlet y = 35\ny /= 5"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nprintf '%s\\n' \"$(echo 15.15 '+' 45.15 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\nprintf '%s\\n' \"$(echo \"$(echo 39.45 '+' 21.18 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '+' 80.12 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\nprintf '%s\\n' \"$(echo \"$(echo \"$(echo 3.0 '+' 9.0 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '+' 648.0 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '+' 12.23 | bc -l | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"", "output": "echo(15.15 + 45.15)\necho(39.45 + 21.18 + 80.12)\necho(3.0 + 9.0 + 648.0 + 12.23)"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f", "output": "let x = 5\nx *= 4\nlet y = 7\ny *= 6"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\necho \"$(( 10 / 2 ))\"\necho \"$(( $(( 20 / 4 )) / 2 ))\"\necho \"$(( $(( $(( 100 / 5 )) / 2 )) / 2 ))\"", "output": "echo(10 / 2)\necho(20 / 4 / 2)\necho(100 / 5 / 2 / 2)"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f", "output": "let x = 20\nx %= 7\nlet y = 35\ny %= 6"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\necho \"$(( 15 + 45 ))\"\necho \"$(( $(( 39 + 21 )) + 80 ))\"\necho \"$(( $(( $(( 3 + 9 )) + 648 )) + 1232 ))\"", "output": "echo(15 + 45)\necho(39 + 21 + 80)\necho(3 + 9 + 648 + 1232)"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nx_0=20.5\nx_0=\"$(echo \"${x_0}\" '%' 7.2 | bc  | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\ny_1=35.8\ny_1=\"$(echo \"${y_1}\" '%' 6.3 | bc  | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"", "output": "let x = 20.5\nx %= 7.2\nlet y = 35.8\ny %= 6.3"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f", "output": "let x = 20\nx -= 8\nlet y = 50\ny -= 25"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\necho \"$(( 21 - 7 ))\"\necho \"$(( $(( 2 - 1 )) - 3 ))\"\necho \"$(( $(( $(( 1 - 3 )) - 2 )) - 12 ))\"", "output": "echo(21 - 7)\necho(2 - 1 - 3)\necho(1 - 3 - 2 - 12)"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\necho \"$(( 5 * 3 ))\"\necho \"$(( $(( 2 * 4 )) * 6 ))\"\necho \"$(( $(( $(( 1 * 2 )) * 3 )) * 4 ))\"", "output": "echo(5 * 3)\necho(2 * 4 * 6)\necho(1 * 2 * 3 * 4)"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\necho \"$(( 10 % 3 ))\"\necho \"$(( $(( 20 % 6 )) % 3 ))\"\necho \"$(( $(( $(( 100 % 7 )) % 3 )) % 2 ))\"", "output": "echo(10 % 3)\necho(20 % 6 % 3)\necho(100 % 7 % 3 % 2)"}
{"input": "Convert this Bash to Amber: #!/usr/bin/env bash\n# Written in [Amber](https://amber-lang.com/)\n# version: nightly-56-gef85f6f\nprintf '%s\\n' \"$(echo 10.5 '%' 3.2 | bc  | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\nprintf '%s\\n' \"$(echo \"$(echo 20.4 '%' 6.0 | bc  | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '%' 3.1 | bc  | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"\nprintf '%s\\n' \"$(echo \"$(echo \"$(echo 100.0 '%' 7.5 | bc  | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '%' 3.0 | bc  | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\" '%' 2.5 | bc  | sed '/\\./ s/\\.\\{0,1\\}0\\{1,\\}$//')\"", "output": "echo(10.5 % 3.2)\necho(20.4 % 6.0 % 3.1)\necho(100.0 % 7.5 % 3.0 % 2.5)"}
{"input": "Here is the Amber programming language documentation:", "output": "In the subsequent section we will learn more about Amber syntax that is recommended for advanced Amber or Shell Script developers.\n\n\nAs cast is a tool that might initially seem like an easy way to convert types. So, why has this functionality found its place in the advanced category? Well, with great power comes great responsibility. We could perform some casts that make sense, like from `Bool` to `Int`, but we could also perform casts that we refer to as _absurd_. An example of this might be converting `Text` to `Int`.\n\n## Regular Casts\n\nThere might be times when we want to pass a variable that is a `Bool` to a function that accepts `Int`. Since Bool and Int are types that are compatible with each other, we can easily cast one into the other like so:\n\n```ab\nlet isReady = systemIsReady()\nprocessStatus(isReady as Int)\n```\n\n## Absurd Casts\n\nAmber allows us to cast one data type to any other data type. This should be avoided and only used if necessary.\n\n```ab\nlet a = \"12\"\nlet b = a as Int\n```\n\nWe can clearly see that this could lead to some big bugs. For example one could pass `\"abc\"` instead of `\"12\"` in a string which is not a valid value for `Int` type. To convert a string to an integer, it's better to use `parse_int()` function from the [standard library]().\n\n```ab\nimport { parse_int } from \"std/text\"\n\nlet a = \"12\"\nlet b = parse_int(a) failed {\n    echo(\"Variable `a` is not a number.\")\n}\n\necho(b + 12)\n// Outputs: 24\n```\n\n\nBuiltins are native methods (built in the compiler itself) and they are also reserved keywords in Amber.\n\nSimilar to the standard library, they generate valid [Shellcheck](https://www.shellcheck.net/) code (though full support for this in Amber is still in progress).\n\n## Cd\n\nTranspile to `cd` which changes the current directory, requires a `Text` parameter.\n\n```ab\ncd \"/tmp\"\n```\n\n## Echo\n\nTranspile to `echo` which prints text to the console, requires a `Text` parameter.\n\n```ab\necho(\"Hello World!\")\n```\n\n## Len\n\nFor a `Text` value, this builtin calculates and returns the length (in ASCII characters) as a `Num` type.  It is transpiled to `${#TEXT}`:\n\n```ab\n// Returns 37\necho(len(\"Jackdaws love my big sphinx of quartz\"))\n```\n\nFor an `Array` `[]` value, it calculates and returns the length of the array as a `Num` type.  It is transpiled to `${#ARRAY[@]}`:\n\n```ab\n// Returns 5\necho(len([\"one\", \"two\", \"three\", \"four\", \"five\"]))\n```\n\n## Lines\n\nThis builtin reads one line at a time from a text file.  It can be used in place of an array in an iterative `for` loop (with or without an index).  This is efficient because each line is read into memory, and processed before the next line is read:\n\n```ab\nfor line in lines(\"foo.txt\") {\n    echo(line)\n}\n\nfor index, line in lines(\"bar.txt\") {\n    echo(\"#{index} {line}\")\n}\n```\n\nAlternatively, it can be used as the right hand side of an array assignment.  This is inefficient because the entire file is read into memory in one go:\n\n```ab\nlet lines = lines(\"foo.txt\")\nlines += lines(\"bar.txt\")\necho(len(lines))\n```\n\n> WARNING: While embedded Bash commands like `$ cat foo.txt $` require a `trust` keyword or `failed` block, Amber does not currently support this for the `lines` builtin. If the file does not exist at runtime, the program will terminate midway, **potentially losing data stored only in variables**\n\n## Mv\n\nIf we need to move files we can use the `mv` builtin, requires two `Text` parameters.\n*Doesn't support the `mv` unix command parameters*.\n\n```ab\nmv \"/tmp/a\" \"/tmp/b\"\n```\n\nThis builtin is `failable`, meaning we can handle errors like this:\n\n```ab\nmv \"/tmp/a\" \"/tmp/b\" failed {\n    echo(\"Error\")\n}\n```\n\n## Nameof\n\nFor more advanced commands, we might need the name of the variable in the compiled script. The `nameof` keyword provides this functionality.\n\nFor example, this allows us to perform operations like:\n\n```ab\nlet variable = null\n\ntrust $ {nameof variable}=12 $\n// Which is the same as declaring (but it is more readable in this way)\nlet variable = 12\n```\n\n\nCompiler flags enable customization of the compiler\u2019s behavior within the scope of a specific function. These flags are particularly useful for managing edge cases by temporarily relaxing certain restrictions. Below is a list of available compiler flags and their functions:\n- `allow_nested_if_else` - Disables warnings that recommend using specialized [if-chain](/basic_syntax/conditions#if-chain) syntax.\n- `allow_generic_return` - Suppresses warnings that prompt the developer to specify a concrete return type when using arguments with defined types.\n- `allow_absurd_cast` - Turns off warnings about the potential for nonsensical results when using force-type casting, which may result in an [absurd cast](/advanced_syntax/as_cast#absurd-cast).\n\n```ab\n#[allow_nested_if_else]\nfun foo() {\n    // ...\n}\n```\n\n\nSometimes when building generic functions one could find it very convenient to additionally validate if passed value is one of the data types that are supported.\n\n```ab\nfun getObject(value) {\n    if {\n        value is Text: getByName(value)\n        value is Num: getById(value)\n    }\n}\n```\n\n\n# Ranges\n\nAmber gives us the ability to generate an array of numbers `[Num]` of certain range. There are two types of ranges:\n- `a..b` is exclusive from `a` to `b` excluding `b`.\n- `a..=b` is inclusive from `a` to `b` including `b`.\n\n```ab\necho(0..10)\n// Outputs: 0 1 2 3 4 5 6 7 8 9\necho(0..=10)\n// Outputs: 0 1 2 3 4 5 6 7 8 9 10\n```\n\nRanges also support reversed order:\n\n```ab\necho(6..3)\n// Outputs: 6 5 4\necho(6..=3)\n// Outputs: 6 5 4 3\n```\n\n# Arrays {#arrays}\n\nWe learned about array literals in the first chapter. In this chapter we will learn how to make use of them. Arrays are indexed from zero.\n\nTo store or retrieve a value at a particular index of an array, we can use the following syntax:\n\n```ab\nlet groceries = [\"apple\", \"banana\", \"cherry\", \"date\"]\ngroceries[0] = \"kiwi\"\necho(groceries[1])\n// Outputs: banana\n```\n\nWe can also _echo_ an entire array:\n\n```ab\necho(groceries)\n// Outputs: kiwi banana cherry date\n```\n\nTo retrieve a slice between a pair of indices of an array, we can use an exclusive range `a..b` or inclusive range `a..=b` (see above) with the following syntax:\n\n```ab\necho(groceries[1..3])\n// Outputs: banana cherry\necho(groceries[1..=2])\n// Outputs: banana cherry\n```\n\n> WARNING: It is not currently possible to *replace* a slice of an array. This means that we can't evaluate expressions like `groceries[1..=2] = [\"kiwi\"]` yet.\n\nTo add an element to an array, we can use the mentioned in the [expressions chapter](/basic_syntax/expressions) addition operator to merge two arrays together.\n\n```ab\nlet capitals = [\"London\", \"Paris\"]\ncapitals += [\"Warsaw\"]\nlet cities = capitals + [\"Barcelona\", \"Florence\"]\n```\n\nIn order to see more operations on the array data type take a look at the standard library documentation which covers functions such as `join`, `len` or `sum`.\n\n## Destructing arrays\nYou can also easily destruct an array into separate variables:\n```ab\nlet groceries = [\"apple\", \"banana\", \"cherry\"]\n\nlet [fruit1, fruit2, berry] = groceries\n\necho(fruit1 // apple)\necho(fruit2 // banana)\necho(berry // cherry)\n```\n\n## Nested Arrays\n\nWe already learned that Bash does not support nesting arrays. But what makes this limitation? The answer is that under the hood Bash defines arrays that essentially only store structures containing string value. You can learn more about Bash arrays by reading [the official source code](https://git.savannah.gnu.org/cgit/bash.git/tree/array.h).\n\n```c\ntypedef struct array {\n    arrayind_t max_index;\n    arrayind_t num_elements;\n#ifdef ALT_ARRAY_IMPLEMENTATION\n    arrayind_t first_index;\n    arrayind_t alloc_size;\n    struct array_element **elements;\n#else\n    struct array_element *head;\n    struct array_element *lastref;\n#endif\n} ARRAY;\n\ntypedef struct array_element {\n    arrayind_t ind;\n    char *value;\n#ifndef ALT_ARRAY_IMPLEMENTATION\n    struct array_element *next, *prev;\n#endif\n} ARRAY_ELEMENT;\n```\n\n\n> This documentation assumes a foundational understanding of programming concepts.\n\nSince Amber is designed with a syntax inspired by ECMAScript, some aspects of the programming language may appear familiar.\n\n> We suggest to take a look on [the examples](https://docs.amber-lang.com/by_example/examples) we provide to see real use cases written in Amber.\n\nHere, we may notice an echo built-in function, which performs the same operation as Bash\u2019s echo command.\n\nHere is a code snippet that illustrates certain features of Amber. We will provide detailed explanations for each of these features and cover additional content in the forthcoming chapters.\n\n```ab\n// Define variables\nlet name = \"John\"\nlet age = 30\n\n// Display a greeting\necho(\"Hello, my name is {name}\")\n\n// Perform conditional checks\nif age < 18 {\n    echo(\"I'm not an adult yet\")\n} else {\n    echo(\"I'm an adult\")\n}\n\n// Loop through an array\nlet fruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\necho(\"My favorite fruits are:\")\nfor fruit in fruits {\n    echo(fruit)\n}\n```\n\n\n{#silent #trust #unsafe #failed #succeeded #exited}\n\nThe only way to access the bash shell is through Amber's commands. Commands can be used in the form of a statement or an expression.\n\nCommands (as well as *failable functions*) can sometimes _fail_, so it\u2019s important for whoever uses them to be ready to handle what happens next. There are different ways to deal with failures, each with its own pros and cons:\n- `failed` - the recommended way to handle failing that enables you to write some specific logic to run when a command fails\n- `succeeded` - allows you to write specific logic to run when a command completes successfully\n- `exited` - allows you to write logic that runs regardless of whether the command failed or succeeded\n- `?` - this shorthand for propagating the failure to the caller. This operator can only be used in a `main` block or inside of a function.\n- `trust` - the discouraged way to handle failing. This modifier will treat commands as if they have completed successfully and will allow them to be parsed without any further steps.\n\nHere is an example use:\n\n```ab\n// Command statement\n$ mv file.txt dest.txt $ failed {\n    echo(\"It seems that the file.txt does not exist\")\n}\n\n// Command expression\nlet result = $ cat file.txt | grep \"READY\" $ failed {\n    echo(\"Failed to read the file\")\n}\necho(result)\n```\n\n> DETAILS: Command expression result is sent to the variable instead of _standard output_.\n\nCommand can also be interpolated with other expressions and variables\n\n```ab\nlet file_path = \"/path/to/file\"\n$ cat {file_path} $ failed {\n    echo(\"Could not open '{file_path}'\")\n}\n```\n\n### Failed\n\nThe `failed` modifier allows you to write specific logic that runs only when a command fails. This is useful when you want to handle errors gracefully or perform recovery operations. Note that `failed` can optionally accept an exit code parameter, like `failed(code)`, to access the command's exit code.\n\n```ab\n$ cat file.txt $ failed(code) {\n    echo(\"Exited with code {code}.\")\n}\n```\n\n### Succeeded\n\nJust like `failed` allows you to handle command failures, `succeeded` lets you write specific logic that runs only when a command completes successfully. This can be useful when you want to perform additional operations that should only happen if the command succeeds.\n\n```ab\n$ cat file.txt $ succeeded {\n    echo(\"File was read successfully\")\n}\n```\n\n### Exited\n\nThe `exited` modifier allows you to write logic that runs regardless of whether the command failed or succeeded. This is useful when you need to perform cleanup or logging operations that should always happen. Note that `exited` can only be used when an exit code parameter is provided, like `exited(code)`.\n\n```ab\n$ cat file.txt $ exited(code) {\n    echo(\"Command finished with exit code {code}\")\n}\n```\n\n\n## Status\n\nThe `status` keyword allows you to access the exit code of a command. This is the old school and Bash way of handling failures. Its trait is that it holds the exit code of only the previous command or *failable function* call.\n\n```ab\ntrust $ no-access.txt < \"some text\" $ // status: 1\ntrust $ cat available-for-all.txt $ // status: 0\necho(\"The status code is: {status}\" // The status code is 0)\n```\n\n## Failure Propagation\n\nIn order to propagate failure to the context above, you can simply use the question mark syntax `?`.\n\nHere is an example:\n\n```ab\n$ test -d /path/to/file $?\n// Which is the same as\n\n$ test -d /path/to/file $ failed {\n    fail status\n}\n```\n\nTo learn more about fail keyword, please read the article covering [failures](/basic_syntax/functions#failing).\n\n# Command Modifiers\n\nCommand modifier is a keyword that alters the behavior of a command. Here are some examples:\n- `silent` - prevents command from displaying the result to the standard output.\n- `trust` - disables Amber's mechanism that requires user to handle failures.\n\nYou can learn more details about each command modifier in the forthcoming chapters.\n\nHere is the example usage of a command modifier:\n\n```ab\nsilent trust $ my command $\n```\n\nYou can use the command modifiers as modifier scopes. This way you don't have to repeat yourself on multiple commands.\n\n```ab\nsilent trust {\n    $ first command $\n    if isReady:\n            $ second command $\n    $ third command $\n}\n```\n\n## Unsafe Command Execution\n\n```ab\ntrust $ test -d /path/to/file $\n```\n\nThis will be treated the same way Bash treats statements. If it fails, then carry on with the code execution. This behavior is the one that we were trying to avoid when building Amber. The cases when this method is encouraged are the following:\n\n- You are **fully sure** that this command will complete successfully\n- You **do not care** whether the command will fail or not\n\n## Silencing Commands\n\nYou can easily silent given command. Here is an example usage:\n\n```ab\nsilent $ very loud command $\n```\n\n\nThere are three ways to perform conditional logic:\n- **If Statement** - This is a regular if statement that can be used anywhere\n- **If Chain** - This is _syntactical sugar_ for pesky if-else chained together.\n- **Ternary Expression** - This is a way to represent conditional logic within an expression.\n\n## If Statement\n\nThe good old if statement that one may recognize from other modern programming languages:\n\n```ab\nif age >= 16 {\n    echo(\"Welcome\")\n}\n```\n\nLet's add an `else` branch to the mix\n\n```ab\nif age >= 16 {\n    echo(\"Welcome\")\n} else {\n    echo(\"Entry not allowed\")\n}\n```\n\nIn Amber, a simple if condition can often feel unnecessarily bulky. To address this, Amber allows the use of a `:` symbol to replace a full block when you only need to write a single statement. This feature is especially useful for handling multiple conditions with concise, single-statement actions.\n\n```ab\nif age >= 16: echo(\"Welcome\")\nelse: echo(\"Entry not allowed\")\n\n// Or\n\nif age >= 16:\n    echo(\"Welcome\")\nelse:\n    echo(\"Entry not allowed\")\n```\n\n## If Chain\n\nThe if-chain is a streamlined approach for handling a sequence of if-else conditions. Here\u2019s an example to illustrate this concept:\n\n```ab\nif {\n    drink == \"water\" {\n        echo(\"Have a natural, mineralized water\")\n    }\n    drink == \"cola\" {\n        echo(\"Here is your fresh cola\")\n    }\n    else {\n        echo(\"Sorry, we have none of that\")\n    }\n}\n\n// Compact alternative:\n\nif {\n    drink == \"water\": echo(\"Have a natural, mineralized water\")\n    drink == \"cola\": echo(\"Here is your fresh cola\")\n    else: echo(\"Sorry, we have none of that\")\n}\n```\n\nInstead of using the traditional nested if-else structure:\n\n```ab\nif drink == \"water\" {\n    echo(\"Have a natural, mineralized water\")\n} else {\n    if drink == \"cola\" {\n        echo(\"Here is your fresh cola\")\n    } else {\n        echo(\"Sorry, we have none of that\")\n    }\n}\n```\n\nThe if-chain offers a cleaner, more concise, and readable way to handle multiple conditions.\n\n## Ternary Expression {#then}\n\nTernary expressions are ideal for quickly assigning values based on simple conditions. They provide a compact and efficient alternative to traditional conditional statements. Here\u2019s an example:\n\n```ab\nlet candy = count > 1\n    then \"candies\"\n    else \"candy\"\n\necho(\"I have {count} {candy}\")\n```\n\nTo achieve an even more compact form, the ternary expression can be written inline when the expressions involved are concise.\n\n```ab\nlet candy = count > 1 then \"candies\" else \"candy\"\n```\n\nThis approach makes code concise and readable, especially for straightforward conditional assignments.\n\n\nIn Bash there is only one primitive data type, string, which internal implementation is represented by an array of characters `char*`. Amber extends on this data type to introduce a few more.\n\nAmber supports six data types:\n- `Text` - The textual data type. In other programming languages it can also be called \"string\".\n- `Int` - Integer data type.\n- `Num` - The numeric data type. It's basically any number.\n- `Bool` - The boolean data type. It's value can be either `true` or `false`.\n- `Null` - The _nothing_ data type.\n- `[]` - The array data type.\n\n## Text {#text}\n\n`Text` data type is the most basic data type in Amber. It's just a string of characters and is also stored as a string of characters under the hood.\n\nText literal in Amber is contained between double quotes. Amber makes sure to prevent content inside from [globbing](https://en.wikipedia.org/wiki/Glob_%28programming%29). This prevents unexpected behaviors from happening.\n\n```ab\n// `Text` literal:\n\"Welcome to the jungle\"\n```\n\nJust like in other programming languages, characters in `Text` literals can be escaped.\n\n| Escape Sequence | Description |\n| :-------------- | :---------- |\n| `\\n`            | Newline     |\n| `\\t`            | Tab         |\n| `\\r`            | Carriage return |\n| `\\0`            | Null byte   |\n| `\\{`            | Literal `{` |\n| `\\$`            | Literal `$` |\n| `\\'`            | Literal `'` |\n| `\\\"`            | Literal `\"` |\n| `\\\\`            | Literal `\\` |\n\nAny other escape sequence not listed above will be treated as a literal escape sequence, similar to how Bash handles them. For instance, escaping `\\c` will result in the literal `\\c` being output.\n\n## Integer {#int}\n\nUnder the hood its value is stored as a string of characters - the same way as it's done in Bash. However when performing operations the values are treated as 64-bit signed integers.\n\n```ab\n// `Int` data type\n42\n-123\n```\n\nThis data type is the most performant way to compute integers. Later we will discover how `Num` data type can let us compute numbers using floating point arithmetic.\n\n## Number {#num}\n\nSimilarly to `Int` its value is stored as a string of characters. The difference is that Amber applies standard commands to do operations on numbers that support _floating point_ values so that you can simply write operator sign instead.\n\n> WARNING: The `Num` data type currently requires the `bc` command to be installed on your operating system when running compiled Amber code. For portability, it is recommended to use the `Int` data type whenever possible.\n\n```ab\n// `Num` data type\n42.0\n-123.456\n\n// You can implicitly cast `Int` to `Num`\nlet variable = 12.12\n// The variable keeps type of `Num`\nvariable = 24\n```\n\nWe will learn more about variables in the upcoming chapters.\n\n## Boolean {#bool}\n\nBoolean values are translated to `0` or `1` numerical values. These values can be easily [cast](/advanced_syntax/as_cast) to numbers `Num`.\n\n```ab\n// `Bool` data type\ntrue\nfalse\n```\n\n## Null {#null}\n\n```ab\n// `Null` data type\nnull\n```\n\nThe most common use of this data type is to indicate that a function does not return a value. Currently, there is no practical real-world scenario where using a null literal is necessary, as it serves no functional purpose at this time.\n\n## Array {#array}\n\nArrays in Amber and Bash are dynamically allocated. When creating an array literal it is important to specify of which data type the array should be made. Type signature of arrays can be represented with `[T]` where `T` is the value type that this array holds. Example: an array of type `Num` is `[Num]` (in C like languages it would be `Num[]`).\n\nTo create an array literal simply enclose a list of elements separated with a comma `,` with square brackets `[]`.\n\n```ab\n// `[Num]` data type\n[1, 2, 3]\n// `[Text]` data type\n[\"apple\", \"banana\", \"orange\"]\n```\n\n### Array Type Resolution\n\nAmber supports type inference for empty arrays. You can initialize an empty array using `[]` without specifying its type immediately. The type will be resolved later based on how the array is used.\n\n```amber\n// Initializes an empty array with unresolved type\nlet array = [] \n// The type is resolved to [Int] upon this assignment\narray += [1]\n```\n\nIn edge cases, where type inference is not possible or explicit typing is preferred, you can use the type signature to create an explicitly typed empty array.\n\n```ab\n// Example of a value that represents empty array of text\n[Text]\n```\n\n> WARNING: Due to the bash's limitations it's pretty hard to implement 2D+ arrays to behave as regular arrays. As of right now Amber does not support nested arrays\n\n```ab\n[[Bool]]\n// Error: Arrays cannot be nested due to the Bash limitations\n```\n\n## Union Types\n\nUnion types provide a flexible way to define function parameters that can accept values of multiple distinct types. This feature enhances code reusability and polymorphism by allowing a single function to handle different data types safely. Currently, union types are exclusively supported for function parameters. To define a union type, separate the accepted types with a vertical bar (`|`).\n\n### Examples\n\nHere is an example of a function that accepts either an array of Booleans or an array of Integers:\n\n```amber\nfun process_data(data: [Bool] | [Int]) {\n    for item in data {\n        echo(item)\n    }\n}\n\nprocess_data([1, 2, 3])          // Valid\nprocess_data([true, false])      // Valid\n// process_data(\"Invalid\")       // Compile-time Error\n```\n\nYou can also combine primitive types like `Int`, `Text`, and `Bool`:\n\n```amber\nfun print_value(val: Int | Text | Bool) {\n    echo(val)\n}\n\nprint_value(42)       // Valid\nprint_value(\"Amber\")  // Valid\nprint_value(true)     // Valid\n```\n\n\nData type literals can be combined using operators, but these operators only function with values of **the same** data type. For example, attempting to add a `Text` value to a `Num` value will result in an error, as this is an unsupported operation. To combine different types of values into a single text, consider using [string interpolation](/basic_syntax/expressions#text-interpolation) instead.\n\n## Addition Operator `+`\n\nAddition can be performed on number, text and array. This operator applied on different data types yields different results:\n\n- `Int` and `Num` - Arithmetic sum\n- `Text` - String concatenation\n- `[]` - Array join\n\n```ab\n12 + 42 // 54\n\"Hello \" + \"World!\" // \"Hello World!\"\n[1, 2] + [3, 4] // [1, 2, 3, 4]\n```\n\n## Arithmetic Operations\n\nArithmetic operations can only be used on `Int` and `Num` data types. Here is the list of all available ones:\n- `+` Arithmetic sum\n- `-` Substraction\n- `*` Multiplication\n- `/` Division\n- `%` Modulo operation\n\n```ab\n((12 + 34) * 9) % 4\n```\n\nThere is also a unary operator that negates the value stored in [variable](/basic_syntax/variables).\n\n```ab\nlet value = 12\necho(-value) // Outputs: -12\n```\n\n## Comparison Operations\n\nThe equality `==` and inequality `!=` operations can be applied to any data type as long as both sides have the same type.\n\n```ab\n\"foo\" != \"bar\"\n42 == 42\ntrue != false\n\"equal\" == \"equal\"\n```\n\n`Int` and `Num` values are compared using standard arithmetic rules. In contrast, `Text`, `[Text]`, and `[Int]` are compared lexically \u2014 that is, element by element (or character by character), based on Unicode (or ASCII) values, much like string comparison in most programming languages.\n\n```ab\n42 > 24\n\"file1.txt\" > \"file.txt\"\n[42, 12] > [24, 12]\n[\"Hello world\"] > [\"Hello\", \"there\"]\n```\n\nFor sequences of different lengths, comparison continues left to right until a difference is found; if one sequence is a prefix of the other, the shorter one is considered smaller. For example, `\"cat\"` is less than `\"catalog\"`, and `[1, 2]` is less than `[1, 2, 0]`.\n\n## Logical Operations\n\nLogical operations can only be used on `Bool` data type. As opposed to C-like family of programming languages we've chosen to go for more Pythonic approach with literal names instead of symbols, as it suits the nature of the scripting programming language better: `and`, `or`, `not`.\n\n```ab\n18 >= 12 and not false\n```\n\n## Shorthand Operator\n\nThe addition operator, along with any arithmetic operator combined with the `=` symbol, can be used to automatically update the value of an existing variable with the calculated result.\n\n```ab\nlet age = 18\nage += 5\necho(age) // Outputs: 23\n```\n\n## Text Interpolation\n\nText interpolation is a form of embedding various values into the text literal that are combined with their textual representations.\n\n```ab\necho(\"State: {false}\") // Outputs: \"State: 0\"\n// It's possible to also nest interpolation\necho(\"1 {\" 2 {\"3\"} 4\"} 5\") // Outputs: \"1 2 3 4 5\"\n```\n\nIn the following table we can see how the interpolation behaves for various data types:\n\nType  |Description          |Before         |After\n------|---------------------|---------------|---------\n`Text`|Identity             |`\"{\"Text\"}\"`   |`\"Text\"`\n`Num` |Identity             |`\"{12.34}\"`    |`\"12.34\"`\n`Bool`|`1` or `0`           |`\"{true}\"`     |`\"1\"`\n`[]`  |Spaces between values|`\"{[1, 2, 3]}\"`|`\"1 2 3\"`\n\n```ab\nlet name = \"John\"\nlet age = 18\necho(\"Hi, I'm {name}. I'm {age} years old.\")\n// Outputs: Hi, I'm John. I'm 18 years old\n```\n## Lexical Operations\n\nLexical operations allow you to compare sequences element by element (or character by character). These operations work with `Text`, `[Text]`, and `[Int]` data types.\n\n```ab\n\"apple\" < \"banana\" // true - 'a' comes before 'b'\n[\"apple\", \"pie\"] <= [\"banana\", \"bread\"] // true - \"apple\" < \"banana\"\n[5, 1] > [4, 9] // true - 5 is greater than 4\n```\n\n\n{#fun #function}\n\nFunctions can help you organize the structure of your code into reusable components. Here is how you can declare such function:\n\n```ab\nfun myFunction(arg1, arg2) {\n    let result = arg1 + arg2\n    return result\n}\n\necho(myFunction(2, 3))\n// Outputs: 5\necho(myFunction(\"Hello\", \" World\"))\n// Outputs: Hello World\n```\n\nFunction declared in the example above has name `myFunction` and can take two arguments `arg1`, `arg2` of any type.\n\nIf you want to declare a function that takes arguments of certain type - you are encouraged to do this. However, for consistency you are required to specify the return type as well\n\n```ab\nfun myFunction(arg1: Int, arg2: Int): Int {\n    let result = arg1 + arg2\n    return result\n}\n```\n\nAn interesting fact about functions is that they are not parsed unless they are used. This behavior exists because Amber allows you to omit specifying any type at all. When you use such function - then it generates different variants of this function with types that were used (without any duplications).\n\nOn the condition that you specify an argument's type, you can also specify its default value \u2014 it will be used if none other is provided when the function is called:\n\n```ab\nfun addition(a: Int, b: Int = 100): Int {\n    return a + b\n}\n\necho(addition(10)) // Outputs: 110\necho(addition(10, 20)) // Outputs: 30\n```\nNotice that arguments with default values must come after the regular arguments.\n\n## Modifiers\n\nYou can apply [Command Modifiers](/basic_syntax/commands) to function calls as well. This way you can suppress any output with `silent` modifier or run _failable_ functions as if they could never fail (although this is unrecommended) with `trust` keyword\n\n## Failing {#fail}\n\nFunctions can additionally fail. We call them _failable_ functions. A failable function is a type of function that can fail. To fail a function use a `fail` keyword and follow it with exit code.\n\n```ab\nfun failing() {\n    fail 1\n}\n```\n\nHere is another example of a failing function:\n\n```ab\nfun failing(name) {\n    $ command $?\n    parse(name)?\n}\n```\n\nNotice that using `?` operator is automatically failing with the `status` code of the failing operation.\n\nIf you specify the return type of a failable function, you must also append the `?` to the type name.\n\n```ab\nfun failable(): Int? {\n    if 0 > 5 {\n        fail 1\n    }\n\n    return 1\n}\n```\n\nNote that you cannot force a function to become failable by simply appending the `?` to the return type. The `?` can (and must) only be used in a function declaration, if the function is known to be failable.\n\n## Status Code {#status}\n\nStatus code contains information about latest failing function or a command that was run. Accessing status is as simple as using `status` keyword.\n\n```ab\nfun safeDivision(a: Num, b: Num): Num {\n    if b == 0:\n        fail 1\n    return a / b\n}\n```\n\nNow let's see how this code will behave in different scenarios:\n\n```ab\nlet result = trust safeDivision(24, 4)\necho(\"{result}, {status}\")\n// Outputs: 6, 0\n```\nThis was a happy ending. Now let's see what happens when we divide by zero:\n\n```ab\nlet result = safeDivision(15, 0) failed(code) {\n    echo(\"Function failed with code {code}\")\n}\n// Outputs: Function failed with code 1\n```\n\n## Variable References `ref` {#ref}\n\nYou have the ability to accept variables passed by reference. To  do this you can use the `ref` keyword.\n\n```ab\nfun push(ref array, value) {\n    array += [value]\n}\n\nlet groceries = [\"apples\", \"bananas\"]\npush(groceries, \"oranges\")\necho(groceries)\n// Outputs: apples bananas oranges\n```\n\nThe behavior of this keyword is pretty similar to `&` in other C-like programming languages.\n\n## Reserved Prefix\n\nThe Amber compiler reserves all identifiers starting with double underscore `__` in addition to keywords like `let`, `if`, etc.\n\n\n{#import}\n\nIn Amber, functions can be imported from other files. To make a function accessible externally, it must be declared as public in the file where it is defined.\n\n## Public Functions {#pub}\n\nTo declare a function as public we can use a `pub` keyword. Let's keep in mind that `pub` keyword has to be used before the `fun` keyword that declares our function:\n\n```ab\npub fun sum(left: Int, right: Int): Int {\n    return left + right\n}\n```\n\n### Importing from Other Files\n\nIt's possible to import functions individually.\n\n```ab\nimport { foo, bar } from \"./my-file.ab\"\n\nfoo()\nbar()\n```\n\nIt's also possible to import all functions at once.\n\n```ab\nimport * from \"./arith.ab\"\n\necho(sum(1, sub(2, mul(4, 5))))\n```\n\n## Public Imports\n\nThere are situations where we might need to re-export something we\u2019ve imported. Amber makes this straightforward with the following syntax:\n\n```ab\npub import * from \"my/path/file.ab\"\n```\n\nThis statement imports all functions defined in file.ab and re-exports them, making them publicly accessible from the current file.\n\n## Main Block {#main}\n\nIn case when we want a specific code to run only when a file is executed directly, Amber offers a clean and powerful solution. Similar to Python\u2019s approach:\n\n```py\nif __name__ == '__main__':\n    # code to execute\n```\n\nAmber uses a dedicated main scope for this purpose. However, it\u2019s more than just a convenient syntax \u2014 it also provides additional functionality. Within the main block, we can use the `?` operator to propagate exit codes directly to the external shell, simplifying error handling.\n\n```ab\necho(\"Running indirectly\")\n\nmain {\n    $ some command $?\n    echo(\"Running directly\")\n}\n```\n\n> DETAILS: Key features of `main` block:\n- Code outside the main block runs regardless of how the file is executed.\n- Code inside the main block runs only when the file is executed directly.\n- The `?` operator ensures that any exit code from a failable command or function call is automatically passed back to the shell, making it easy to handle script results effectively.\n\nNow if we run this file the output will look like this:\n```\nRunning indirectly\nRunning directly\n```\n\nHere is the behavior when we import the file instead.\n\n```ab\nimport * from \"./file.ab\"\n// Outputs: Running indirectly\n```\n\n\n### Main Block and External Arguments {#args}\n\nMain block can provide an array of arguments (that is of type `[Text]`) passed to this script.\n\n```ab\nmain (args) {\n    for i, arg in args {\n        echo(\"{i}: {arg}\")\n    }\n}\n```\n\n\nAmber supports three types of loop:\n- **Infinite** loop that can only be broken with a `break` keyword\n- **Iterator** loop that iterates over an array\n- **While** loop that runs as long as a condition is true\n\nWithin loops, the `break` and `continue` keywords can be used to control the flow of execution effectively.\n\n## Infinite Loop {#loop}\n\nAn infinite loop executes its code repeatedly without end until a `break` statement is used to exit the loop.\n\n```ab\nlet i = 0\nlet sum = 0\nloop {\n    if i == 5:\n        break\n    i += 1\n    sum += i\n}\necho(sum)\n// Outputs: 15\n```\n\n## Iterator Loop {#for}\n\nIt's the most encouraged way to iterate over an array. The example in the previous chapter can be rewritten to a more concise version:\n\n```ab\nlet sum = 0\nfor i in 0..5 {\n    sum += i\n}\necho(sum)\n// Outputs: 10\n```\n\nHere is another example showing iterator loop in action:\n\n```ab\nlet files = [\"config.json\", \"file.txt\", \"audio.mp3\"]\n\nfor index, file in files {\n    $ mv {file} {index}{file} $ failed {\n        echo(\"Failed to rename {file}\")\n    }\n}\n```\n\nThe above example will iterate through all the files in the array and index them according to their order in the array. As a result, these files will be renamed to `0config.json`, `1file.txt`, and `2audio.mp3`.\n\n## While Loop {#while}\n\nThe `while` loop is used to repeat a block of code as long as a condition is true. It's most powerful in situations where the number of iterations is not easily known beforehand.\n\n```ab\nlet number = 1\n\nwhile number < 100 {\n    echo(number)\n    number *= 2\n}\n// Outputs:\n// 1\n// 2\n// 4\n// 8\n// 16\n// 32\n// 64\n```\n\n\n{#let}\n\nVariables are the way to store values we discussed earlier. In order to create a variable you can use a `let` keyword. Here is an example:\n\n```ab\nlet name = \"John\"\n```\n\nThe above example shows how to initialize a variable. However if you have already created the one you want, you can reassign it just by name (without using any keywords)\n\n```ab\nname = \"Rob\"\n```\n\nAnd to access the value stored by this variable - just refer to it by name, like so:\n\n```ab\necho(name) // Outputs: \"Rob\"\n```\n\n> WARNING: The Amber compiler reserves all identifiers starting with double underscore `__` in addition to keywords like `let`, `if`, etc.\n\n## Overshadowing\n\nVariable declarations in Amber can be overshadowed, allowing the redeclaration of an existing variable with a different data type within a specific scope if necessary. Here\u2019s an example:\n\n```ab\n// `result` is a `Num`\nlet result = 123\n// `result` is a `Text`\nlet result = \"Hello my friend\"\n```\n\n# Constant {#const}\n\nConstant is a type of variable that cannot be modified.\n\n```ab\nconst sunrise = \"east\"\nsunrise = \"west\" // ERROR: Cannot reassign constant 'sunrise'\n```\n\n\nThis script demonstrates an automated backup rotation system that keeps only the most recent backups while deleting older ones.\n\n```ab\nimport { dir_exists, dir_create, file_exists } from \"std/fs\"\nimport { parse_int, trim } from \"std/text\"\nimport { date_now, date_format_posix } from \"std/date\"\n\nfun get_backup_count(backup_dir: Text): Int? {\n    let count_output = trust $ ls -1 \"{backup_dir}\" | wc -l $\n    return parse_int(trim(count_output))?\n}\n\nfun create_backup(source: Text, backup_dir: Text): Int? {\n    let timestamp = date_format_posix(date_now())?\n    let backup_name = \"backup_{timestamp}.tar.gz\"\n\n    echo(\"Creating backup: {backup_name}\")\n    sudo $ tar -czf \"{backup_dir}/{backup_name}\" \"{source}\" $?\n\n    echo(\"Backup created successfully\")\n    return 0\n}\n\nfun rotate_backups(backup_dir: Text, max_backups: Int) {\n    let current_count = get_backup_count(backup_dir)?\n    echo(\"Current backup count: {current_count}\")\n\n    // Remove old backups while we have too many\n    while current_count > max_backups {\n        echo(\"Removing oldest backup (count: {current_count}/{max_backups})\")\n\n        // Get the oldest backup file\n        let oldest = trust $ ls -1t \"{backup_dir}\" | tail -n 1 $\n\n        sudo $ rm \"{backup_dir}/{oldest}\" $ succeeded {\n            echo(\"Removed: {oldest}\")\n        }\n        current_count = get_backup_count(backup_dir)?\n    }\n    echo(\"Backup rotation complete. Keeping {current_count} backups.\")\n}\n\nmain(args) {\n    if len(args) < 2 {\n        echo(\"Usage: backup-rotator <source_dir> <backup_dir> [max_backups]\")\n        echo(\"Example: backup-rotator /var/www /backups 5\")\n        exit(1)\n    }\n\n    let source_dir = args[0]\n    let backup_dir = args[1]\n    let max_backups = len(args) >= 3\n        then parse_int(args[2])?\n        else 5\n\n    // Validate source directory\n    if not dir_exists(source_dir) {\n        echo(\"Error: Source directory '{source_dir}' does not exist\")\n        exit(1)\n    }\n\n    // Create backup directory if it doesn't exist\n    if not dir_exists(backup_dir) {\n        echo(\"Creating backup directory: {backup_dir}\")\n        sudo dir_create(backup_dir) failed {\n            echo(\"Failed to create backup directory\")\n            exit(1)\n        }\n    }\n\n    // Create new backup\n    create_backup(source_dir, backup_dir)?\n\n    // Rotate old backups\n    rotate_backups(backup_dir, max_backups)?\n}\n```\n\n\nThis script is meant for periodic execution and must be run as root. It scans an Nginx webserver log file for large volumes of requests from automated bots not identifying themselves as bots. If a bad bot makes more than 1000 requests per hour then the IP address is added to a blocklist file that can be picked up by firewall block software such as ipset.\n\n```ab\n// Script for detecting unwanted bots on our sites and blocking their IPs.\n// Usage: ./bot-detector.sh <LOG_FILE_PATH>\n// The script is triggered by a cronjob every 10 minutes.\n\nimport * from \"std/text\"\n\nmain (args) {\n    if len(args) < 1 {\n        echo(\"Path to log file missing.\")\n        echo(\"Usage: bot-detector.sh <logfile>\")\n        echo(\"       bot-detector.sh /var/log/nginx/access.log\")\n        exit(1)\n    }\n\n    let logfile = args[0]\n    $ test -r {logfile} $ failed {\n        echo(\"File not found or not readable: {logfile}\")\n        exit(1)\n    }\n\n    let start = parse_int($ date +%s $?)?\n\n    // Get server IP address for excluding.\n    let server_ip = $ hostname -i $?\n\n    // We want to check the previous hour and the current hour.\n    let timeframes = [\"1 hour ago\", \"now\"]\n    for timeframe in timeframes {\n        if timeframe == \"1 hour ago\" {\n            echo(\"Checking the previous hour...\")\n        } else {\n            echo(\"Checking the current hour...\")\n        }\n\n        let hour_timestamp = $ date \"+%d/%b/%Y:%H\" -d \"{timeframe}\" $?\n        // Get the top 20 IP addresses that accessed job pages for the given hour\n        // timestamp. Includes a count per IP address in the format: \"<count> <ip>\".\n        // Only check GET requests to certain job-related paths.\n        // Ignore requests from well-behaved bots that send a bot user agent.\n        // Never block requests from Google in the user agent.\n        // Exclude requests to /files/ paths.\n        // Check the top 20 results.\n        let ip_log = trust $ grep -e \"{hour_timestamp}\" \"{logfile}\" | \\\n            grep \\\n                -e \"GET /job/\" \\\n                -e \"GET /jobs/\" \\\n                -e \"GET /stelle/\" \\\n                -e \"GET /stellen/\" \\\n                -e \"GET /stellenangebot/\" \\\n                -e \"GET /de/stelle/\" \\\n                -e \"GET /de/stellen/\" \\\n                -e \"GET /de/stellenangebot/\" | \\\n            grep -i -v \"bot\" | \\\n            grep -v \"Google\" | \\\n            grep -v /files/ | \\\n            awk '\\{print \\$1}' | sort | uniq -c | sort -nr | \\\n            grep -v \"{server_ip}\" | \\\n            head -n 20 $\n\n        for line in lines(ip_log) {\n            let parts = split(line, \" \")\n            let count = parse_int(parts[0])?\n            // Skip IP addresses that sent less than 1000 requests.\n            if count < 1000 {\n                continue\n            }\n\n            let ip = parts[1]\n            trust $ grep \"{ip}\" /etc/ipblocklist.txt $ succeeded {\n                echo(\"IP address {ip} is already blocked.\")\n                continue\n            }\n            trust $ grep \"{ip}\" /etc/ipexcludedlist.txt $ succeeded {\n                echo(\"IP address {ip} is allow-listed and will not be blocked.\")\n                continue\n            }\n            echo(\"Blocking IP address: {ip} ({count} requests)\")\n            $ echo \"{ip}\" >> /etc/ipblocklist.txt $?\n            $ echo \"\\$(date) | IP addess {ip} added to the block list, RPH={count}\" >> /var/log/bot-detector.log $?\n        }\n    }\n    let end = parse_int($ date +%s $?)?\n    let duration = end - start\n    echo(\"Execution time: {duration} seconds\")\n}\n```\n\n\n> WARNING: Experimental standard library is used here. The full documentation covering it will be created soon as it get's more stable.\n\nHere, you\u2019ll find a collection of practical scripts designed to help you quickly grasp the fundamentals and advanced features of the Amber programming language. Whether you are new to programming or an experienced developer, these examples will guide you through.\n\n\nThis script automates the installation of several Language Server Protocol (LSP) tools, primarily by downloading them from GitHub and installing them on your system. The latest version of the script (and also **complete**) can be found [here](https://github.com/Mte90/My-Scripts/blob/master/dev/lsp-installer/install.ab).\n\n> The script uses standard library functions to simplify the process of downloading, unpacking, and installing various LSP tools. It checks for necessary permissions, downloads the latest releases of selected LSPs, moves them to system directories, makes them executable, and installs additional LSPs using `npm`, `pip`, and `gem` as needed.\n> For each tool, if the download or installation fails, an error message is displayed, and the script exits to prevent partial installations.\n\n```ab\nimport { dir_exists, file_chmod, symlink_create } from \"std/fs\"\nimport { file_download } from \"std/http\"\nimport { is_root } from \"std/env\"\nimport { text_contains } from \"std/text\"\n\nif not is_root() {\n    echo(\"This script requires root permissions!\")\n    exit(1)\n}\n\nfun get_download_path(repo, position) {\n    return trust $ curl -sL \"https://api.github.com/repos/{repo}/releases\" | jq -r \".[0].assets.[{position}].browser_download_url\" $\n}\n\nfun move_to_bin(download_url, binary) {\n    file_download(download_url, binary) failed {\n        echo(\"Download for {binary} at {download_url} failed\")\n        exit(1)\n    }\n    \n    mv binary \"/usr/local/bin\" failed {\n        echo(\"Move {binary} to /usr/local/bin failed!\")\n        exit(1)\n    }\n    \n    file_chmod(\"/usr/local/bin/{binary}\", \"+x\") failed {\n        echo(\"Failed to make {binary} executable\")\n        exit(1)\n    }\n}\n\nfun download_to_bin(download_url, binary, packed_file) {\n    file_download(download_url, packed_file) failed {\n        echo(\"Download for {binary} at {download_url} failed\")\n        exit(1)\n    }\n    \n    trust {\n        if text_contains(\"tar.gz\", packed_file) {\n            $ tar -zxvf \"./{packed_file}\" -C ./ > /dev/null 2>&1 $\n            trust mv \"./{binary}\" \"/usr/local/bin\"\n        } else {\n            $ gunzip -c - > \"/usr/local/bin/{binary}\" $\n        }\n        $ rm \"./{packed_file}\" $\n    }\n    \n    file_chmod(\"/usr/local/bin/{binary}\", \"+x\") failed {\n        echo(\"Failed to make {binary} executable\")\n        exit(1)\n    }\n}\n\ncd(\"/tmp\")\n\necho(\"Install Typos LSP\")\ndownload_to_bin(get_download_path(\"tekumara/typos-lsp\", 6), \"typos-lsp\", \"typos.tar.gz\")\n\necho(\"Install Rust LSP\")\ndownload_to_bin(\"https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz\", \"rust-analyzer\", \"rust-analyzer-x86_64-unknown-linux-gnu.gz\")\n\necho(\"Install Lua LSP\")\nif not dir_exists(\"/opt/lua-language-server\") {\n    cd(\"/opt/\")\n    trust $ git clone https://github.com/LuaLS/lua-language-server $\n} else {\n    cd \"/opt/lua-language-server\"\n}\nsilent trust {\n    cd \"lua-language-server\"\n    $ git pull $\n    $ ./make.sh $\n}\nsymlink_create(\"/opt/lua-language-server/bin/lua-language-server\", \"/usr/local/bin/lua-language-server\") failed {\n    echo(\"Failed to create symlink for lua-language-server\")\n    exit(1)\n}\n\ncd \"/tmp\"\n\nlet npm_lsp = [\"vscode-langservers-extracted\", \"@tailwindcss/language-server\", \"@olrtg/emmet-language-server\", \"intelephense\", \"bash-language-server\"]\nlet npm_lsp_name = [\"CSS, HTML, JSON LSP\", \"Tailwind LSP\", \"Emmet LSP\", \"Intelephense LSP\", \"Bash LSP\"]\nfor index, lsp in npm_lsp {\n    echo(\"Install {npm_lsp_name[index]}\")\n    $ npm i -g \"{lsp}\" $ failed(code) {\n        echo(\"Error! Exit code: {code}\")\n    }\n}\n```\n\n\nThis script is used within the project to automate the process of identifying any ShellCheck validation issues in our test cases after they are compiled to Bash scripts.\n\n> The script loops through all files in the Amber project's standard library test folder (`src/tests/stdlib/`), compiles each test to a Bash script, and then runs ShellCheck on the resulting script.\n> If ShellCheck detects any issues (i.e., returns a non-zero exit code), the script generates a `.txt` report detailing the problems found. This report is stored in a designated temporary directory (`/tmp/amber-sc-tests`).\n\n```ab\nimport { split, text_contains } from \"std/text\"\nimport { file_write, file_append, dir_exists, file_exists, dir_create } from \"std/fs\"\n\nlet path = \"/tmp/amber-sc-tests\"\n\nif (not dir_exists(path)) {\n    dir_create(path) failed {\n        echo(\"Failed to create directory {path}\")\n        exit(1)\n    }\n}\ntrust $ cp -r \"src/tests/stdlib/\" {path} $\nlet report = \"{path}/report.txt\"\nfile_write(report, \"Report for Shellcheck\") failed {\n    echo(\"Failed to write report file\")\n    exit(1)\n}\nlet output = \"\"\n\nlet stdtests = trust $ /usr/bin/ls \"src/tests/stdlib/\" $\nlet stdlib = split(stdtests, \"\\n\")\n\nfor v in stdlib {\n    if not text_contains(v, \".txt\") and file_exists(\"src/tests/stdlib/{v}\") {\n        echo(\"Generating Bash script for test {v}\")\n        trust $ ./target/debug/amber build \"src/tests/stdlib/{v}\" \"{path}/{v}.sh\" $\n        \n        $ shellcheck \"{path}/{v}.sh\" $ exited(code) {\n            if code != 0 {\n                echo(\"Shellcheck found something!\")\n                file_append(report, \"\\n--- Issues in {v} ---\\n\") failed {\n                    echo(\"Failed to append to report\")\n                }\n            }\n        }\n    }\n}\n```\n\n\nHere is an example script to periodically install software updates on an Ubuntu system. The update commands are wrapped in a `main` block, so that all commands between `$` signs can pass up errors with the `?` operator. The script will stop in that case and not execute any further commands.\n\n> As you can see, the Amber code currently looks as if it is intertwined with bash commands. As development progresses, executing custom commands will be even better integrated with special syntax and improved runtime safety features to aid this process.\n\n```ab\nimport { date_now, date_format_posix } from \"std/date\"\n\nmain {\n    // Print output and log it at the same time.\n    $ exec > >(tee -a /var/log/autoapt.log) 2>&1 $?\n    // Log the current date so that we can check when any failed runs happened.\n    echo(date_format_posix(date_now()))\n\n    // Internet is slow on Austrian trains. Check the Wifi SSID and stop in that\n    // case.\n    trust $ iwgetid -r | grep -E '(OEBB|WESTlan)' $ succeeded {\n        echo(\"Skipping updates because of slow Wifi\")\n        exit 0\n    }\n\n    $ export DEBIAN_FRONTEND=noninteractive $?\n    $ apt update $?\n    // By default answer all user interaction questions with yes, for example\n    // for debconf.\n    // Use the old configuration file when new config files arrive.\n    // Also say yes to setting up config files.\n    $ yes '' | apt \\\n        -o Dpkg::Options::=--force-confold \\\n        -o Dpkg::Options::=--force-confdef \\\n        -y --allow-downgrades --allow-remove-essential \\\n        --allow-change-held-packages \\\n        upgrade $?\n    // Clean up any packages that are not needed anymore.\n    $ apt autoremove -y $?\n    // Also update Snap packages.\n    $ snap refresh --color=never --unicode=never $?\n}\n```\n\n\nThe Amber compiler follows a standard compilation pipeline to transform Amber source code into Bash scripts.\n\n```mermaid\nflowchart LR\n    Lexer --> Parser\n    Parser --> TypeCheck[Type Checker]\n    TypeCheck --> Translator\n    Translator --> Optimizer\n    Optimizer --> Renderer\n```\n\n1.  **Lexer**: Transforms source code text into a stream of tokens (Keywords, Operators, Identifiers, etc.).\n2.  **Parser**: Consumes tokens to build an Abstract Syntax Tree (AST), representing the code structure.\n3.  **Type Checker**: Traverses the AST to validate types, ensure safety, and infer missing type information.\n4.  **Translator**: Converts the typed AST into an intermediate representation called `FragmentKind` (Lower IR).\n5.  **Optimizer**: Performs optimizations on the intermediate representation.\n6.  **Renderer**: Converts the final IR into the target Bash string.\n\nHere you will find out how the compiler is structured, how the parser works and how to write new syntax modules. Let's begin!\n\n## Lexer\n\nBeforehand the code is transformed into an array of tokens that contain information about:\n- `word` - the token content\n- `pos` - the token location in the document (row, column)\n- `start` - the index in the code string where the token starts\n\n```rs\nstruct Token {\n    word: String,\n    pos: (usize, usize),\n    start: usize\n}\n```\n\nTokens are created with lexical rules that are contained in the [src/rules.rs](https://github.com/amber-lang/amber/blob/master/src/rules.rs) file.\n\nHere is the example of how an array of Amber tokens can look like, where strings represent instances of `Token`:\n```js\n[Token<\"let\">, Token<\"is_alive\">, Token<\"=\">, Token<\"true\">, ...]\n```\n\n## Parser\n\nParser takes in Tokens and forms an Abstract Syntax Tree that represents the code written in Amber.\n\n### Syntax Module\n\nWhat transforms tokens into the AST (Abstract Syntax Tree) is a `SyntaxModule`. It can be a `Text` literal, `echo` builtin or `Add` operator. The `SyntaxModule` is a trait that implements:\n- `parse` method that parses the module and determines whether or not the corresponding token string represents this sytax module. If otherwise, then a `Failure::Quiet` is returned that means that this is not the correct module to parse the tokens. However if this is the correct module but an error is encountered, then `Failure::Loud` is returned with an error (or warning / info) is returned.\n- `new` method that instantiates a new SyntaxModule.\n- `syntax_name!(\"<name of this module>\")` that identifies this syntax module with its name.\n\nThe most important method here is `parse` that is defined with the following signature:\n\n```rs\nfn parse(&mut self, meta: &mut M) where M: Metadata -> SyntaxResult;\n```\n\nParsing returns a `SyntaxResult` that under the hood is represented as `Result<(), Failure>`. It means that parsing can be finished successfully or it can fail returning a `Failure` object.\n\nHere is an example `SyntaxModule` that parses `Bool` literal:\n```rs\nimpl SyntaxModule<ParserMetadata> for Bool {\n    syntax_name!(\"Bool\");\n\n    fn new() -> Self {\n        Bool {\n            value: false\n        }\n    }\n\n    fn parse(&mut self, meta: &mut ParserMetadata) -> SyntaxResult {\n        let value = token_by(meta, |value| [\"true\", \"false\"].contains(&value.as_str()))?;\n        self.value = value == \"true\";\n        Ok(())\n    }\n}\n```\n\n### Metadata\n\nYou can see that in the `parse` method mentioned above we pass some object called `meta`. This is a metadata parameter of type `ParserMetadata` that inherits from `Metadata` provided by Heraclitus. The structure instance is carried through the parsing process to keep a track of current state. It holds information such as declared variables, functions, boolean parameters telling if current context is within a loop or a function etc. `ParserMetadata` is represented as:\n\n```rs\nstruct ParserMetadata {\n    // Parsing contenxt\n    pub context: Context\n    // Error / Warning messages\n    pub messages: Vec<Message>\n    // ...\n}\n```\n\nYou can find out more about this structure in [src/utils/metadata/parser.rs](https://github.com/amber-lang/amber/blob/master/src/utils/metadata/parser.rs) file.\n\n### Parsing Flow\n\nThe journey starts with parsing the global `Block` that can be located in [src/modules/block.rs](https://github.com/amber-lang/amber/blob/master/src/modules/block.rs) file. The `Block` parses a sequence of statements (`Statement` located in [src/modules/statement/stmt.rs](https://github.com/amber-lang/amber/blob/master/src/modules/statement/stmt.rs)).\n\n#### Statement\n\nStatement (`Statement`) is a structure that can represent any `SyntaxModule` that is of statement type. In other words Statement is a wrapper for syntax modules that represents a statement type such as loop, if condition, variable declaration etc.\n\n```rs\nstruct Statement {\n    value: Option<StmtType>\n}\n```\n\nHere we can see that the `value` field accepts `StmtType` enum that is declared above and represents a syntax module.\n\n```rs\nenum StmtType {\n    Expr(Expr),\n    VariableInit(VariableInit),\n    VariableSet(VariableSet),\n    IfCondition(IfCondition),\n    // ...\n}\n```\n\nStatement is built of a macro `parse_statement!` that can be located in [src/modules/statement/stmt.rs](https://github.com/amber-lang/amber/blob/master/src/modules/statement/stmt.rs). The syntax modules provided to the macro are parsed sequentially in the order from top to bottom. This means that the parser will first try to match `Import` and then `FunctionDeclaration`. The expression  (`Expr` located in [src/modules/expression/expr.rs](https://github.com/amber-lang/amber/blob/master/src/modules/expression/expr.rs)) is passed as the final parameter to the `parse_statement!` macro so that it's parsed at the very end.\n\n```rs\nparse_statement!([\n    Import,\n    FunctionDeclaration,\n    // ...\n    Expr\n], ...);\n```\n\nThis macro iterates through the provided syntax modules and attempts to parse them one by one. If a module successfully parses the code, the loop breaks and the result is returned.\n\nThe `StatementDispatch` derive macro is used on the `StmtType` enum to automatically generate dispatch methods for traits like `TranslateModule`, `TypeCheckModule`, etc. preventing the need to verify matches manually.\n\n#### Expr\n\nExpression (`Expr` located in [src/modules/expression/expr.rs](https://github.com/amber-lang/amber/blob/master/src/modules/expression/expr.rs)) represents a syntax that is a value of certain type (also referred to as _kind_ because of the Rust's type keyword). For example `1 + 1` is an addition of type `Num`.\n\n```rs\nstruct Expr {\n    // The value of the expression\n    value: Option<ExprType>,\n    // The type of the expression\n    kind: Type,\n    // The position of the expression\n    position: Option<PositionInfo>\n}\n```\n\nAnalogically to `Statement`, expression also is a wrapper for syntax modules that are of expression type. Instead of `StmtType` enum `ExprType` is declared.\n\n```rs\nenum ExprType {\n    Bool(Bool),\n    Number(Number),\n    Text(Text),\n    Add(Add),\n    Sub(Sub),\n    // ...\n}\n```\n\nSince certain expressions require different approaches to parsing, there is a different macro used here to automate the process. There are a couple of different types of expressions:\n- `TernOp` - a ternary operator that is parsed from right to left. It's used for conditional ternary operator.\n- `BinOp` - a binary operator that is parsed from left to right.\n- `UnOp` - a unary operator that is parsed from left to right, where the symbol expression is on the left side.\n- `TypeOp` - a binary expression that is represented as expression followed by operator and then a type. Example of such operator is a cast operator: `12 as Bool`.\n- `Literal` - a Literal that doesn't have any directional precedence. Literal is the final group of expression precedence.\n\nThe hierarchy of the groups is represented within the `parse_expression!` macro (defined in [src/modules/expression/macros.rs](https://github.com/amber-lang/amber/blob/master/src/modules/expression/macros.rs)). It returns an Expr` that has been parsed.\n\nbegin[details] How exactly does parsing expressions work?\n\n```rs\nlet result = parse_expression!(meta, [\n    ternary @ TernOp => [ Ternary ],\n    range @ BinOp => [ Range ],\n    addition @ BinOp => [ Add, Sub ],\n    multiplication @ BinOp => [ Mul, Div, Modulo ],\n    types @ TypeOp => [ Is, Cast ],\n    unops @ UnOp => [ Neg, Not ],\n    literals @ Literal => [ Bool, Number, Text ]\n]);\n```\n\nThe pattern that the macro follows can be represented as `<function_group_name> @ <group_type> => [<syntax_modules>]`. The macro is declared as a recurrent relation of functions (groups) that are calling each other (inside of an internal macro `parse_expr_group!`).\n\n```rs\nlet result = {\n    fn _terminal(...) {\n        panic!(\"Please end the recurrence in the group before\");\n    }\n\n    fn literal(...) {\n        parse_expr_group!(... {literal, _terminal} ...);\n    }\n\n    // ...\n\n    fn range(...) {\n        parse_expr_group!(... {range, addition} ...);\n    }\n\n    fn ternary(...) {\n        parse_expr_group!(... {ternary, range} ...);\n    }\n\n    return ternary(...);\n};\n```\n\nThe main objective of `parse_expr_group!` is to implement given function's body with appropriate parsing mechanism. If it's a `BinOp` that parses from left to right, then first we parse left expression by calling the lower order group, then we parse the operator, and then the right expression. You can read more on how parsing groups works in the macros file.\n\nend[details]\n\n### Type Checking\n\nAfter the parsing phase is completed, the Compiler performs a Type Check that validates types of variables and expressions. This logic is contained within the `TypeCheckModule` trait located in [src/modules/typecheck.rs](https://github.com/amber-lang/amber/blob/master/src/modules/typecheck.rs).\n\n```rs\npub trait TypeCheckModule {\n    fn typecheck(&mut self, meta: &mut ParserMetadata) -> SyntaxResult;\n}\n```\n\nThis method is called after parsing but before translation. It allows the module to infer types, check for type mismatches, and mutate the module state (e.g. storing the inferred type) using the `ParserMetadata`.\n\n### Translation\n\nThe next step is translating the AST into an Intermediate Representation (Fragments) which is structurally closer to the target language (Bash). This is handled by the `TranslateModule` trait located in [src/translate/module.rs](https://github.com/amber-lang/amber/blob/main/src/translate/module.rs).\n\n```rs\npub trait TranslateModule {\n    fn translate(&self, meta: &mut TranslateMetadata) -> FragmentKind;\n}\n```\n\nThis method takes `TranslateMetadata` and transforms the module into a `FragmentKind`.\n\n### FragmentKind\n\n`FragmentKind` is a crucial enum that represents a piece of generated code. It serves as an intermediate representation that abstracts over different types of Bash constructs before they are rendered into the final string. It is defined in [src/translate/fragments/fragment.rs](https://github.com/amber-lang/amber/blob/main/src/translate/fragments/fragment.rs).\n\n```rs\npub enum FragmentKind {\n    Raw(RawFragment),\n    VarExpr(VarExprFragment),\n    VarStmt(VarStmtFragment),\n    Block(BlockFragment),\n    Interpolable(InterpolableFragment),\n    List(ListFragment),\n    Subprocess(SubprocessFragment),\n    Arithmetic(ArithmeticFragment),\n    Comment(CommentFragment),\n    Log(LogFragment),\n    #[default] Empty\n}\n```\n\nIts purpose is to provide structured generation of Bash code. For example:\n- `VarExpr` handles variable access (like `$VAR`).\n- `Subprocess` handles `$(...)` command substitutions.\n- `Block` handles sequences of statements (like `{ ... }`).\n- `Arithmetic` handles `(( ... ))` arithmetic contexts.\n\n`FragmentKind` implements `FragmentRenderable` trait which allows it to be converted to a string. This is the final stage of compilation where Lower IR is rendered into actual Bash code:\n\n```rs\nfn to_string(self, meta: &mut TranslateMetadata) -> String;\n```\n\n\nWelcome to the Amber Contributing Guidebook! \ud83d\udc4b\n\nThis guide offers a clear and comprehensive introduction to getting started with contributing to Amber. If you haven\u2019t already, consider joining our [Discord](https://discord.com/invite/cjHjxbsDvZ) community, where you can ask any questions and connect with other contributors.\n\n## Contributing Guidelines\n\nBefore you dig into Amber, you should know a few things before you contribute.\n\nAny code change is submitted [through a PR](https://github.com/amber-lang/Amber/pulls), which is then approved by at least 2 maintainers. Each pull request should be directed to the `staging` branch unless there is a specific justification for targeting the `master` branch.\n\nThe way we talk on GitHub is not the same as we would talk in person. When on GitHub, always get straight to the point and be critical.\n\nPersonal grudges are forbidden around here, as well as anything offtopic or offensive.\n\n### Opening a PR\n\nBefore a PR is opened, it usually has an issue about it first, where we discuss how exactly a feature must be implemented, to avoid making a mistake.\n\nIt is recommended that you see how features were already implemented. A good example is [#130](https://github.com/amber-lang/Amber/issues/130)\n\nTo create a PR, you should fork the repo, create a branch, do your work in there, and open a PR. It will then be reviewed and pushed into master.\n\nThe maintainers will check who it is the best reviewer, we suggest to open a ticket reporting the issue before starting to do the PR so we can discuss the implementation.\n\n### Getting Help\n\nAlong the way, you may need help with your code. The best way to ask is in [our Discord server](https://discord.com/invite/cjHjxbsDvZ), but you may also ask other contributors personally or post in [Discussions](https://github.com/amber-lang/Amber/discussions).\n\n### Development\n\nCompile Amber with the following instructions:\n\n```\ngit clone https://github.com/amber-lang/amber\ncd amber\ncargo build\n```\n\nIn order to execute amber code, use the following command:\n\n```bash\n# `cargo run` - cargo command\n# `run <file.ab>` - amber command\ncargo run run <file.ab>\n```\n\nTo compile amber code into a bash code, use the following command:\n\n```bash\n# `cargo run` - cargo command\n# `build <input.ab> <output.sh>` - amber command\ncargo run build <input.ab> <output.sh>\n```\n\nDebugging Amber:\n```bash\n# Displays Amber's AST trace of trying to parse code\nAMBER_DEBUG_PARSER=true cargo run -- run <file.ab>\n# Shows the time it took to compile each phase\nAMBER_DEBUG_TIME=true cargo run -- run <file.ab>\n# Flamegraph is a profiling tool that is used to visualize the time each function took to execute\nsudo cargo flamegraph -- <file.ab> <file.sh>\n```\n\n#### Running Tests\n\nTests modules can be found in [`src/tests`](https://github.com/amber-lang/amber/tree/main/src/tests). Modules like [`erroring.rs`](https://github.com/amber-lang/amber/blob/main/src/tests/erroring.rs), [`stdlib.rs`](https://github.com/amber-lang/amber/blob/main/src/tests/stdlib.rs) and [`validity.rs`](https://github.com/amber-lang/amber/blob/main/src/tests/validity.rs) load test scenarios from directories `src/tests/erroring/`, `src/tests/stdlib/` and `src/tests/validity/` respectively.\n\nTo run ALL tests, run `cargo test`.\n\nIf you want to run only tests from a specific module, let's say from [`stdlib.rs`](https://github.com/amber-lang/amber/blob/main/src/tests/stdlib.rs), you can do that by adding the module name to the command: `cargo test stdlib`.\n\nTo run a single test case, for example `function_with_wrong_typed_return.ab` in `erroring`, you can filter by the test name:\n`cargo test function_with_wrong_typed_return`\n\n#### Github Actions\n\nWe use GitHub Actions to run tests and build binaries. When a new release tag is created, artifacts are built for Linux, macOS, and Windows (x86_64 and aarch64) and uploaded to the release page. We also generate installers and Debian packages.\n\n\nIn this guidebook we will learn how the compiler works and how to contribute to it by adding new features or fixing bugs. We will cover the CLI interface, the compiler architecture, how to create builtins, the standard library and tests.\n\n# CLI Interface\n\nThe entire CLI interface is defined in [`main.rs`](src/main.rs), using [`clap`](https://crates.io/crates/clap) for argument parsing. The `main` function initializes the `AmberCompiler` struct (defined in [`src/compiler.rs`](src/compiler.rs)), which serves as the main driver for the compilation process.\n\nAvailable subcommands include:\n*   `Run`: Compiles and executes an Amber script immediately.\n*   `Build`: Compiles an Amber script to a Bash script.\n*   `Eval`: Executes a snippet of Amber code passed as a string.\n*   `Check`: parses and type-checks the code without generating output.\n*   `Docs`: parsing the code and generating documentation for it.\n*   `Test`: Runs tests defined in the Amber project.\n*   `Completion`: Generates shell completion scripts.\n\nWhen a command is executed, `main.rs` configures the `AmberCompiler` with the appropriate options and calls its methods (e.g., `compile()`, `execute()`, `generate_docs()`) to perform the requested task.\n\n## Compiler\n\nCompiler consists of:\n- `src/compiler.rs` - Main entry point for the compiler\n- `src/rules.rs` - Syntax rules that are used by Heraclitus framework to correctly output tokens\n- `src/utils` - Contains parsing environments, caches, contexts and Amber's implementations of metadata\n- `src/modules` - Syntax modules that parse Amber syntax and also handle the translation process\n- `src/translate` - Contains a definition of `TranslateModule` trait that is used to translate modules the previously mentioned `modules`\n\n`AmberCompiler` struct by itself is just a bootstrapper for all the syntax modules. Here we will learn some practical facts about compiler. For a more in-depth guide, visit [our compiler guide](/contribute/compiler).\n\n## Parser & Tokenizer\n\nThanks to [`heraclitus`](https://github.com/amber-lang/Heraclitus), we can use simple abstractions to go through tokens.\n\nPlease open any syntax module code file, and find a line that says: \n```rs\nimpl SyntaxModule<ParserMetadata> for MODULE_NAME_HERE\n```\n\nIt will have a `parse()` function, where all the magic happens. You can either dig into the code yourself or look at the example below to understand how it works.\n\nbegin[details] Example parser\n\n**Important: this is pseudo code. Its purpose is to demonstrate how it should look like.**\n\n```rs\n// This code parses the following: `1 + 2`\nfn parse(meta: &mut ParserMetadata) -> SyntaxResult {\n    let digit_1 = meta.get_current_token();     // gets the text (as an Option)\n    token(meta, \"+\")?;                          // matches that there is a \"+\" and skips it\n    let digit_2 = meta.get_current_token();\n\n    self.digit_1 = digit_1.unwrap();\n    self.digit_2 = digit_2.unwrap();\n\n    Ok(())\n}\n```\n\nend[details]\n\n## Parsing Logic & Failures\n\nThe parsing process in Heraclitus revolves around the `SyntaxResult` type, which is an alias for `Result<(), Failure>`. The `Failure` type is critical for control flow and offers two distinct error modes:\n\n*   **Quiet Error**: which means \"This is not the syntax validation you are looking for.\"\n    *   Returned when a syntax module doesn't match the current code (e.g., looking for a `let` keyword but finding `if`).\n    *   The compiler catches this error and backtracks to try the next available syntax module.\n*   **Loud Error**: which means \"This IS the correct module, but the code is wrong.\"\n    *   Returned when the compiler is certain it's parsing the correct construct but encounters invalid syntax (e.g., missing semicolon after variable declaration).\n    *   This error halts the entire compilation process and reports a failure to the user.\n\n## Heraclitus Functions\n\nHeraclitus provides a set of helper functions and macros to streamline parsing and error reporting:\n\n*   `token(meta, \"keyword\")`: Attempts to consume a specific text token. Returns a **Quiet** error if the token doesn't match.\n*   `token_by(meta, pattern)`: Matches a token based on a boolean predicate function. Returns a **Quiet** error failure.\n*   `syntax(meta, &mut submodule)`: Recursively parses a nested syntax module. It propagates whatever error the submodule returns (Quiet or Loud).\n*   `error!(meta, tok, ...)`: A macro that halts compilation with a **Loud** error at the position of provided token.\n*   `error_pos!(meta, pos => ...)`: A macro that halts compilation with a **Loud** error at a *specific* position which can be more complex than single token, allowing for detailed error messages with context.\n\n## Translator\n\nSame as parser open a syntax module, and find a line that says `impl TranslateModule for MODULE_NAME_HERE` and that should contain a `translate` function.\n\nSame as before, you can either dig into the code you opened or look at the example below.\n\nbegin[details] Example translator\n\n**Important: this is pseudo code. Its purpose is to demonstrate how it should look like.**\n\n```rs\n// This will translate `1 + 2` into `(( 1 + 2 ))`\nfn translate() -> String {\n\n    // self.digit_1 and self.digit_2 is set earlier by the parser\n    format!(\"(( {} + {} ))\", self.digit_1, self.digit_2)\n}\n```\n\nend[details]\n\nBasically, the `translate()` method should return a `FragmentKind` which represents a piece of the compiled shell script.\n\n## Fragments\n\nAmber compiles to shell script fragments. The `FragmentKind` enum encapsulates these different types of output. You can find available fragment modules in `src/translate/fragments/`. Common ones include:\n\n*   `RawFragment` (`raw`): Represents a raw string of shell code (e.g., `echo \"hello\"`).\n*   `BlockFragment` (`block`): Represents a block of code, often used for bodies of functions or loops.\n*   `ListFragment` (`list`): A list of fragments properly joined together.\n*   `SubprocessFragment` (`subprocess`): For command substitutions `$(...)`.\n*   `VarExprFragment` / `VarStmtFragment`: For handling variable usage and definition.\n\nTo construct these fragments easily, Amber provides helper macros:\n\n*   `raw_fragment!(\"echo {}\", value)`: Creates a `RawFragment` with formatted text.\n*   `fragments!(a, b, c)`: joins multiple fragments into a `ListFragment`.\n\n# Creating Builtins\n\nIn this guide we will see how to create a basic built-in function that in Amber syntax presents like:\n\n```ab\nexample \"Hello World\"\n```\n\nAnd compiles to:\n\n```sh\necho \"Hello World\"\n```\n\nFor a real example based on this guide you can check the [`cd` builtin](https://github.com/amber-lang/amber/blob/master/src/modules/builtin/cd.rs) that is also Failable.\n\nbegin[details] Let's start!\n\nCreate a `src/modules/builtin/builtin.rs` file with the following content:\n\n\n```rs\n// Import the core Heraclitus framework traits and types required for defining syntax modules\nuse heraclitus_compiler::prelude::*;\n// Import the Expression module to parse arguments as expressions\nuse crate::modules::expression::expr::Expr;\n// Import the TranslateModule trait to define how this syntax translates to shell code\nuse crate::translate::module::TranslateModule;\n// Import metadata structures:\n// - `ParserMetadata`: Tracks parsing state (declared variables, functions, warnings, current scope).\n// - `TranslateMetadata`: Tracks translation state (indentation level, silent/eval modes).\nuse crate::utils::{ParserMetadata, TranslateMetadata};\n// Import DocumentationModule (required trait, even if unused for internal builtins)\nuse crate::docs::module::DocumentationModule;\n// Import the `raw_fragment` macro for easy construction of shell script fragments\nuse crate::raw_fragment;\n\n// This struct represents the parsed state of our builtin.\n// It holds the data extracted during parsing.\n#[derive(Debug, Clone)]\npub struct Example {\n    // We expect this builtin to take one argument, which is an expression.\n    value: Expr,\n}\n\n// Implement the SyntaxModule trait to define how to parse this construct.\nimpl SyntaxModule<ParserMetadata> for Example {\n    // Defines the name used for this module in compiler debug logs and traces.\n    syntax_name!(\"Example\");\n\n    // Returns a default instance of the struct.\n    fn new() -> Self {\n        Example {\n            value: Expr::new()\n        }\n    }\n\n    // The core parsing logic.\n    // Returns `SyntaxResult`, which is `Result<(), Failure>`.\n    // See \"2.1.1. Parsing Logic & Failures\" for details on Quiet vs Loud errors.\n    fn parse(&mut self, meta: &mut ParserMetadata) -> SyntaxResult {\n        // 1. Match the keyword \"example\".\n        // `token(...)` attempts to consume the specific token. If it fails, it returns a `Quiet` error.\n        // The `?` operator propagates this error, allowing the compiler to try other modules.\n        token(meta, \"example\")?;\n\n        // 2. Parse the argument.\n        // Once we've matched the keyword \"example\", we are committed to this syntax.\n        // `syntax(...)` will return either a `Loud` or `Quiet` error from the submodule.\n        syntax(meta, &mut self.value)?;\n        Ok(())\n    }\n}\n\n// Implement TypeCheckModule to validate types before translation.\nimpl TypeCheckModule for Example {\n    fn typecheck(&mut self, meta: &mut ParserMetadata) -> SyntaxResult {\n        // 1. Recursively typecheck the argument expression first.\n        self.value.typecheck(meta)?;\n        \n        // 2. Validate that the argument is of the expected type (Text).\n        if self.value.get_type() != Type::Text {\n            let pos = self.value.get_position();\n            // `error_pos!` creates a formatted `Loud` error message pointing to the specific\n            // location in the user's code.\n            return error_pos!(meta, pos => {\n                message: \"Builtin function `example` can only be used with values of type Text\"\n            });\n        }\n        Ok(())\n    }\n}\n\n// Implement TranslateModule to convert the AST into the target shell script.\nimpl TranslateModule for Example {\n    fn translate(&self, meta: &mut TranslateMetadata) -> FragmentKind {\n        // 1. Translate the argument expression into a shell string.\n        let value = self.value.translate(meta);\n        \n        // 2. Construct the final shell command.\n        // `raw_fragment!` creates a code fragment that is inserted directly into the output script.\n        raw_fragment!(\"echo {}\", value)\n    }\n}\n\n// Implement DocumentationModule.\n// For internal builtins not exposed in standard docs, we return an empty string.\nimpl DocumentationModule for Example {\n    fn document(&self, _meta: &ParserMetadata) -> String {\n        String::new()\n    }\n}\n```\n\nNow let's import it in the main module for built-ins `src/modules/builtin/mod.rs`\n\n```rs\npub mod echo;\npub mod nameof;\n// ...\npub mod builtin;\n```\n\nNow we have to integrate this syntax module with either statement `Stmt` or expression `Expr`. Since this is a statement module, we'll add it to the list of statement syntax modules. Let's modify `src/modules/statement/stmt.rs`:\n\n```rs\n// 1. Import your new module\nuse crate::modules::builtin::builtin::Example;\n\n// 2. Add it to the StmtType enum\n// This allows the AST (Abstract Syntax Tree) to hold your new construct.\npub enum StmtType {\n    // ...\n    Example(Example)\n}\n\n// 3. Register it in the parsing loop\nimpl SyntaxModule<ParserMetadata> for Statement {\n    // ...\n    fn parse(&mut self, meta: &mut ParserMetadata) -> SyntaxResult {\n        // `parse_statement!` iterates through the provided modules in order.\n        // The order determines precedence (though keywords usually disambiguate).\n        parse_statement!([\n            // ...\n            Example,\n            // ...\n        ], |module, cons| {\n            // ...\n        })\n    }\n}\n```\n\nend[details]\n\nDon't forget to add a test in the [`validity`](https://github.com/amber-lang/amber/tree/master/src/tests/validity) folder and to add the new builtin to the list of the [reserved keywords](https://github.com/amber-lang/amber/blob/master/src/modules/variable/mod.rs#L16).\n\n# Standard Library\n\nThe Amber Standard Library (stdlib) is a collection of essential modules written in Amber itself, located in the `src/std` directory. It provides foundational capabilities that are available to every Amber program.\n\nModules include:\n*   **Text** (`text.ab`): String manipulation functions (splitting, joining, trimming).\n*   **Math** (`math.ab`): Mathematical constants and functions.\n*   **Array** (`array.ab`): Utilities for handling arrays and lists.\n*   **FS** (`fs.ab`): File system operations (reading, writing, checking existence).\n*   **Env** (`env.ab`): Environment variable access and manipulation.\n*   **Date** (`date.ab`): Date and time utilities.\n*   **Http** (`http.ab`): Basic HTTP request capabilities.\nand more...\n\nEvery function in the standard library is rigorously tested. You can find these tests in `src/tests/stdlib/`. When adding new standard library features, you must add corresponding tests to ensure correctness and prevent regressions.\n\n# Tests\n\nAmber uses `cargo test` for testing:\n- `validity` - the validity of the compiler output (`src/tests/validity/`)\n- `erroring` - the error handling of the compiler (`src/tests/erroring/`)\n- `stdlib` - the standard library functions (`src/tests/stdlib/`)\n\nFor every test written in Amber there are 3 ways to check the result following this order:\n\n* if a `// Output` comment on top that include the output to match\n* `Succeeded` word will be matched against the test output\n\nTests will be executed without recompilation. Amber will load the scripts and verify the output in the designated file to determine if the test passes.\n\nSome tests require additional setup, such as those for `download` that needs Rust to load a web server. These functions require special tests written in Rust that we can find in `src/tests/stdlib.rs` file.\n\nbegin[details] Let's write a simple test\n\n```rs\n#[test]\nfn prints_hi() {\n    let code = \"\n        echo \\\"hi!\\\"\n    \";\n    test_amber(code, \"hi!\", TestOutcomeTarget::Success);\n}\n```\n\nend[details]\n\n\nWelcome to the documentation of Amber the programming language! \ud83c\udf89\n\nHere is a minimal hello world example:\n```ab\necho(\"Hello world!\")\n```\n\n## What is Amber?\n\nAmber is a programming language compiled into Bash Script. It was designed with a modern syntax, safety features, type safety and practical functionalities that Bash could not offer. The subsequent section will demonstrate how Amber embodies these characteristics.\n\n### Modern Syntax\n\nAmber is designed based on the ECMA script syntax. The goal was to create a syntax that any developer could feel comfortable with. Hence, Amber draws on features from languages like Rust and Python.\n\n### Safety Features\n\nWhen Bash command fails - it carries on with the code execution as if nothing has happened. This could lead to some serious problems and side effects that are irreversible.\n\nWe dislike this behavior. This is why Amber will not compile if edge cases aren't handled - whether that involves displaying an error message to the user or failing silently.\n\n### Type Safety\n\nAmber comes with a straightforward type system that aids in identifying simple bugs and errors at compile time, yet it remains unobtrusive, allowing you to focus on what matters most in scripting: the logic.\n\n### Extra Features\n\nAmber supports things that are essential to developer like floating point arithmetic, a non-obscure way to handle arrays or even passing variables by reference instead of by copy. In addition to that Amber comes with a standard library that includes features like text trimming, summing all number in an array, splitting text and many more.\n\n### Supported Environments\n\nAmber's compiled Bash scripts are actively tested across a range of environments.\n\n| Environment       | Version Range | Status               | Notes                                                              |\n|-------------------|---------------|----------------------|--------------------------------------------------------------------|\n| **Bash (Linux) GNU**  | 3.2 - 5.3     | Under Testing | All versions within this range are tested using [tianon/docker-bash](https://github.com/tianon/docker-bash). |\n| **Bash (macOS)**  | 3.2           | Under Testing | Verified through GitHub Actions `macos-latest` environments.       |\n| **Bash (Linux) Busy Box**           | Latest           | Under Testing | Busy box environment. As of right now latest is 5.3 |\n\n\n## Installation\n\n### Support for architectures\n\nThe Amber compiler currently works on:\n- Linux x86 and ARM\n- macOS x86 and ARM (Apple Silicon)\n- Windows over WSL 2\n\n### Preparation for installation\n\n## macOS\nOn macOS, you should have everything preinstalled (curl, bash, bc).\n\n## Linux\nMake sure that the operating system meets the following prerequisites\n- Install the basic calculator:\n  - On Debian and Ubuntu: `sudo apt install bc` \n  - On Arch: `sudo pacman -Syu bc`\n  - On Fedora: `sudo dnf install bc`\n  - On OpenSUSE: `sudo zypper install bc`\n  \n- `curl` and `bash` are both installed by default in most cases. \n  In the very rare case that they happen to be not available yet, download them as well.\n\n> DETAILS: You should always update the system before you install a package in a rolling release distro, such as **Arch** and **Tumbleweed.**  Always reboot after an update of the kernel, init system, and similar software as well. \n\n## Installation via `bin`, the binary package manager\n\n**Install bin itself**:\n\nDownload the binary for your platform here:\n\n```\nhttps://github.com/marcosnils/bin/releases \n```\n\nAnd then make it executable: \n\n```\nchmod +x ./bin_0.24.2_linux_amd64\n```\n\nAnd now run it from the directory where it is located:\n\n```\n./bin_0.24.2_linux_amd64 install github.com/marcosnils/bin\n```\n\nAnd now, install Amber:\n\n```\nbin install github.com/amber-lang/amber\n```\n\nUpdate it via:\n\n```\nbin update\n```\n\n> DETAILS: Bin can install all binaries that are hosted somewhere on GitHub, Codeberg, and other locations. For detailed documentation, see: [Commands Reference](https://github.com/marcosnils/bin?tab=readme-ov-file#-commands-reference)\n\n## Installation via script\n\n- **System-wide**\n```bash\nbash <(curl -sL \"https://github.com/amber-lang/amber/releases/download/0.5.1-alpha/install.sh\")\n```\n- **Local-user**\n```bash\nbash -- <(curl -sL \"https://github.com/amber-lang/amber/releases/download/0.5.1-alpha/install.sh\") --user\n```\n\n- **Available versions with package managers**\n\n<div style=\"width:250px;margin: 0 auto;\">\n[![Packaging status](https://repology.org/badge/vertical-allrepos/amber-lang.svg)](https://repology.org/project/amber-lang/versions)\n</div>\n\n### NixOS Channel\n\nThe name of the package is `amber-lang`.\n- **configuration.nix**\n```nix\n  environment.systemPackages = [\n    pkgs.amber-lang\n  ];\n```\n- **And with home manager:**\n```nix\n  home.packages = with pkgs; [\n    amber-lang\n  ];\n  programs.home-manager.enable = true;\n```\n\n- **Start a shell with:**\n\n```nix\nnix-shell -p amber-lang\n```\n\n### NixOS with Flakes\n\n- **You can use the Amber flake like this:**\n\n```nix\n{\n    inputs = {\n        # ...\n        amber.url = \"github:amber-lang/Amber\";\n    };\n}\n```\n\n- **Flakes with home manager:**\n\n```nix\nhome.packages = [ inputs.amber.packages.${pkgs.system}.default ];\n```\nWhile developing with Nix, the flake defines all dependencies for `nix develop` (or `direnv` if used).\n\n### Snap\n\n```bash\nsudo snap install amber-bash --classic\n```\n\n## Windows Support\n\nAs Windows does not come with bash installed, it makes no sense to support it.  \nPlease install WSL 2 on your Windows machine and install the Linux version of the Amber compiler inside.\n\nFor it to work, you may need to run the following code that pulls all the prerequisites.  \nThese count for Debian and Ubuntu-based images.\n\n```sh\nsudo apt install curl bc\nsudo mkdir /opt /usr/local/bin\n```\n\n## Integration of external tools\n\nAmber is currently an alpha-stage project, and to implement some features, we have chosen to integrate external tools.  \nIf these tools are available on your system, they will be executed at the end of the Bash compilation process.\n\n* [bshchk](https://github.com/b1ek/bshchk): A runtime Bash dependency checker\n\n## Uninstallation\n\nIf you have installed it via the script installation option, simply run the following code snippet.\n\n```sh\nbash -- <(curl -sL \"https://github.com/amber-lang/amber/releases/download/0.5.1-alpha/uninstall.sh\")\n```\n\n\nThis guide provides a step-by-step walkthrough for migrating code from 0.4.0-alpha to 0.5.0-alpha. The current version introduces several breaking changes. This document outlines the modifications, explains how to adapt your code to maintain the same behavior, and highlights updated features. In this guide we will cover two main categories of changes:\n1. **Language Features**: Changes and updates to the core language syntax and semantics.\n2. **Standard Library Updates**: Modifications to existing standard library functions and their usage.\n\nFollow along to ensure a smooth transition to the new version. Let\u2019s get started!\n\n# New integer `Int` data type <!-- #712 #752 -->\n\nPreviously, Amber supported only the `Num` type. This release introduces `Int`, which maps to Bash\u2019s native integer arithmetic. To support this, we\u2019ve updated parts of the language syntax.\n\n## Array subscript\n\nExpression in the subscript can only be of type `Int`.\n\n```ab\n// Before\narr[12.0] // Ok; although fails\n\n// After\narr[12.0] // Error: array subscript can only be an integer\n```\n\n## Range\n\nExpressions in range operator can only be of type `Int`.\n\n```ab\n// Before\n10.0..15.0 // OK; although fails\n\n// After\n10.0..15.0 // Error: range can only be applied on integers\n```\n\n## Iterator\n\nIterator variable in for-loop is now of type `Int`.\n\n```ab\n// Before\nfor i, item in items {} // `i` is a `Num`\n\n// After\nfor i, item in items {} // `i` is an `Int`\n```\n\n## Exit\n\nExit builtin now accepts only expressions of type `Int`.\n\n```ab\n// Before\nexit 2.0 // Ok; although fails\n\n// After\nexit 2.0 // Error: exit accepts only `Int` type\n```\n\n## Status\n\nThe `status` builtin now returns a value of type `Int`.\n\n```ab\n// Before\nstatus // Returns `Num` value\n\n// After\nstatus // Returns `Int` value\n```\n\n## Len\n\nThe `len` builtin now returns a value of type `Int`.\n\n```ab\n// Before\nlen(text) // Returns `Num` value\n\n// After\nlen(text) // Returns `Int` value\n```\n\n# Text to Bool Casting Warning <!-- #719 #831 -->\n\nCasting `Text` to any values including `Bool` and `Int`, now issues an \"absurd cast\" warning. While not an error, it indicates a potential logical issue and encourages explicit conversion for clarity.\n\n```ab\n// Before\necho \"true\" as Bool then 1 else 0 // OK\n\n// After\necho(\"true\" as Bool then 1 else 0) // Warning: Absurd cast\n```\n\n# Escaping Changes\n\n## String Literal Escaping Changes <!-- #594 -->\n\nA bug related to the escaping of `$` sequences within string literals has been fixed. Previously, `\"\\$variable\"` would incorrectly interpolate the value of `variable` instead of treating `$` as a literal character. If your code inadvertently relied on the previous buggy behavior where `\\$` within a string literal was interpolated, you will now observe the correct behavior where `\\$` is treated as a literal dollar sign. You may need to adjust your string literals if you intended interpolation in such cases.\n\n```ab\n// Before\nlet var = 45\necho \"\\$var\" // Output: 45\n\n// After\nlet var = 45\necho(\"\\$var\") // Output: \\$var\n```\n\n## Command String Escaping Changes <!-- #772 -->\n\nThe internal handling of text within commands has been refactored, leading to a breaking change in how double quotes (`\"`) should be escaped within command strings. Previously, `\"` might have been escaped with `\\\"` in some contexts, but this is no longer the correct behavior.\n\nDouble quotes (`\"`) should *not* be escaped with a backslash (`\\`) when used within command strings. The parser now handles this automatically. If your code contains command strings where double quotes are escaped (e.g., `$ echo \\\"hello\\\" $`), you must remove the backslash.\n\n```ab\n// Before (will now cause an error or incorrect behavior)\ntrust $ printf \\\"Amber\\\" $ // Incorrect: will now be interpreted as a literal backslash followed by a double quote\n\n// After (correct behavior)\ntrust $ printf \"Amber\" $ // Correct: the double quote is handled by the parser\n```\n\n# Standard Library Updates\n\n## Redesigned `std/date`\n\nThe standard library\u2019s Date module has been completely overhauled. We improved how its functions compose, removed obsolete ones, and repurposed others. The complete list of changes is below.\n\n| Old Name | New Name | Description |\n|:--|:--|:--|\n| `date_posix` | `date_from_posix` | Converts textual representation in a default `YYYY-MM-DD HH:MM:SS` format to [unix epoch time](https://en.wikipedia.org/wiki/Unix_time) |\n| *new* | `date_format_posix` | Converts [unix epoch time](https://en.wikipedia.org/wiki/Unix_time) to a textual representation. |\n| `date_add` | `date_add` | Adds time to passed date. |\n| *new* | `date_sub` | Subtracts time to passed date. |\n| *removed* | `date_compare` | Compares two dates and returns value of a sign function. |\n\n## Regex Functions Compatibility Changes <!-- #717 -->\n\nTo improve cross-platform compatibility, especially with macOS and BusyBox environments, the standard library functions `match_regex()` and `replace_regex()` no longer support certain GNU Sed-specific regular expression features. If your existing code relies on these GNU Sed-specific features within `match_regex()` or `replace_regex()`, you will need to update your regular expressions to use POSIX-compliant alternatives. For example, instead of `\\b`, you might use `[[:<:]]` and `[[:>:]]` for word boundaries, or ensure you are using ERE for alternation (`|`).\n\nThe following regular expression features are no longer supported within `match_regex()` and `replace_regex()`:\n*   `\\b` (word boundary) in both Extended Regular Expressions (ERE) and Basic Regular Expressions (BRE).\n*   `|` (alternation) in Basic Regular Expressions (BRE).\n\n## Function Renaming <!-- #768 -->\n\nThe standard library function `parse_number` has been renamed to `parse_num` to align with the new `Int` data type and improve clarity. If your code directly calls `parse_number`, you will need to update these calls to `parse_num`.\n\n```ab\n// Before\nconst num_val = trust parse_number(\"123.45\")\n\n// After\nconst num_val = trust parse_num(\"123.45\")\n```\n\n## Functions Now Failable <!-- #791 -->\n\nSeveral standard library functions that previously returned a `Bool` to indicate success or failure have been updated to be failable functions. This change aligns with Amber's failable paradigm, providing a more consistent and robust error handling mechanism. These functions no longer return a `Bool`. Instead, they will either succeed or fail, triggering the failable mechanism (e.g., propagating failure with `?` or being caught by a `failed` block).\n\n**Affected Functions:**\n- `std/fs::symlink_create`\n- `std/fs::dir_create`\n- `std/fs::file_chmod`\n- `std/fs::file_chown`\n- `std/net::file_download`\n\n```ab\n// Before\nif dir_create(\"my_directory\") {\n    echo \"Directory created successfully.\"\n} else {\n    echo \"Failed to create directory.\"\n}\n\n// After\ndir_create(\"my_directory\") exited(code) {\n    if code == 0:\n        echo(\"Directory created successfully.\")\n    else:\n        echo(\"Failed to create directory.\")\n}\n```\n\n## Removed `env_const_get` Function\n\nThe `env_const_get` function has been removed from `std/env`. Use `env_var_get` instead, which provides the same functionality.\n\n```ab\n// Before\nenv_const_get(\"VAR\")\n\n// After\nenv_var_get(\"VAR\")\n```\n\n\n\nTest blocks are dedicated scopes for writing tests. They are executed only when running the `amber test` command and are ignored during normal compilation. Test blocks can be optionally named using a string literal. This improves readability and allows for targetted execution.\n\n## Syntax\n```ab\nimport { assert } from \"std/test\"\n\n// Unique named test block\ntest \"can multiply numbers\" {\n    let result = 10 * 2\n    assert(result == 20)\n}\n\n// Unnamed test block (only one allowed per file)\ntest {\n    let name = \"Amber\"\n    assert(name + \" Lang\" == \"Amber Lang\")\n}\n```\n\n# CLI Test Filtering\n\nThe `amber test` command is designed to verify the correctness of your code by executing test blocks. By default, it recursively finds and runs all tests in the current directory. You can narrow down which tests to run by providing filter arguments.\n\n## Filtering Tests\n\nYou can run a specific subset of tests by providing a filter argument. This argument performs a substring match against both the **filename** and the **test name**.\n\n```bash\n# Run all tests located in the current directory containing \"variable\" in their name or filename\namber test . \"variable\"\n```\n\n## Targeting Specific Files\n\nInstead of running tests from the current directory, you can specify a particular file or directory to scan.\n\n```bash\n# Run all tests inside main.ab\namber test main.ab\n\n# Run all tests in main.ab that contain \"zip\" in their name\namber test main.ab \"zip\"\n```\n\n\nThe Amber CLI can be used as a runtime or as a compiler.\n\n## Command Line Interface\n\nThe Amber CLI syntax uses subcommands, like the Git CLI:\n\n*This output is generated from the 0.5.2-alpha version.*\n```\nUsage: amber [OPTIONS] [INPUT] [ARGS]... [COMMAND]\n\nCommands:\n  eval        Execute Amber code fragment\n  run         Execute Amber script\n  check       Check Amber script for errors\n  build       Compile Amber script to Bash\n  docs        Generate Amber script documentation\n  completion  Generate Bash completion script\n  test        Run Amber tests\n  help        Print this message or the help of the given subcommand(s)\n\nArguments:\n  [INPUT]    Input filename ('-' to read from stdin)\n  [ARGS]...  Arguments passed to Amber script\n\nOptions:\n      --no-proc <NO_PROC>  Disable a postprocessor\n                           Available postprocessors: 'bshchk'\n                           To select multiple, pass multiple times with different values\n                           Argument also supports a wildcard match, like \"*\" or \"b*chk\"\n  -h, --help               Print help\n  -V, --version            Print version\n```\n\nFor detailed usage instructions, refer to the [Amber usage guide](https://docs.amber-lang.com/getting_started/usage).\n\n### Running Amber Code\n\nThe following command will simply execute `hello.ab` as a script file. Amber code will be compiled to Bash and then executed all in one go:\n\n```sh\n$ amber run hello.ab\nHello world!\n```\n\nAlternatively, if the file contains a _shebang_ line and has the executable bit set, it can be run like this:\n\n```ab\n#!/usr/bin/env amber\necho(\"Hello world\")\n```\n\n```sh\n$ ./hello.ab\nHello world\n```\n\nAdditionally, command line arguments can be passed to the script:\n\n```ab\n#!/usr/bin/env amber\nmain(args) {\n    for arg in args {\n        echo(arg)\n    }\n}\n```\n\n```sh\n$ ./args.ab 1 2 3\n1\n2\n3\n```\n\nIf you want to run just a small code snippet, you can do that as well:\n\n```sh\n$ amber eval '\nimport * from \"std/text\"\necho(uppercase(\"Hello world!\"))\n'\nHELLO WORLD!\n```\n\n### Compiling Amber Scripts\n\nThere are times when you prefer to just compile Amber code to a script, for example when dealing with _cron jobs_:\n\n```sh\n$ amber build input.ab output.sh\n```\n\nYou\u2019ll notice that the compiled script is immediately callable; hence, there\u2019s no need to add executable permissions using `chmod`, for instance. Amber grants the permission automatically.\n\nFurthermore, Amber adds a _shebang_ at the top of the compiled script. This enables you to run the code simply, without any additional commands:\n\n```sh\n$ ./output.sh\n```\n\n## Testing\n\nAmber comes with a built-in test runner. You can define named test blocks in your code and execute them using the `amber test` command.\n\n```sh\n$ amber test\n```\n\nFor more details on writing and filtering tests, please refer to the [Testing guide](https://docs.amber-lang.com/getting_started/testing).\n\n## Syntax Highlighting\n\n[VS Code](https://code.visualstudio.com) as well as [Zed](https://zed.dev) now have built-in LSP integration.\n\n![Amber LSP Feature]{\"width\": \"100%\"}(/images/lsp-example-light.webp)(/images/lsp-example-dark.webp)\n\nHere is a list of plugins that support syntax highlighting for Amber language.\n\n| Icon | Name | Location |\n|---|:----:|:-----:|\n| LOGO:hx | **Helix Editor** | [Native Support](https://docs.helix-editor.com/lang-support.html) |\n| LOGO:nova | **Nova** | [Nova extensions](https://extensions.panic.com/extensions/besya/besya.amber/) |\n| LOGO:vim | **Vim** | [Our extension repository](https://github.com/amber-lang/amber-vim) |\n| LOGO:vsc | **VS Code** | [VSC Marketplace](https://marketplace.visualstudio.com/items?itemName=Ph0enixKM.amber-language) or [Our extension repository](https://github.com/amber-lang/amber-vsc) |\n| LOGO:zed | **Zed** | Zed extensions or [Our extension repository](https://github.com/amber-lang/zed-amber-extension) |\n\n\n## Other interesting commands\n\n### Postprocessors\n\nBy default, Amber runs postprocessor `bshchk` (if installed) on the compiled Bash script.  This functionality can be disabled with a `--no-proc` option:\n\n```sh\n$ amber build --no-proc=bshchk input.ab output.sh\n```\n\n### Minification\n\nAdditionally, the `--minify` option compresses the generated Bash code to reduce its size:\n\n```sh\n$ amber build --minify input.ab output.sh\n```\n\n### Generating Amber Documentation\n\nThe following command extracts comments prefixed with `///` (triple slashes) from a single Amber file, and generates a Markdown file for documentation, by default in the `docs` subdirectory:\n\n```sh\n$ amber docs stdlib.ab\n```\n\n### Generating Bash Completion Scripts\n\nThe following command generates a [Bash completion](https://en.wikipedia.org/wiki/Command-line_completion) script:\n\n```sh\n$ amber completion\n_amber() {\n    local i cur prev opts cmd\n    COMPREPLY=()\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n...\n```\n\nThis can be sourced in the `.bashrc` file via command redirection, so that command completion works in all subsequently opened Bash shells.  Assuming the `amber` binary is on the system path:\n\n```sh\n$ cat ~/.bashrc\n...\nsource <(amber completion)\n...\n```\n\n### Disabling the Optimizer\n\nThe optimizer is still being improved. If you encounter any issues with optimization, you can disable it using an environment variable:\n\n```sh\nAMBER_NO_OPTIMIZE=1 amber ...\n```\n\n\n> WARNING: Brief description of new changes TBD when releasing\n\n# Union Types\nUnion types provide a flexible way to define function parameters that can accept values of multiple distinct types.\n\n```ab\nfun print_value(val: Int | Text | Bool) {\n    echo(val)\n}\n\nprint_value(42)       // Valid\nprint_value(\"Amber\")  // Valid\nprint_value(true)     // Valid\n```\n\n# Testing suite\nAmber now features a built-in testing suite. It allows you to write dedicated `test` blocks that are only executed when running the `amber test` command.\n\nWe also introduced a new `std/test` library. More on that in the [Standard library improvements](#standard-library-improvements) section.\n\n```ab\ntest \"can multiply numbers\" {\n    let result = 10 * 2\n    // assertions ...\n}\n```\n\nYou can also name your tests for better readability and filter them by name or filename using CLI arguments. Read more in the [Testing Guide](testing).\n\n# Improved variable diagnostics\n\nThe compiler now surfaces clearer warnings when variables are not used, helping you catch mistakes earlier. It also warns when a variable declared with `let` is never modified, encouraging the use of `const` for bindings that never need reassignment.\n\n```ab\nlet unused = 1 // Warning: variable 'unused' is not used\nlet count = 3  // Warning: variable 'count' is never modified - consider using 'const'\necho(count)\n\n```\n\n# New builtins syntax\n\nAll builtins like `echo` now have new syntax similar to functions:\n\n```ab\necho(\"Hello world\")\ncd(\"newdir\")\nmv(\"file.ab\", \"newdir\")\nexit(1)\n```\n\n# Array Type Resolution\n\nAmber now supports type inference for empty arrays `[]`. You can initialize an empty array without specifying its type immediately. The type will be resolved later based on how the array is used, such as in assignments, binary operations, or function calls.\n\n```ab\nlet arr = [] // Type is generic\narr += [1]   // Resolved to [Int]\n```\n\n# Array destructing\n\nYou can now destruct arrays into separate variables:\n\n```ab\nlet arr = [1,2,3]\nlet [key1, key2, key3] = arr\n\necho(\"{key1} {key2} {key3}\") // 1 2 3\n```\n\n# Standard library improvements\n\n> WARNING: Brief description of new changes TBD when releasing\n\n## New `std/test` module\n\nWe introduced a new [`std/test`](stdlib/doc/test) library that provides `assert` and `assert_eq` functions to help you write tests.\n\n```ab\nimport { assert, assert_eq } from \"std/test\"\n\ntest \"can multiply numbers\" {\n    let result = 10 * 2\n    assert(result == 20)\n    assert_eq(result, 20)\n}\n```\n\n## New `fetch` function for HTTP requests\n\nThe `fetch` function provides a functionality for making HTTP requests. It intelligently utilizes available command-line tools for network operations, with a failover to bash's network sockets. This function supports a comprehensive set of HTTP methods, including `GET`, `POST`, `PUT`, and `DELETE`.\n\n```ab\nimport { fetch } from \"std/http\"\n\nlet response = trust fetch(\"https://example.com\")\nlet post_request = trust fetch(\"https://example.com\", \"POST\", \"hello world!\", [ \"content-type: text/plain\" ]) // POST request\n```\n\n\n## Builtin vs Standard Library\n\n[Builtins](/advanced_syntax/builtins) are methods that are included in the Amber compiler and don't need to be imported in the code.\n\nIn contrast, the standard library (stdlib) is a collection of Amber functions that are embedded in every Amber release. Each version of Amber may include changes to the standard library and you need to import these functions in your code. These functions are more advanced and can accept various parameters.\n\n## Standard Library and Shellcheck\n\nJust like the Amber's compiled Bash output, all standard library functions are built from the ground up to be shellcheck compliant. This means that you can focus more on building the logic and spend less time on keeping the code predictable and valid.\n\n## How to Use It\n\nBelow is an example of how to use the standard library to generate documentation (using the [script](https://github.com/amber-lang/amber-docs/sync-stdlib-doc.ab) provided on the Amber Documentation repository):\n\n```ab\nimport { download } from \"std/http\"\nimport { split, contains } from \"std/text\"\nimport { file_exist } from \"std/fs\"\n\ntrust $ rm -fr /tmp/amber-git $\nif silent download(\"https://github.com/amber-lang/amber/archive/refs/heads/master.zip\", \"/tmp/amber-git.zip\") {\n    trust $ unzip \"/tmp/amber-git.zip\" -d /tmp/amber-git $\n\n    let std = trust $ /usr/bin/ls \"/tmp/amber-git/amber-master/src/std/\" $\n    let stdlib = split(std, \"\\n\")\n\n    for v in stdlib {\n        if (contains(v, \".ab\") and file_exist(\"/tmp/amber-git/amber-master/src/std/{v}\")) {\n            trust $ amber --docs \"/tmp/amber-git/amber-master/src/std/{v}\" \"./docs/stdlib/doc\" $\n            echo(\"\\n\")\n        }\n    }\n}\n```\n\n> WARNING: Each Amber release may have a different version of the standard library, so make sure to verify compatibility with the specific release you are using.\n\n### Importing a Library\n\nYou can also import all functions from a module by using the following syntax:\n\n```ab\nimport * from \"std/http\"\n```\n\nHowever, only the functions that are used in the script will be included in the generated Bash code, ensuring efficiency.\n\nIf you prefer a verbose import, you can specify a single function:\n\n```ab\nimport { download } from \"std/http\"\n```\n\n\n## `array_contains`\n\n```ab\npub fun array_contains(array, value) \n```\n\nChecks if a value is in the array.\n\n### Usage\n```ab\nimport { array_contains } from \"std/array\"\n\narray_contains([1, 2, 3], 2) // Outputs true\n```\n\n## `array_extract_at`\n\n```ab\npub fun array_extract_at(ref array: [], index: Int) \n```\n\nRemoves an element at the index from the array, and returns it; if the\nindex is negative or beyond the end, the function fails.\n\n### Usage\n```ab\nimport { array_extract_at } from \"std/array\"\n\nlet array = [1, 2, 3]\nlet element = array_extract_at(array, 1)\necho element // Outputs 2\necho(array) // Outputs [1, 3]\n```\n\n## `array_filled`\n\n```ab\npub fun array_filled(size, value = 0) \n```\n\nReturns an array of length `size` with each element set to `value`; if `size`\nis less than zero an empty array is returned\n\n### Usage\n```ab\nimport { array_filled } from \"std/array\"\n\nlet array = array_filled(5, 1)\necho(array) // Outputs [1, 1, 1, 1, 1]\n```\n\n## `array_find`\n\n```ab\npub fun array_find(array, value): Int \n```\n\nReturns index of the first value found in the specified array.\n\nIf the value is not found, the function returns -1.\n\n### Usage\n```ab\nimport { array_find } from \"std/array\"\n\narray_find([1, 2, 3], 2) // Outputs 2\n```\n\n## `array_find_all`\n\n```ab\npub fun array_find_all(array, value): [Int] \n```\n\nSearches for a value in an array and returns an array with the index of the various items.\n\n### Usage\n```ab\nimport { array_find_all } from \"std/array\"\n\narray_find_all([1, 2, 3, 2], 2) // Outputs [1, 3]\n```\n\n## `array_first`\n\n```ab\npub fun array_first(array) \n```\n\nReturns the first element in the array; if the array is empty, the function\nfails.\n\n### Usage\n```ab\nimport { array_first } from \"std/array\"\n\narray_first([1, 2, 3]) // Outputs 1\n```\n\n## `array_last`\n\n```ab\npub fun array_last(array) \n```\n\nReturns the last element in the array; if the array is empty, the function\nfails.\n\n### Usage\n```ab\nimport { array_last } from \"std/array\"\n\narray_last([1, 2, 3]) // Outputs 3\n```\n\n## `array_pop`\n\n```ab\npub fun array_pop(ref array) \n```\n\nRemoves the last element from the array, and returns it; if the array\nis empty, the function fails, and the array will be unchanged.\n\n### Usage\n```ab\nimport { array_pop } from \"std/array\"\n\nlet array = [1, 2, 3]\nlet element = array_pop(array)\necho(element) // Outputs 3\necho(array) // Outputs [1, 2]\n```\n\n## `array_remove_at`\n\n```ab\npub fun array_remove_at(ref array: [], index: Int): Null \n```\n\nRemoves an element at the index from the array; if the index is negative\nor beyond the end, the array will be unchanged.\n\n### Usage\n```ab\nimport { array_remove_at } from \"std/array\"\n\nlet array = [1, 2, 3]\narray_remove_at(array, 1)\necho(array) // Outputs [1, 3]\n```\n\n## `array_shift`\n\n```ab\npub fun array_shift(ref array) \n```\n\nRemoves the first element from the array, and returns it; if the array\nis empty, the function fails, and the array will be unchanged.\n\n### Usage\n```ab\nimport { array_shift } from \"std/array\"\n\nlet array = [1, 2, 3]\nlet element = array_shift(array)\necho(element) // Outputs 1\necho(array) // Outputs [2, 3]\n```\n\n## `sort`\n\n```ab\npub fun sort(ref array: [], desc: Bool = false, version_sort: Bool = false): Null \n```\n\nSort the array in-place.\nPass `desc` value `true` for descending order.\nPass `version_sort` value `true` for version sort,\nthis only applies to text arrays.\n\n### Usage\n```ab\nimport { sort } from \"std/array\"\n\nlet array = [\"15\",\"-3\",\"foo\",\"bar\"]\nsort(array)\necho(array) // Outputs [\"-3\", \"15\", \"bar\", \"foo\"]\n```\n\n## `sorted`\n\n```ab\npub fun sorted(array: [], desc: Bool = false, version_sort: Bool = false): [] \n```\n\nReturn the sorted array, leaving the original array unchanged.\nPass `desc` value `true` for descending order.\nPass `version_sort` value `true` for version sort,\nthis only applies to text arrays.\n\n### Usage\n```ab\nimport { sorted } from \"std/array\"\n\necho(sorted([-3,15,7,2], true)) // Outputs [-3, 2, 7, 15]\n```\n\n\n\n## `date_add`\n\n```ab\npub fun date_add(date: Int, amount: Int, unit: Text): Int? \n```\n\nAdds a value to a date passed in the unix epoch format in milliseconds.\nExample : `date_add(date, 3, \"days\")`\n\nAvailable units:\n- years\n- months\n- days\n- hours\n- minutes\n- seconds\n\n### Usage\n```ab\nimport { date_add } from \"std/date\"\n\nlet date = date_now() // Example value: 1678887000\nlet new_date = date_add(date, 5, \"hours\") // Example value: 1678890600\n```\n\n## `date_format_posix`\n\n```ab\npub fun date_format_posix(date: Int, format: Text = \"%F %T\", utc: Bool = false): Text? \n```\n\nTransform date from unix epoch to a human-readable format described by a posix format string.\nIf no format is specified, \"%F %T\" is used.\nFor more info about format type \"man date\" in your shell or see <https://www.gnu.org/software/coreutils/date>.\n\nFormat includes the following patterns:\n- `%%` - a literal %\n- `%a` - locale's abbreviated weekday name (e.g., Sun)\n- `%A` - locale's full weekday name (e.g., Sunday)\n- `%b` - locale's abbreviated month name (e.g., Jan)\n- `%B` - locale's full month name (e.g., January)\n- `%d` - day of month (e.g., 01)\n- `%D` - date; same as %m/%d/%y\n- `%F` - full date; like %+4Y-%m-%d\n- `%H` - hour (00..23)\n- `%I` - hour (01..12)\n- `%m` - month (01..12)\n- `%M` - minute (00..59)\n- `%N` - nanoseconds (000000000..999999999)\n- `%p` - locale's equivalent of either AM or PM; blank if unknown\n- `%T` - time; same as %H:%M:%S\n- `%Y` - year\n\n### Usage\n```ab\nimport { date_format_posix } from \"std/date\"\n\nlet date = date_now() // Example value: 1678887000\necho(date_format_posix(date)) // Outputs: 2023-03-15 14:30:00\n```\n\n## `date_from_posix`\n\n```ab\npub fun date_from_posix(date: Text, format: Text = \"%F %T\", utc: Bool = false): Int? \n```\n\nTransforms date from a format described by a posix format string to a unix epoch format (seconds since the Epoch (1970-01-01 00:00 UTC)).\nIf no format is specified, \"%F %T\" format is used.\nFor more info about format type \"man date\" on your shell or go to <https://www.gnu.org/software/coreutils/date>.\n\n### Usage\n```ab\nimport { date_from_posix } from \"std/date\"\n\nlet date = \"2023-03-15 14:30:00\"\necho(date_from_posix(date)) // Output: 1678887000\n```\n\n## `date_now`\n\n```ab\npub fun date_now(): Int \n```\n\nReturns the current timestamp (seconds since the Epoch (1970-01-01 00:00 UTC)).\n\n### Usage\n```ab\nimport { date_now } from \"std/date\"\n\nlet date = date_now() // Example value: 1678887000\n```\n\n## `date_sub`\n\n```ab\npub fun date_sub(date: Int, amount: Int, unit: Text): Int? \n```\n\nSubtracts a value from a date passed in the unix epoch format in milliseconds.\nExample : `date_sub(date, 5, \"hours\")`\n\nAvailable units:\n- years\n- months\n- days\n- hours\n- minutes\n- seconds\n\n### Usage\n```ab\nimport { date_sub } from \"std/date\"\n\nlet date = date_now() // Example value: 1678887000\nlet new_date = date_sub(date, 5, \"hours\") // Example value: 1678882200\n```\n\n\n\n## `bash_version`\n\n```ab\npub fun bash_version(): [Int] \n```\n\nReturns current bash version with major, minor and patch components.\n\n### Usage\n```ab\nimport { bash_version } from \"std/env\"\n\nconst version = bash_version()\necho(\"Bash {version[0]}.{version[1]}.{version[2]}\")\n```\n\n## `bold`\n\n```ab\npub fun bold(message: Text): Text \n```\n\nReturns a text as bold.\n\n### Usage\n```ab\nimport { bold } from \"std/env\"\n\nprintf(\"%s\\n\", [bold(\"Important message\")])\n```\n\n## `echo_colored`\n\n```ab\npub fun echo_colored(message: Text, color: Text | Int): Null \n```\n\nPrints a text with a specified color.\n\n### Usage\n```ab\nimport { echo_colored } from \"std/env\"\n\necho_colored(\"Red text\", \"red\")\necho_colored(\"Blue text\", 34)\n```\n\n### Supported color names\n| Color name | Code |\n| - | - |\n| black | 30 |\n| red | 31 |\n| green | 32 |\n| yellow | 93 |\n| orange | 33 |\n| blue | 34 |\n| purple | 35 |\n| cyan | 36 |\n| gray | 37 |\n| white | 97 |\n\nFor all supported color codes, please visit https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit\n\n## `echo_error`\n\n```ab\npub fun echo_error(message: Text, exit_code: Int = 1): Null \n```\n\nPrints a text as a error and exits if the status code is greater than 0.\n\n### Usage\n```ab\nimport { echo_error } from \"std/env\"\n\necho_error(\"Fatal error occurred\", 1)\n```\n\n## `echo_info`\n\n```ab\npub fun echo_info(message: Text): Null \n```\n\nPrints a text as a info message.\n\n### Usage\n```ab\nimport { echo_info } from \"std/env\"\n\necho_info(\"Information message\")\n```\n\n## `echo_success`\n\n```ab\npub fun echo_success(message: Text): Null \n```\n\nPrints a text as a success message.\n\n### Usage\n```ab\nimport { echo_success } from \"std/env\"\n\necho_success(\"Operation completed successfully\")\n```\n\n## `echo_warning`\n\n```ab\npub fun echo_warning(message: Text): Null \n```\n\nPrints a text as a warning message.\n\n### Usage\n```ab\nimport { echo_warning } from \"std/env\"\n\necho_warning(\"Warning: Disk space low\")\n```\n\n## `env_const_set`\n\n```ab\npub fun env_const_set(name: Text, val: Text | Int | Bool): Null? \n```\n\nSets a constant inside the shell session. Note that `true` is saved as int (`1`).\n\n### Usage\n```ab\nimport { env_const_set } from \"std/env\"\n\nenv_const_set(\"API_KEY\", \"secret123\")\n```\n\n## `env_file_load`\n\n```ab\npub fun env_file_load(file: Text = \".env\"): Null \n```\n\nLoads the env file in the environment, using `xargs`.\n\n### Usage\n```ab\nimport { env_file_load } from \"std/env\"\n\nenv_file_load(\".env\")\n```\n\n## `env_var_get`\n\n```ab\npub fun env_var_get(name: Text): Text? \n```\n\nGets a variable or constant inside the shell session.\n\n### Usage\n```ab\nimport { env_var_get } from \"std/env\"\n\nconst debug = env_var_get(\"DEBUG\")\n```\n\n## `env_var_load`\n\n```ab\npub fun env_var_load(var: Text, file: Text = \".env\"): Text \n```\n\nRetrieves the value of an environment variable, optionally sourcing it from a file if not already set.\n\n### Usage\n```ab\nimport { env_var_load } from \"std/env\"\n\nconst value = env_var_load(\"MY_VAR\", \".env.local\")\n```\n\n## `env_var_set`\n\n```ab\npub fun env_var_set(name: Text, val: Text | Int | Bool): Null? \n```\n\nSets a variable inside the shell session. Note that `true` is saved as int (`1`).\n\n### Usage\n```ab\nimport { env_var_set } from \"std/env\"\n\nenv_var_set(\"STATUS\", \"succeeded\")\nenv_var_set(\"COUNT\", 100)\nenv_var_set(\"DEBUG\", true) // saved as int (`1`)\n```\n\n## `env_var_test`\n\n```ab\npub fun env_var_test(name: Text): Bool \n```\n\nChecks if a variable inside the shell session exists.\n\n### Usage\n```ab\nimport { env_var_test } from \"std/env\"\n\nif env_var_test(\"PATH\") {\n    echo(\"PATH exists\")\n}\n```\n\n## `env_var_unset`\n\n```ab\npub fun env_var_unset(name: Text): Null? \n```\n\nRemoves a variable inside the shell session.\n\n### Usage\n```ab\nimport { env_var_unset } from \"std/env\"\n\nenv_var_unset(\"TEMP_VAR\")\n```\n\n## `escaped`\n\n```ab\npub fun escaped(text: Text): Text \n```\n\nEscapes the text to be used with `printf`.\n\n### Usage\n```ab\nimport { escaped } from \"std/env\"\n\nprintf(\"%s\\n\", [escaped(\"100% done\\\\n\")])\n```\n\n## `has_failed`\n\n```ab\npub fun has_failed(command: Text): Bool \n```\n\nChecks if the command has failed.\n\n### Usage\n```ab\nimport { has_failed } from \"std/env\"\n\nif has_failed(\"test -f config.txt\") {\n    echo(\"File doesn't exist\")\n}\n```\n\n## `input_confirm`\n\n```ab\npub fun input_confirm(prompt: Text, default_yes: Bool = false): Bool \n```\n\nCreates a confirm prompt (Yes/No), and returns true if the choice is Yes.\n\n\"No\" is the default choice, set default_yes to true for \"Yes\" as default choice.\n\n### Usage\n```ab\nimport { input_confirm } from \"std/env\"\n\nif input_confirm(\"Continue?\", false) {\n    echo(\"Continuing...\")\n}\n```\n\n## `input_hidden`\n\n```ab\npub fun input_hidden(prompt: Text): Text \n```\n\nCreates a prompt, hides any user input and returns the value.\n\n### Usage\n```ab\nimport { input_hidden } from \"std/env\"\n\nconst password = input_hidden(\"Enter password: \")\n```\n\n## `input_prompt`\n\n```ab\npub fun input_prompt(prompt: Text): Text \n```\n\nCreates a prompt and returns the value.\n\n### Usage\n```ab\nimport { input_prompt } from \"std/env\"\n\nconst name = input_prompt(\"Enter your name: \")\n```\n\n## `is_command`\n\n```ab\npub fun is_command(command: Text): Bool \n```\n\nChecks if a command exists.\n\n### Usage\n```ab\nimport { is_command } from \"std/env\"\n\nif is_command(\"git\") {\n    echo(\"Git is installed\")\n}\n```\n\n## `is_root`\n\n```ab\npub fun is_root(): Bool \n```\n\nChecks if the script is running with a user with root permission.\n\n### Usage\n```ab\nimport { is_root } from \"std/env\"\n\nif is_root() {\n    echo(\"Running as root\")\n}\n```\n\n## `italic`\n\n```ab\npub fun italic(message: Text): Text \n```\n\nReturns a text as italic.\n\n### Usage\n```ab\nimport { italic } from \"std/env\"\n\nprintf(\"%s\\n\", [italic(\"Emphasized text\")])\n```\n\n## `kill`\n\n```ab\npub fun kill(pid: Int, signal: Text = \"TERM\"): Null? \n```\n\nSends a signal to a process by PID.\n\n### Usage\n```ab\nimport { kill } from \"std/env\"\n\nkill(1234)?                  // Send SIGTERM (default)\nkill(1234, \"SIGKILL\")?       // Send SIGKILL\nkill(1234, \"9\")?             // Send signal 9 (SIGKILL)\n```\n\n## `mount`\n\n```ab\npub fun mount(source: Text, target: Text, options: Text = \"\"): Null? \n```\n\nMounts a filesystem. Requires root privileges.\n\n### Usage\n```ab\nimport { mount } from \"std/env\"\n\nmount(\"/dev/sda1\", \"/mnt/disk\")?\nmount(\"/root\", \"/test\", \"bind,ro\")? // mount /root to /test directory with read-only permission\n```\n\n## `pgrep`\n\n```ab\npub fun pgrep(pattern: Text): [Int] \n```\n\nFinds process IDs by name pattern.\n\n### Usage\n```ab\nimport { pgrep } from \"std/env\"\n\nconst pids = pgrep(\"nginx\")\nfor pid in pids {\n    echo(pid)\n}\n```\n\n## `pgrep_exact`\n\n```ab\npub fun pgrep_exact(name: Text): [Int] \n```\n\nFinds process IDs by exact name.\n\n### Usage\n```ab\nimport { pgrep_exact } from \"std/env\"\n\nconst pids = pgrep_exact(\"nginx\")\n```\n\n## `pkill`\n\n```ab\npub fun pkill(pattern: Text): Null? \n```\n\nKills processes by name pattern.\n\n### Usage\n```ab\nimport { pkill } from \"std/env\"\n\npkill(\"nginx\")?\n```\n\n## `pkill_exact`\n\n```ab\npub fun pkill_exact(name: Text): Null? \n```\n\nKills processes by exact name.\n\n### Usage\n```ab\nimport { pkill_exact } from \"std/env\"\n\npkill_exact(\"nginx\")?\n```\n\n## `pkill_force`\n\n```ab\npub fun pkill_force(pattern: Text): Null? \n```\n\nForcefully kills processes by name pattern (SIGKILL).\n\n### Usage\n```ab\nimport { pkill_force } from \"std/env\"\n\npkill_force(\"nginx\")?\n```\n\n## `printf`\n\n```ab\npub fun printf(format: Text, args: [Text] = []): Null \n```\n\n`printf` the text following the arguments.\n\n### Usage\n```ab\nimport { printf } from \"std/env\"\n\nprintf(\"Hello %s!\", [\"World\"])\n```\n\n## `shopt_disable`\n\n```ab\npub fun shopt_disable(optname: Text, set_opt: Bool = false): Null? \n```\n\nDisables shopt or set option.\n\n### Usage\n```ab\nimport { shopt_disable } from \"std/env\"\n\nshopt_disable(\"dotglob\")? // Hides files starting with \".\" during filename expansion\nshopt_disable(\"noglob\", true)? // Enables filename expansion (globbing)\n```\nFor all available options, see https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html\n\n## `shopt_enable`\n\n```ab\npub fun shopt_enable(optname: Text, set_opt: Bool = false): Null? \n```\n\nEnables shopt or set option.\n\n### Usage\n```ab\nimport { shopt_enable } from \"std/env\"\n\nshopt_enable(\"globstar\")? // Enables star (*) expansion for filenames\nshopt_enable(\"noglob\", true)? // Disables filename expansion (globbing). Note that this option doesn't properly work in a limited environment, e.g. GitHub Actions\n```\nFor all available options, see https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html\n\n## `styled`\n\n```ab\npub fun styled(message: Text, style: Int, fg: Int | Text, bg: Int | Text): Text \n```\n\nPrepares a text with formatting options for `printf`.\n\n### Usage\n```ab\nimport { styled } from \"std/env\"\n\nprintf(\"%s\\n\", [styled(\"Error!\", 1, 31, 40)])\nprintf(\"%s\\n\", [styled(\"Warning!\", 1, \"white\", \"yellow\")])\n```\n\n### Supported color names\n| Color name | Foreground code | Background code |\n| - | - |\n| black | 30 | 40 |\n| red | 31 | 41 |\n| green | 32 | 42 |\n| yellow | 33 | 43 |\n| orange | 93 | 103 |\n| blue | 34 | 44 |\n| purple | 35 | 45 |\n| cyan | 36 | 46 |\n| gray | 37 | 47 |\n| white | 97 | 107 |\n\nFor all supported color codes, please visit https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit\n\n## `umount`\n\n```ab\npub fun umount(target: Text): Null? \n```\n\nUnmounts a filesystem. Requires root privileges.\n\n### Usage\n```ab\nimport { umount } from \"std/env\"\n\numount(\"/mnt/disk\")?\n```\n\n## `umount_force`\n\n```ab\npub fun umount_force(target: Text): Null? \n```\n\nForce unmounts a filesystem. Requires root privileges.\n\n### Usage\n```ab\nimport { umount_force } from \"std/env\"\n\numount_force(\"/mnt/disk\")?\n```\n\n## `uname_all`\n\n```ab\npub fun uname_all(): Text \n```\n\nReturns all system information from uname.\n\n### Usage\n```ab\nimport { uname_all } from \"std/env\"\n\nconst info = uname_all()\necho(info) // e.g., \"Linux my-host 5.15.0 #1 SMP x86_64 GNU/Linux\"\n```\n\n## `uname_kernel_name`\n\n```ab\npub fun uname_kernel_name(): Text \n```\n\nReturns the kernel name (e.g., \"Linux\", \"Darwin\").\n\n### Usage\n```ab\nimport { uname_kernel_name } from \"std/env\"\n\nconst kernel = uname_kernel_name()\necho(kernel) // \"Linux\" or \"Darwin\"\n```\n\n## `uname_kernel_release`\n\n```ab\npub fun uname_kernel_release(): Text \n```\n\nReturns the kernel release version.\n\n### Usage\n```ab\nimport { uname_kernel_release } from \"std/env\"\n\nconst release = uname_kernel_release()\necho(release) // e.g., \"5.15.0-generic\"\n```\n\n## `uname_kernel_version`\n\n```ab\npub fun uname_kernel_version(): Text \n```\n\nReturns the kernel version.\n\n### Usage\n```ab\nimport { uname_kernel_version } from \"std/env\"\n\nconst version = uname_kernel_version()\necho(version)\n```\n\n## `uname_machine`\n\n```ab\npub fun uname_machine(): Text \n```\n\nReturns the machine hardware name (architecture).\n\n### Usage\n```ab\nimport { uname_machine } from \"std/env\"\n\nconst arch = uname_machine()\necho(arch) // e.g., \"x86_64\" or \"arm64\"\n```\n\n## `uname_nodename`\n\n```ab\npub fun uname_nodename(): Text \n```\n\nReturns the network node hostname.\n\n### Usage\n```ab\nimport { uname_nodename } from \"std/env\"\n\nconst host = uname_nodename()\necho(host) // e.g., \"my-computer\"\n```\n\n## `uname_os`\n\n```ab\npub fun uname_os(): Text \n```\n\nReturns the operating system name.\n\n### Usage\n```ab\nimport { uname_os } from \"std/env\"\n\nconst os = uname_os()\necho(os) // e.g., \"GNU/Linux\" or \"Darwin\"\n```\n\n## `underlined`\n\n```ab\npub fun underlined(message: Text): Text \n```\n\nReturns a text as underlined.\n\n### Usage\n```ab\nimport { underlined } from \"std/env\"\n\nprintf(\"%s\\n\", [underlined(\"Underlined text\")])\n```\n\n\n\n## `dir_create`\n\n```ab\npub fun dir_create(path: Text): Null? \n```\n\nCreates a directory with all parent directories as required.\n\n### Usage\n```ab\nimport { dir_create } from \"std/fs\"\n\ndir_create(\"/tmp/my/nested/directory\")\n```\n\n## `dir_exists`\n\n```ab\npub fun dir_exists(path: Text): Bool \n```\n\nChecks if a directory exists.\n\n### Usage\n```ab\nimport { dir_exists } from \"std/fs\"\n\nif dir_exists(\"/tmp/mydir\") {\n    echo(\"Directory exists\")\n}\n```\n\n## `escape_non_glob_chars`\n\n```ab\nfun escape_non_glob_chars(path: Text): Text \n```\n\nEscapes all characters in the passed-in glob except \"*\", \"?\" and \"/\",\nto prevent injection attacks.\n```ab\nimport { escape_non_glob_chars } from \"std/fs\"\n```\n## `file_append`\n\n```ab\npub fun file_append(path: Text, content: Text): Text? \n```\n\nAppends content to a file.\n\nDoesn't check if the file exists.\n\n### Usage\n```ab\nimport { file_append } from \"std/fs\"\n\nfile_append(\"log.txt\", \"New log entry\")\n```\n\n## `file_chmod`\n\n```ab\npub fun file_chmod(path: Text, mode: Text): Null? \n```\n\nChanges the permission bits of a file.\n\nIf the file doesn't exist, it fails and prints a message.\n\n### Usage\n```ab\nimport { file_chmod } from \"std/fs\"\n\nfile_chmod(\"script.sh\", \"755\")\n```\n\n## `file_chown`\n\n```ab\npub fun file_chown(path: Text, user: Text): Null? \n```\n\nChanges the owner of a file.\n\nIf the file doesn't exist, it fails and prints a message.\n\n### Usage\n```ab\nimport { file_chown } from \"std/fs\"\n\nfile_chown(\"/var/www/html\", \"www-data\")\n```\n\n## `file_compress`\n\n```ab\npub fun file_compress(files: [Text], target: Text): Null? \n```\n\nCompress file(s) or directories into an archive\nSupports: bz2, gz, xz, bz2, deb, rar, rpm, tar(gz/xz/bz), zip(war/jar), 7z\nNote: Not all supported methods support multiple files/directories\n### Usage\n```ab\nimport { file_compress } from \"std/fs\"\n\nfile_compress([\"main.ab\", \"src\"], \"amber.tar.gz\")?\nfile_compress([\"amber\"], \"amber.gz\")?\n```\n\n## `file_exists`\n\n```ab\npub fun file_exists(path: Text): Bool \n```\n\nChecks if a file exists.\n\n### Usage\n```ab\nimport { file_exists } from \"std/fs\"\n\nif file_exists(\"config.txt\") {\n    echo(\"File exists\")\n}\n```\n\n## `file_extract`\n\n```ab\npub fun file_extract(path: Text, target: Text): Null? \n```\n\nExtract the file detecting from the filename the extension\nSupports: bz2, gz, xz, bz2, deb, rar, rpm, tar(gz/xz/bz), zip(war/jar), 7z\nNote: Not all the commands supports the output folder path\n\n### Usage\n```ab\nimport { file_extract } from \"std/fs\"\n\nfile_extract(\"archive.tar.gz\", \"/tmp/extracted\")\n```\n\n## `file_glob`\n\n```ab\npub fun file_glob(path: Text): [Text]? \n```\n\nFinds all files or directories matching a file glob.\n\n### Usage\n```ab\nimport { file_glob } from \"std/fs\"\n\nlet files = file_glob(\"*.txt\")\n```\n\n## `file_glob_all`\n\n```ab\npub fun file_glob_all(paths: [Text]): [Text]? \n```\n\nFinds all files or directories matching multiple file globs. When\nwe have union types, this functionality can be merged into the main\n`file_glob` function.\n\n### Usage\n```ab\nimport { file_glob_all } from \"std/fs\"\n\nlet files = file_glob_all([\"*.txt\", \"*.md\"])\n```\n\n## `file_read`\n\n```ab\npub fun file_read(path: Text): Text? \n```\n\nGets file contents from a path.\n\n### Usage\n```ab\nimport { file_read } from \"std/fs\"\n\nlet content = file_read(\"data.txt\")\n```\n\n## `file_write`\n\n```ab\npub fun file_write(path: Text, content: Text): Text? \n```\n\nWrites content to a file.\nDoesn't check if the file exist\n\n### Usage\n```ab\nimport { file_write } from \"std/fs\"\n\nfile_write(\"output.txt\", \"Hello, World!\")\n```\n\n## `is_mac_os_mktemp`\n\n```ab\nfun is_mac_os_mktemp(): Bool \n```\n\nDetermine whether mktemp is macOS's.\n```ab\nimport { is_mac_os_mktemp } from \"std/fs\"\n```\n## `symlink_create`\n\n```ab\npub fun symlink_create(origin: Text, destination: Text): Null? \n```\n\nCreates a symbolic link, if destination exists it will be replaced.\n\nIf the file doesn't exist, it fails and prints a message.\n\n### Usage\n```ab\nimport { symlink_create } from \"std/fs\"\n\nsymlink_create(\"/usr/bin/python3\", \"/usr/local/bin/python\")\n```\n\n## `temp_dir_create`\n\n```ab\npub fun temp_dir_create(template: Text = \"tmp.XXXXXXXXXX\", auto_delete: Bool = false, force_delete: Bool = false): Text? \n```\n\nCreate a temporary directory and return the path.\nPlease note this does not respect _CS_DARWIN_USER_TEMP_DIR environment variable.\n\n### Usage\n```ab\nimport { temp_dir_create } from \"std/fs\"\n\nlet temp = temp_dir_create(\"myapp.XXXXXX\", true, false)\n```\n\n\n\n## `fetch`\n\n```ab\npub fun fetch(url: Text, method: Text = \"GET\", data: Text = \"\", headers: [Text] = [\"\"]): Text? \n```\n\nMakes a HTTP request using available command-line tools or bash's network sockets as failover.\n\nFor POST requests with a custom data type, you should include `content-type` header in `headers[]`.\n\n### Usage\n```ab\nimport { fetch } from \"std/http\"\n\nlet response = trust fetch(\"https://example.com\")\n\n// POST request example\nlet post_request = trust fetch(\"https://example.com\", \"POST\", \"hello world!\", [\n    \"content-type: text/plain\"\n])\n```\n\n## `file_download`\n\n```ab\npub fun file_download(url: Text, path: Text): Null? \n```\n\nDownloads a file from a given URL and saves it to a specified path using available command-line tools.\n\nIt checks for the availability of common command-line tools (`curl`, `wget`, and `aria2c`, in order) and uses the first available tool to perform the download.\nIf none of the tools are available, the function fails.\n\n### Usage\n```ab\nimport { file_download } from \"std/http\"\n\nfile_download(\"https://example.com/file.zip\", \"/tmp/file.zip\")\n```\n\n\n\n## `math_abs`\n\n```ab\npub fun math_abs(number) \n```\n\nReturns the absolute value of a number\n\n### Usage\n```ab\nimport { math_abs } from \"std/math\"\n\nlet absolute = math_abs(-42)\necho(absolute) // 42\n```\n\n## `math_ceil`\n\n```ab\npub fun math_ceil(number: Num): Int \n```\n\nReturns the smallest integer greater than or equal to a number\n\n### Usage\n```ab\nimport { math_ceil } from \"std/math\"\n\nlet ceiled = math_ceil(3.1)\necho(ceiled) // 4\n```\n\n## `math_floor`\n\n```ab\npub fun math_floor(number: Num): Int \n```\n\nReturns the largest integer less than or equal to a number\n\n### Usage\n```ab\nimport { math_floor } from \"std/math\"\n\nlet floored = math_floor(3.9)\necho(floored) // 3\n```\n\n## `math_round`\n\n```ab\npub fun math_round(number: Num): Int \n```\n\nReturns a number, rounded to the nearest integer\n\n### Usage\n```ab\nimport { math_round } from \"std/math\"\n\nlet rounded = math_round(3.7)\necho(rounded) // 4\n```\n\n## `math_sum`\n\n```ab\npub fun math_sum(list) \n```\n\nSums an array's contents\n\n### Usage\n```ab\nimport { math_sum } from \"std/math\"\n\nlet total = math_sum([1, 2, 3, 4, 5])\necho(total) // 15\n```\n\n\n\n## `assert`\n\n```ab\npub fun assert(condition: Bool) \n```\n\nAsserts that a boolean condition is true. Fails the test with exit code `1` if false.\n### Usage\n```ab\nimport { assert } from \"std/test\"\n\nlet user_age = 18\nassert(user_age >= 18)\n```\n\n## `assert_eq`\n\n```ab\npub fun assert_eq(left, right) \n```\n\nAsserts that two values are equal. Fails the test with exit code `1` if they are not equal.\n### Usage\n```ab\nimport { assert_eq } from \"std/test\"\n\nlet expected = [1, 2, 3]\nlet actual = [1, 2, 3]\nassert_eq(expected, actual)\n```\n\n\n\n## `bash_version`\n\n```ab\nfun bash_version(): [Int] \n```\n\n## `capitalized`\n\n```ab\npub fun capitalized(text: Text): Text \n```\n\nCapitalize the first letter of the given `text`.\n\n### Usage\n```ab\nimport { capitalized } from \"std/text\"\n\nconst cap = capitalized(\"hello\")\necho(cap) // \"Hello\"\n```\n\n## `char_at`\n\n```ab\npub fun char_at(text: Text, index: Int): Text \n```\n\nReturns the character from `text` at the specified `index` (0-based).\n\nIf `index` is negative, the substring starts from the end of `text` based on the absolute value of `index`.\n\n### Usage\n```ab\nimport { char_at } from \"std/text\"\n\nconst ch = char_at(\"hello\", 1)\necho(ch) // \"e\"\n```\n\n## `count_chars`\n\n```ab\npub fun count_chars(text: Text): Int \n```\n\nCounts the number of characters in the given text.\n\n### Usage\n```ab\nimport { count_chars } from \"std/text\"\n\nconst count = count_chars(\"hello\")\necho(count) // 5\n```\n\n## `count_lines`\n\n```ab\npub fun count_lines(text: Text): Int \n```\n\nCounts the number of lines in the given text.\n\n### Usage\n```ab\nimport { count_lines } from \"std/text\"\n\nconst count = count_lines(\"one\\ntwo\\nthree\")\necho(count) // 3\n```\n\n## `count_words`\n\n```ab\npub fun count_words(text: Text): Int \n```\n\nCounts the number of words in the given text.\n\n### Usage\n```ab\nimport { count_words } from \"std/text\"\n\nconst count = count_words(\"hello world foo\")\necho(count) // 3\n```\n\n## `ends_with`\n\n```ab\npub fun ends_with(text: Text, suffix: Text): Bool \n```\n\nChecks if text ends with a value.\n\n### Usage\n```ab\nimport { ends_with } from \"std/text\"\n\nif ends_with(\"hello world\", \"world\") {\n    echo(\"Ends with world!\")\n}\n```\n\n## `join`\n\n```ab\npub fun join(list: [Text], delimiter: Text): Text \n```\n\nMerges text using the delimiter specified.\n\n### Usage\n```ab\nimport { join } from \"std/text\"\n\nconst joined = join([\"a\", \"b\", \"c\"], \",\")\necho(joined) // \"a,b,c\"\n```\n\n## `lowercase`\n\n```ab\npub fun lowercase(text: Text): Text \n```\n\nMakes the text input lowercase using `tr`.\n\n### Usage\n```ab\nimport { lowercase } from \"std/text\"\n\nconst lower = lowercase(\"HELLO\")\necho(lower) // \"hello\"\n```\n\n## `lpad`\n\n```ab\npub fun lpad(text: Text, pad: Text, length: Int): Text \n```\n\nPads `text` with the specified `pad` character on left until it reaches the desired `length`.\n\n### Usage\n```ab\nimport { lpad } from \"std/text\"\n\nconst padded = lpad(\"42\", \"0\", 5)\necho(padded) // \"00042\"\n```\n\n## `match_regex`\n\n```ab\npub fun match_regex(source: Text, search: Text, extended: Bool = false): Bool \n```\n\nMatch all occurrences of a regex pattern.\n\nFunction uses `sed`\n\n### Usage\n```ab\nimport { match_regex } from \"std/text\"\n\nif match_regex(\"test123\", \"[0-9]+\", true) {\n    echo(\"Contains numbers!\")\n}\n```\n\n## `match_regex_any`\n\n```ab\npub fun match_regex_any(text: Text, terms: [Text]): Bool \n```\n\nChecks if an array value (with regular expression) is in the text.\n\n### Usage\n```ab\nimport { match_regex_any } from \"std/text\"\n\nif match_regex_any(\"test123\", [\"[a-z]+\", \"[0-9]+\"]) {\n    echo(\"Matches at least one pattern!\")\n}\n```\n\n## `parse_int`\n\n```ab\npub fun parse_int(text: Text): Int? \n```\n\nAttempts to parse a given text into an `Int` number.\n\n### Usage\n```ab\nimport { parse_int } from \"std/text\"\n\nconst num = parse_int(\"42\")?\necho(num) // 42\n```\n\n## `parse_num`\n\n```ab\npub fun parse_num(text: Text): Num? \n```\n\nAttempts to parse a given text into a `Num` number.\n\n### Usage\n```ab\nimport { parse_num } from \"std/text\"\n\nconst num = parse_num(\"3.14\")?\necho(num) // 3.14\n```\n\n## `replace`\n\n```ab\npub fun replace(source, search, replace) \n```\n\nReplaces all occurrences of a pattern in the content with the provided replace text.\n\n### Usage\n```ab\nimport { replace } from \"std/text\"\n\nconst result = replace(\"Hello world\", \"world\", \"universe\")\necho(result) // \"Hello universe\"\n```\n\n## `replace_one`\n\n```ab\npub fun replace_one(source, search, replace) \n```\n\nReplaces the first occurrence of a pattern in the content with the provided replace text.\n\n### Usage\n```ab\nimport { replace_one } from \"std/text\"\n\nconst result = replace_one(\"foo foo foo\", \"foo\", \"bar\")\necho(result) // \"bar foo foo\"\n```\n\n## `replace_regex`\n\n```ab\npub fun replace_regex(source: Text, search: Text, replace_text: Text, extended: Bool = false): Text \n```\n\nReplaces all occurrences of a regex pattern in the content with the provided replace text.\nFunction uses `sed` and supports capture groups syntax in extended mode.\n\n### Usage\n```ab\nimport { replace_regex } from \"std/text\"\n\nconst result = replace_regex(\"test123\", \"[0-9]+\", \"456\", true)\necho(result) // \"test456\"\n// Also supports replace regex\necho(replace_regex(\"Put number 255 in brackets\", \"([0-9]+)\", \"(\\1)\", true)); // Put number (255) in brackets\n```\n\n## `reversed`\n\n```ab\npub fun reversed(text: Text): Text \n```\n\nReverses text using `rev`.\n\n### Usage\n```ab\nimport { reversed } from \"std/text\"\n\nconst reversed_text = reversed(\"hello\")\necho(reversed_text) // \"olleh\"\n```\n\n## `rpad`\n\n```ab\npub fun rpad(text: Text, pad: Text, length: Int): Text \n```\n\nPads `text` with the specified `pad` character on the right until it reaches the desired `length`.\n\n### Usage\n```ab\nimport { rpad } from \"std/text\"\n\nconst padded = rpad(\"42\", \"0\", 5)\necho(padded) // \"42000\"\n```\n\n## `sed_version`\n\n```ab\nfun sed_version(): Int \n```\n\n## `slice`\n\n```ab\npub fun slice(text: Text, index: Int, length: Int = 0): Text \n```\n\nReturns a substring from `text` starting at the given `index` (0-based).\n\nIf `index` is negative, the substring starts from the end of `text` based on the absolute value of `index`.\nIf `length` is provided, the substring will include `length` characters; otherwise, it slices to the end of `text`.\nIf `length` is negative, an empty string is returned.\n\n### Usage\n```ab\nimport { slice } from \"std/text\"\n\nconst sub = slice(\"hello world\", 6, 5)\necho(sub) // \"world\"\n```\n\n## `sort_lines`\n\n```ab\npub fun sort_lines(text: Text, desc: Bool = false, numeric: Bool = false): Text \n```\n\nSorts lines of text in ascending, descending or numerial order.\n\n### Usage\n```ab\nimport { sort_lines } from \"std/text\"\n\nlet sorted = sort_lines(\"banana\\napple\\ncherry\")\necho(sorted) // \"apple\\nbanana\\ncherry\"\n\nsorted = sort_lines(\"banana\\napple\\ncherry\", true) // Sorts lines of text in descending order\necho(sorted) // \"cherry\\nbanana\\napple\"\n\nsorted = sort_lines(\"10\\n2\\n1\", false, true) // Sorts lines of text numerically\necho(sorted) // \"1\\n2\\n10\"\n```\n\n## `split`\n\n```ab\npub fun split(text: Text, delimiter: Text): [Text] \n```\n\nSplits the input `text` into an array of substrings using the specified `delimiter`.\n\n### Usage\n```ab\nimport { split } from \"std/text\"\n\nconst parts = split(\"a,b,c\", \",\")\necho(parts[0]) // \"a\"\n```\n\n## `split_chars`\n\n```ab\npub fun split_chars(text: Text): [Text] \n```\n\nSplits a text into an array of individual characters.\n\n### Usage\n```ab\nimport { split_chars } from \"std/text\"\n\nconst chars = split_chars(\"hello\")\necho(chars[0]) // \"h\"\n```\n\n## `split_lines`\n\n```ab\npub fun split_lines(text: Text): [Text] \n```\n\nSplits a `text` into an array of substrings based on newline characters.\n\n### Usage\n```ab\nimport { split_lines } from \"std/text\"\n\nconst lines = split_lines(\"line1\\nline2\\nline3\")\necho(lines[0]) // \"line1\"\n```\n\n## `split_words`\n\n```ab\npub fun split_words(text: Text): [Text] \n```\n\nSplits a `text` into an array of substrings based on space character.\n\n### Usage\n```ab\nimport { split_words } from \"std/text\"\n\nconst words = split_words(\"hello world example\")\necho(words[1]) // \"world\"\n```\n\n## `starts_with`\n\n```ab\npub fun starts_with(text: Text, prefix: Text): Bool \n```\n\nChecks if text starts with a value.\n\n### Usage\n```ab\nimport { starts_with } from \"std/text\"\n\nif starts_with(\"hello world\", \"hello\") {\n    echo(\"Starts with hello!\")\n}\n```\n\n## `text_contains`\n\n```ab\npub fun text_contains(source: Text, search: Text): Bool \n```\n\nChecks if some text contains a value.\n\n### Usage\n```ab\nimport { text_contains } from \"std/text\"\n\nif text_contains(\"hello world\", \"world\") {\n    echo(\"Found!\")\n}\n```\n\n## `text_contains_all`\n\n```ab\npub fun text_contains_all(source: Text, searches: [Text]): Bool \n```\n\nChecks if all the arrays values are in the string\n\n### Usage\n```ab\nimport { text_contains_all } from \"std/text\"\n\nif text_contains_all(\"hello world\", [\"hello\", \"world\"]) {\n    echo(\"All found!\")\n}\n```\n\n## `text_contains_any`\n\n```ab\npub fun text_contains_any(source: Text, searches: [Text]): Bool \n```\n\nChecks if an array value is in the text.\n\n### Usage\n```ab\nimport { text_contains_any } from \"std/text\"\n\nif text_contains_any(\"hello world\", [\"foo\", \"world\", \"bar\"]) {\n    echo(\"Found at least one!\")\n}\n```\n\n## `trim`\n\n```ab\npub fun trim(text: Text): Text \n```\n\nTrims the spaces from the text input.\n\n### Usage\n```ab\nimport { trim } from \"std/text\"\n\nconst trimmed = trim(\"   hello   \")\necho(trimmed) // \"hello\"\n```\n\n## `trim_left`\n\n```ab\npub fun trim_left(text: Text): Text \n```\n\nTrims the spaces at top of the text using `sed`.\n\n### Usage\n```ab\nimport { trim_left } from \"std/text\"\n\nconst trimmed = trim_left(\"   hello\")\necho(trimmed) // \"hello\"\n```\n\n## `trim_right`\n\n```ab\npub fun trim_right(text: Text): Text \n```\n\nTrims the spaces at end of the text using `sed`.\n\n### Usage\n```ab\nimport { trim_right } from \"std/text\"\n\nconst trimmed = trim_right(\"hello   \")\necho(trimmed) // \"hello\"\n```\n\n## `uniq_lines`\n\n```ab\npub fun uniq_lines(text: Text, remove_all: Bool = false): Text \n```\n\nRemoves duplicate lines from text.\n\n### Usage\n```ab\nimport { uniq_lines } from \"std/text\"\n\nlet result = uniq_lines(\"foo\\nfoo\\nbar\\nbar\\nbaz\")\necho(result) // \"foo\\nbar\\nbaz\"\n\nlet result = uniq_lines(\"foo\\nbar\\nfoo\\nbaz\\nbar\", true) // Removes all duplicate lines from text (not just consecutive)\necho(result) // \"foo\\nbar\\nbaz\"\n```\n\n## `uppercase`\n\n```ab\npub fun uppercase(text: Text): Text \n```\n\nMakes the text input uppercase using `tr`.\n\n### Usage\n```ab\nimport { uppercase } from \"std/text\"\n\nconst upper = uppercase(\"hello\")\necho(upper) // \"HELLO\"\n```\n\n## `zfill`\n\n```ab\npub fun zfill(text: Text, length: Int): Text \n```\n\nPads `text` with zeros on the left until it reaches the desired `length`.\n\n### Usage\n```ab\nimport { zfill } from \"std/text\"\n\nconst padded = zfill(\"42\", 5)\necho(padded) // \"00042\"\n```"}
